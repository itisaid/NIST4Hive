This file lists specifies test cases developed by National Computing Centre
and Computer Logic under the European Community sponsored CTS5 SQL2 Project.
This file documents test cases as they were turned over to NIST.
----------------------------------------------------------------------------


CTS5 SQL2 Test Purpose 001: Feature #25

IDENTIFICATION
     TEST7500, YTS750

DESCRIPTION
     CREATE DOMAIN as SQL procedure statement, no options

REFERENCES
     11.21 SR.1
     11.21 GR.3
     21.2.5 -- DOMAINS view
     F# 25 -- Domain definition
     F# 3 -- Basic schema manipulation
     F# 2 -- Basic information schema

TEST PURPOSE
To determine that when a <domain definition> which specifies a
data  type of INTEGER and does not specify any of the optional
elements  "AS",  <default  clause>,  <domain  constraint>  and
<collate clause> and is not contained in a <schema definition>
is   executed,  then  a  domain  descriptor  is  created  that
describes the specified domain.

NOGO:
     None.

TEST SPECIFICATION
Ensure   that   the   schema  associated  with   the   current
authorization identifier does not contain a domain  descriptor
for  a domain with the same domain name as the domain that  is
to be created.

Execute  as  an  <SQL schema statement> a <domain  definition>
that  specifies  a  <data  type> of INTEGER  and  contains  no
optional elements.

Check that the value returned in SQLSTATE or SQLCODE (or both)
indicates  successful execution. Commit the  creation  of  the
domain. (Note that some implementations have been known do  an
implicit  commit  after  every Schema Manipulation  statement.
That  is not the subject of this test, and an explicit  COMMIT
here will put most implementations into the same state.)

Check  that  a  row  containing a correct description  of  the
domain   specified  in  the  <domain  definition>  has  become
accessible through the DOMAINS view in the Information Schema.


PROGRAMMING SPECIFICATION
Create   a  program  that  will  execute  under  authorization
identifier "CTS5" using schema "CTS5". Schema CTS5 should  not
normally  contain a domain descriptor that describes a  domain
named "intdomain".

If  the  schema  associated  with  the  current  authorization
identifier  contains  a  domain descriptor  that  describes  a
domain with the domain name "intdomain", then execute a  <drop
domain  statement> that will destroy that domain with  CASCADE
drop behaviour.

Initialise  variables SQLSTATE and SQLCODE  with  values  that
differ  from "00000" and zero, respectively. Create the domain
intdomain by executing the <SQL schema statement>:

     CREATE DOMAIN intdomain INTEGER

If  SQLSTATE  does  not contain "00000" and SQLCODE  does  not
contain 0, then record an error.

Initialise  variables SQLSTATE and SQLCODE  with  values  that
differ  from "00000" and zero, respectively. Execute a <select
statement:  single  row> to retrieve into host  variables  all
columns of the Information Schema viewed table DOMAINS for the
row where:

     DOMAIN_SCHEMA = 'CTS5'  AND
     DOMAIN_NAME = 'intdomain'

In  the statement, associate indicator variables with all host
variables  into  which values are retrieved so  as  to  permit
checking for null values.

Record  an error if either SQLSTATE or SQLCODE indicates  that
either  no  qualifying  row or multiple qualifying  rows  were
found.

If a row has been returned, check that the value returned from
the  DATA_TYPE  column  is 'INTEGER'.  If  the  value  is  not
'INTEGER', record an error.

If a row has been returned, check that the value returned from
the  NUMERIC_SCALE column is not null and has the value 0.  If
the value is null or non-zero,  record an error.

If a row has been returned, check that the value returned from
the NUMERIC_PRECISION_RADIX column is not null and has a value
in  the  set (2, 10). If the value is null or not one  of  the
specified values,  record an error.

If a row has been returned, check that the value returned from
the  NUMERIC_PRECISION column is not null.  If  the  value  is
null, record an error.

If a row has been returned, check that the value returned from
the  DOMAIN_DEFAULT column is null. If the value is not  null,
record an error.

If  a  row  has been returned, then if the indicator  variable
associated with any of the columns:
CHARACTER_MAXIMUM_LENGTH,
CHARACTER_OCTET_LENGTH,
COLLATION_CATALOG,
COLLATION_SCHEMA,
COLLATION_NAME,
CHARACTER_SET_CATALOG,
CHARACTER_SET_SCHEMA,
CHARACTER_SET_NAME,
DATETIME_PRECISION, does not indicate the null  value,  record
an error.

If no error has been recorded, then insert a row indicating  a
pass into the TESTREPORT table.

If  any  error  has  been recorded, insert  a  row  indicating
failure into the TESTREPORT table.

Commit the insertion of a row into the TESTREPORT table.

Where  an  error  has  been detected,  display  any  available
diagnostic information.

Note  that  the program should leave the domain definition  in
place  when  it terminates, and drop the domain  if  necessary
when  it  starts execution. This will facilitate diagnosis  of
the causes of any errors that are reported.



CTS5 SQL2 Test Purpose 002: Feature #25

IDENTIFICATION
     TEST7501, YTS751

DESCRIPTION
     CREATE DOMAIN as SQL procedure statement, with default

REFERENCES
     11.21 SR.1
     11.21 GR.3
     11.5 -- <default clause>
     21.2.5 -- DOMAINS view
     F# 25 -- Domain definition
     F# 3 -- Basic schema manipulation
     F# 2 -- Basic information schema

TEST PURPOSE
To determine that when a <domain definition> that specifies  a
data  type  of  CHARACTER and a domain default  and  does  not
specify  either  of the optional elements <domain  constraint>
and  <collate  clause>  and  is not  contained  in  a  <schema
definition> is executed, then a domain descriptor  is  created
that describes the specified domain.

NOGO:
     None.

TEST SPECIFICATION
Ensure   that   the   schema  associated  with   the   current
authorization identifier does not contain a domain  descriptor
for  a domain with the same domain name as the domain that  is
to be created.

Execute  as  an  <SQL schema statement> a <domain  definition>
that  specifies  a  <data type> of CHARACTER  and  a  <default
clause> and specifies neither of the optional elements <domain
constraint> and <collate clause>.

Check that the value returned in SQLSTATE or SQLCODE (or both)
indicates  successful execution. Commit the  creation  of  the
domain. (Note that some implementations have been known do  an
implicit  commit  after  every Schema Manipulation  statement.
That  is not the subject of this test, and an explicit  COMMIT
here will put most implementations into the same state.)

Check  that  a  row  containing a correct description  of  the
domain   specified  in  the  <domain  definition>  has  become
accessible through the DOMAINS view in the Information Schema.


PROGRAMMING SPECIFICATION
Create   a  program  that  will  execute  under  authorization
identifier "CTS5". The schema identified by that authorization
identifier  should  not normally contain a  domain  descriptor
that describes a domain with the domain name "chardomain".

If  the  schema  associated  with  the  current  authorization
identifier  contains  a  domain descriptor  that  describes  a
domain with the domain name "chardomain", then execute a <drop
domain  statement> that will destroy that domain with  CASCADE
drop behaviour.

Initialise  variables SQLSTATE and SQLCODE  with  values  that
differ  from "00000" and zero, respectively. Create the domain
chardomain by executing the <SQL schema statement>:

     CREATE    DOMAIN   chardomain   AS   CHAR(10)     DEFAULT
     'MANCHESTER'

If  SQLSTATE  does  not contain "00000" and SQLCODE  does  not
contain 0, then record an error.

Initialise  variables SQLSTATE and SQLCODE  with  values  that
differ  from "00000" and zero, respectively. Use a  COUNT  (*)
aggregate function  to check that there is exactly one row  in
the Information Schema viewed table DOMAINS where:
     DOMAIN_SCHEMA = 'CTS5' AND
     DOMAIN_NAME = chardomain

If  there  is not exactly one such row, or if the  attempt  to
retrieve  the count of such rows was unsuccessful,  record  an
error.

Initialise  variables SQLSTATE and SQLCODE  with  values  that
differ  from "00000" and zero, respectively. Execute a <select
statement:  single  row> to retrieve into host  variables  all
columns of the Information Schema viewed table DOMAINS for the
row where:

     DOMAIN_SCHEMA = 'CTS5' AND
     DOMAIN_NAME = chardomain

In  the statement, associate indicator variables with all host
variables  into  which values are retrieved so  as  to  permit
checking for null values.

If  SQLSTATE  does  not contain "00000" and SQLCODE  does  not
contain 0, then record an error.

Record  an error if either SQLSTATE or SQLCODE indicates  that
either  no  qualifying  row or multiple qualifying  rows  were
found.

If a row has been returned, check that the value returned from
the DATA_TYPE column is 'CHARACTER'. If the value is null,  or
is  not 'CHARACTER', record an error. (Note that 'CHAR' is not
an acceptable alternative in this context.)

If a row has been returned, check that the value returned from
the  CHARACTER_MAXIMUM_LENGTH column is 10. If  the  value  is
null or is not 10, record an error.

If a row has been returned, check that the value returned from
the  DOMAIN_DEFAULT column is 'MANCHESTER'. If  the  value  is
null or is not 'MANCHESTER', record an error.

If  a  row  has been returned, then if the indicator  variable
associated with any of the columns:
CHARACTER_OCTET_LENGTH,
COLLATION_CATALOG,
COLLATION_SCHEMA,
COLLATION_NAME,
CHARACTER_SET_CATALOG,
CHARACTER_SET_SCHEMA,
CHARACTER_SET_NAME,
indicates the null value, record an error.

If  a  row  has been returned, then if the indicator  variable
associated with any of the columns:
NUMERIC_PRECISION,
NUMERIC_PRECISION_RADIX,
NUMERIC_SCALE,
DATETIME_PRECISION
 does not indicate the null value, record an error.

If no error has been recorded, then insert a row indicating  a
pass into the TESTREPORT table.

If  any  error  has  been recorded, insert  a  row  indicating
failure into the TESTREPORT table.

Commit the insertion of the row into the TESTREPORT table.

Where  an  error  has  been detected,  display  any  available
diagnostic information.

Note  that  the program should leave the domain definition  in
place  when  it terminates, and drop the domain  if  necessary
when  it  starts execution. This will facilitate diagnosis  of
the causes of any errors that are reported.



CTS5 SQL2 Test Purpose 003: Feature #25

IDENTIFICATION
     TEST7502, YTS752

DESCRIPTION
     CREATE DOMAIN as SQL procedure statement, with constraint

REFERENCES
     11.21 SR.1
     11.21 GR.3
     11.3 -- <table definition>
     11.4 -- <column definition>
     10.6 GR4 -- Integrity constraint violation
     11.9 -- <check constraint definition>
     F# 25 -- Domain definition
     F# 3 -- Basic schema manipulation

TEST PURPOSE
To determine that when a <domain definition> that specifies  a
data  type  of SMALLINT and a <domain CONSTRAINT> default  and
does  not  specify  either of the optional  elements  <default
clause> and <collate clause> and is not contained in a <schema
definition> is executed, then that domain is created  and  may
be referenced in s subsequent <column definition>.

NOGO:
     None.

TEST SPECIFICATION
Ensure   that   the   schema  associated  with   the   current
authorization identifier does not contain a domain  descriptor
for  a domain with the same domain name as the domain that  is
to  be created or a table descriptor for the table that is  to
be created.

Execute  as  an  <SQL schema statement> a <domain  definition>
that  specifies a <data type> of SMALLINT and a single <domain
constraint>,  and  specifies neither of the optional  elements
<default clause> and <collate clause>.

Check that the value returned in SQLSTATE or SQLCODE (or both)
indicates  successful execution. Commit the  creation  of  the
domain. (Note that some implementations have been known do  an
implicit  commit  after  every Schema Manipulation  statement.
That  is not the subject of this test, and an explicit  COMMIT
here will put most implementations into the same state.)

Execute as an <SQL schema statement> a <table definition> that
specifies creation of a table with two or more columns, one of
which is based on the domain defined in this test. Check  that
the  value returned in SQLSTATE or SQLCODE (or both) indicates
successful execution. Commit the creation of the table

Attempt  to  insert  into the table four rows,  one  of  which
contains,  in the column defined on the domain, a  value  that
does  not  satisfy the domain constraint and another of  which
contains  a value that is greater than the maximum value  that
can  be  held  in a SMALLINT item. Check that the attempts  to
insert these rows are unsuccessful and that only the two  rows
without errors are stored in the database.


PROGRAMMING SPECIFICATION
Create   a  program  that  will  execute  under  authorization
identifier "CTS5". The schema identified by that authorization
identifier  should  not normally contain a  domain  descriptor
that  describes a domain with the domain name "sintdom"  or  a
table  descriptor that describes a table with the  table  name
"shorttab".

If  the  schema  associated  with  the  current  authorization
identifier  contains  a  domain descriptor  that  describes  a
domain  with the domain name "sintdom", then execute  a  <drop
domain  statement> that will destroy that domain with  CASCADE
drop  behaviour.  If the schema associated  with  the  current
authorization  identifier contains  a  table  descriptor  that
describes a table with the table name "shorttab", then execute
a  <drop  table statement> that will destroy that  table  with
CASCADE drop behaviour.

Initialise  variables SQLSTATE and SQLCODE  with  values  that
differ  from "00000" and zero, respectively. Create the domain
sintdom by executing the <SQL schema statement>:

     CREATE DOMAIN sintdom AS SMALLINT
        CHECK (VALUE > 5)

If  SQLSTATE  does  not contain "00000" and SQLCODE  does  not
contain 0, then record an error.

Commit the creation of the domain.

Initialise  variables SQLSTATE and SQLCODE  with  values  that
differ  from "00000" and zero, respectively. Create the  table
shorttab by executing the <SQL schema statement>:

     CREATE TABLE shorttab
        (keycol integer,
         domcol sintdom)

If  SQLSTATE  does  not contain "00000" and SQLCODE  does  not
contain 0, then record an error.

Commit the creation of the table.

Attempt to insert the following rows into the table shorttab:

     (1, 6),  (2, 3),  (3, 123456789), (4, 100)

Use  a host variable as the source of the second value of each
pair. For rows 1 and 4, check that at least one of SQLCODE and
SQLSTATE  indicates  a  successful completion  of  the  insert
operation.   For   row  2,  check  that   the   insertion   is
unsuccessful, with the value "23000" returned in SQLSTATE or a
negative  value  returned in SQLCODE,  or  both  those  values
returned. For row 3, check that the insertion is unsuccessful,
with  the  value "22003" returned in SQLSTATE  or  a  negative
value returned in SQLCODE, or both. If any of the checks fail,
record an error.

Commit the insertion of values into the table shorttab.

Check  that the table shorttab contains exactly two  rows  and
that  these  contain  the values (1,  6)  and  (4,  100).,  by
retrieving  a  count  of  the  rows  in  the  table  and  then
retrieving,   using   the  <select  statement:   single   row>
statement, the rows with values 1 and 4 in column "keycol". If
any of these checks fails, record an error.

If no error has been recorded, then insert a row indicating  a
pass into the TESTREPORT table.

If  any  error  has  been recorded, insert  a  row  indicating
failure into the TESTREPORT table.

Commit the insertion of a row into the TESTREPORT table.

Where  an  error  has  been detected,  display  any  available
diagnostic information.

Note  that the program should leave the domain definition  and
table definition and contents in place when it terminates, and
drop  the  domain  and  table  if  necessary  when  it  starts
execution. This will facilitate diagnosis of the causes of any
errors that are reported.



CTS5 SQL2 Test Purpose 004: Feature #25

IDENTIFICATION
     TEST7503, YTS753

DESCRIPTION
     DROP DOMAIN RESTRICT

REFERENCES
     11.27 -- <drop domain statement>
     11.21 -- <domain definition>
     21.2.5 -- DOMAINS VIEW
     F#25 -- Domain definition
     F#3 -- Basic Schema Manipulation

TEST PURPOSE
To  determine  that  a <drop domain statement>  with  RESTRICT
behaviour will not destroy a domain which is used in a  column
descriptor  in a column in a table owned by the current  user,
but will drop a domain that is not in use.

NOGO:
     None.

TEST SPECIFICATION
Ensure that the current user has a domain x

Create a table t with a column based on x

Attempt  to  drop domain x with RESTRICT - check  for  failure
with SQLSTATE "42000", as SR2 of 11.27 is not satisfied

Record a fail if the drop has been successful

Drop table t - and with it the only use of the domain

Drop the domain x again - this attempt should work

As a final check that the domain has gone, try to recreate the
table,  the  attempt should fail, with SQLSTATE value  "42000"
again.

After  every execution of an SQL statement, unless some  other
check  is specified, check that the value returned in SQLSTATE
indicates successful completion.

If  any  check  fails, record a verdict of  'fail',  otherwise
record a verdict of 'pass'.

(Editorial change, 26 June 1995)


CTS5 SQL2 Test Purpose 005: Feature #25

IDENTIFICATION
     TEST7504, YTS754

DESCRIPTION
     DROP DOMAIN CASCADE - domain definition in use

REFERENCES
     11.27  --  <drop domain statement>
     11.21  --  <domain definition>
     11.3  --  <table definition>
     11.4  --  <column definition>
     F#25  --  Domain definition
     F#3   --  Basic Schema Manipulation

TEST PURPOSE
Let D be a domain that does not have a default, domain
constraint or an explicit collation and is owned by the
current user. To determine that when D is referenced in the
column descriptor of a column in a table owned by the current
user, then execution of a <drop domain statement> with <drop
behaviour> of CASCADE that specifies D is successful, and that
values in the table are unchanged.

NOGO:
     None.

TEST SPECIFICATION
Ensure the current user owns domain y which is not in use.
This domain should not have any domain constraint or explicit
collation.

Create a table, T, with one column based on domain y and at
least one other column.

Commit the creation of  table T.

Populate the table with three rows, with valid values for
domain y in the column based on y and values in another column
that can be used to distinguish the rows from each other.

Commit the population of T.

Drop domain y using a <drop domain statement> with behaviour
CASCADE

Commit the dropping of domain y.

Use a cursor to retrieve all the rows from the table T.

Check that all rows are present and that the values in the
column that was based on y have not changed.

Insert a row into the table with a value in the column that
was based on y that would have been acceptable in a column
based on y.

Except where a check for some other value is specified or
implied, after execution of each SQL statement check that the
value returned in SQLSTATE indicates successful completion.

If any check has failed, record a verdict of 'fail', otherwise
record a verdict of 'pass'.

Drop the table that was created in the course of the test.


(Revised 14 July 1995)



CTS5 SQL2 Test Purpose 006: Feature #25

IDENTIFICATION
     TEST7505, YTS755

DESCRIPTION
     DROP DOMAIN CASCADE - domain with default and constraint

REFERENCES
     11.27  --  <drop domain statement>
     11.27 GR1b
     11.27 GR1c
     11.21  --  <domain definition>
     F#25  --  Domain Definition
     F#3 -- Basic schema manipulation

TEST PURPOSE
To  determine  that  successful execution  of  a  DROP  DOMAIN
statement   with  behaviour  CASCADE  causes  the  data   type
descriptor  of  the  domain  to  be  included  in  the  column
descriptor of any column that is defined on the domain, causes
any  domain  constraint contained in the domain descriptor  to
become  a  table constraint of any table containing  a  column
defined on the domain, and destroys the domain.

NOGO:
     None.

TEST SPECIFICATION
Ensure  that a domain z exists which is not in use and  has  a
default clause and constraint associated with it

Create a table that contains a column based on domain z

Populate   the  table  with  three  rows  which  satisfy   the
constraint.

Check  that  SQLSTATE  indicates success  after  each  row  is
inserted.

Drop  domain  z using a <drop domain statement>  with  CASCADE
behaviour specified.

Check that SQLSTATE indicates success.

Check that the domain constraint has become a table constraint
by  attempting  to  add a row to the table  which  breaks  the
constraint. Check that SQLSTATE does not record success.

Check that the table does not contain the row.

Insert a row that causes the default to be invoked

Retrieve  the  row from the table and record  a  fail  if  the
column does not contain the expected value.

If any of the subtests have failed record a 'fail' else record
a 'pass'.


(Editorial changes 8 February 1995)



CTS5 SQL2 Test Purpose 007: Feature #25

IDENTIFICATION
     TEST7506, YTS756

DESCRIPTION
     Domain Constraint Containing VALUE

REFERENCES
     6.2  SR5 -- <value specification>
     6.11 -- <value expression>
     11.21 GR5 -- <domain definition>
     11.3 -- <table definition>
     11.4  -- <column definition>
     11.9 -- <check constraint definition>
     8.2 -- <comparison predicate>
     8.5 -- <like predicate>
     4.10.3 -- Domain Constraints
     8.12 -- <search condition>
     F#25 --Domain Definition
     F#3 -- Basic Schema Manipulation

TEST PURPOSE
To  determine that VALUE may be specified as a <general  value
specification>  in  a  <predicate> in  the  <check  constraint
definition> of a <domain constraint>, and that when evaluating
the  constraint  for any row of a table, VALUE is  effectively
replaced by the VALUE that exists, or would be placed in,  the
column defined on the domain.

NOGO:
     None

TEST SPECIFICATION
Ensure  that the current user owns domain d which has a domain
constraint  that  contains an <in predicate>  that  references
VALUE.

Ensure  that  the current user owns a domain  e  which  has  a
domain  constraint  that  contains  a  <like  predicate>  that
references VALUE

Ensure  that the current user owns domain f which has a domain
constraint  clause  containing a <comparison  predicate>  that
contains a <value expression> that contains VALUE * VALUE <  1
+ VALUE

Ensure  that  the current user owns a table that  has  columns
defined on each of the domains d, e and f.

Insert  into  the table a row in which all of the  constraints
are met

If the row does not appear in the table, record a fail.

Attempt to insert into the table a row in which one constraint
is not met.

Record a fail if the attempted insertion is successful or  the
new row appears in the table

Insert into the table a row in which the second constraint  is
not satisfied.

Record a fail if the row does appear in the table.

Attempt  to  insert a row into the table in  which  the  third
constraint is not satisfied.

Record a fail if the new row appears in the table.

If  any  of  the  subtests have failed record a  'fail',  else
record a 'pass'


CTS5 SQL2 Test Purpose 008: Feature #25

IDENTIFICATION
     TEST7507, YTS757

DESCRIPTION
     INSERT value in column defined on a domain

REFERENCES
     11.21 -- <domain definition>
     11.4 -- <column definition>
     11.3 --  <table definition>
     13.8 -- <insert statement>
     F#25 -- Domain Definition
     F#3 -- Basic Schema Manipulation

TEST PURPOSE
To  ensure  that  values of a data type can be  inserted  into
columns that are defined on domains based on the same type and
are  defined in a table in a schema owned by the current user,
and  that  operations are unsuccessful if they would  cause  a
value to be stored that is not within the domain.

NOGO:
     None.

TEST SPECIFICATION
Ensure  there  is  a domain x which contains  values  of  type
character(1)  and  in  the range a-m  and  a  domain  y  which
contains values of type integer and in the range 1-100.

Ensure  that  the current user has insert, update  and  select
privileges a table with one column based on the domain  x  and
another column based on domain y.

Populate  the  table  with a row containing  values  contained
within the appropriate domains.

Check  the  table  to  ensure the  correct  values  have  been
inserted. If either of the values is incorrect or the row  has
not been inserted record a fail.

Insert  a  row into the table containing values 'a'  and  '1'.
Check  that the value returned in SQLSTATE indicates that  the
row  has  been inserted correctly.   Check that the table  now
contains the row.

Attempt to insert a row containing values 'z' and '101' in the
columns  based  on domains x and y, respectively.  Check  that
SQLSTATE  indicates that the execution of  the  statement  has
been  unsuccessful. Check that the table does not contain  the
row.

Attempt to update one row in the table such that the new value
in  the column based on domain y would not be a valid value of
domain y. Check that SQLSTATE indicates that the execution  of
the statement has been unsuccessful.

Check the table to ensure that the row has not been modified.

If  any check has failed record a verdict of 'fail;' otherwise
record a verdict of 'pass'.

(Editorial change, 8 February 1995)


CTS5 SQL2 Test Purpose 009: Feature #25

IDENTIFICATION
     TEST7508, YTS757

DESCRIPTION
     Store  value  in a column defined on a domain,  violating
     constraint

REFERENCES
     11.21 -- <domain definition>
     11.3 -- <table definition>
     11.4 -- <column definition>
     11.25 -- <add domain constraint definition>
     F#25  --  Domain Definition
     F#3  --  Basic schema manipulation

TEST PURPOSE
To  determine that a column defined on a domain cannot contain
values which violate the domain constraints.

NOGO:
     None.

TEST SPECIFICATION
Ensure the current user owns domain x which contains values of
type  character(1) and in the range a-h  and  domain  y  which
contains values of type integer and in the range 1-100.

Ensure  that  the  current user owns a table with  one  column
based on domain x and another column based on domain y.

Attempt to add a row containing the character 'A' which is not
found within domain x, but a correct value for domain y.

Record  a  fail  if SQLSTATE indicates that the insertion  has
been  successful. Record a fail if the row has  been  inserted
into the table.

Attempt  to add a row containing '101' which is not  found  in
domain y and a correct value for domain x.

Record  a  fail  if SQLSTATE indicates that the insertion  has
been  successful. Record a fail if the row has  been  inserted
into the table.

Record  a  fail  if either of the subtests have  failed,  else
record a pass.


(Editorial change, 8 February 1995)



CTS5 SQL2 Test Purpose 010: Feature #25

IDENTIFICATION
     TEST7509, YTS759

DESCRIPTION
     GRANT USAGE on a domain

REFERENCES
     11.36 -- <grant statement>
     10.3 -- <privileges>
     11.21  -- <domains definition>
     11.3  -- <table definition>
     11.4 -- <column definition>
     F#25  --  Domain Definition
     F#3  --  Basic Schema Manipulation
     F#32  --  User Authorisation

TEST PURPOSE
To  ensure  that when USAGE of a domain on which  the  current
owner has the USAGE privilege with grant option is granted  to
another   user,  then  the  domain  can  be  used  in   column
definitions by both users.

NOGO:
     None.

TEST SPECIFICATION
Ensure the current user, A, has the USAGE privilege with grant
option  on domain w, and that a second user, B, does not  have
any privileges on domain w.

Create a table which has a column based on domain w.

If SQLSTATE does not indicate success record a fail.

Insert a row into the table.

Record a fail if the row has not been inserted into the table.

Execute  a GRANT domain w USAGE statement with user B  as  the
grantee.

Change to a the authorization identifier B.

Create  a  table  for the second user that contains  a  column
based on domain w.

Record a fail if the table has not created properly.

Insert a row into the table.

Check,  using a <SELECT statement: single row>, that  the  row
has been inserted into the table.

If  any  check  fails, then record a verdict of  'fail',  else
record a verdict of 'pass'.



CTS5 SQL2 Test Purpose 011: Feature #26

IDENTIFICATION
     TEST7534, YTS760

DESCRIPTION
     CASE expression with one simple WHEN

REFERENCES
     6.9 -- <case expression>
     6.9 SR4
     6.9 SR6
     6.9 GR1
     6.9 GR2
     9.3 -- Set operation result data types
     13.10 -- <update statement: searched>
     F# 26 -- CASE expression

     
TEST PURPOSE
To determine that where a <case expression> is a <simple case>
that  contains  only one <simple when clause>, then  when  the
implied <comparison predicate> is satisfied, the result of the
<case expression> is the <result> associated with that <simple
when  clause>; and when the implied <comparison predicate>  is
not  satisfied,  the  result of the <case expression>  is  the
<result>  associated  with  the  specified  or  implied  <else
clause>. That is, if the implied <comparison predicate> is not
satisfied  and there is no explicit <else clause>, the  result
of the <case expression> is the null value.

NOGO:
     None.

TEST SPECIFICATION
Explicit  column names and table names are used here only  for
purposes of reference within this Test Specification, and  are
not  intended  to  constrain  the  names  that  are  used   in
implementations of this specification.

Let  T  be  a table with at least three columns, A, B  and  C,
populated  in  such a way that the rows of the  table  may  be
distinguished by the values in column A, none of the values in
column  B  is the null value, and column C contains some  non-
null values and at least one null value.

Execute  an <update statement: searched> that specifies  T  as
<table name>, does not specify a WHERE option, specifies B  as
the  <object  column> in one <set clause> in its  <set  clause
list>, and specifies C as the <object column> in another  <set
clause>.

In  the <set clause> that specifies B, the <value source> must
be  a <case expression> that is a <simple case> that specifies
one  <simple  when  clause>  and does  not  specify  an  <else
clause>. The <when operand> must be a literal that specifies a
value that occurs in column B in exactly one row of T, and the
<result>  must be a literal that specifies a value  that  does
not occur in column B of T.

In  the <set clause> that specifies C, the <value source> must
be  a <case expression> that is a <simple case> that specifies
one  <simple  when  clause> and an <else  clause>.  The  <when
operand> must be a literal that specifies a value that  occurs
in  column  C  in  exactly one row of T, the <result>  in  the
<simple when clause> must be a literal that specifies a  value
that does not occur in column C, and the <result> in the <else
clause>  must  be  a literal that specifies a different  value
that does not occur in column C.

Check that all values in column B of T, except that in the row
which  contained the value specified as the <when operand>  in
the  <simple  when clause>, are now the null  value,  and  the
value  in the row which contained the value specified  as  the
<when  operand> in the <simple when clause> is now  the  value
specified as <result> in the <simple when clause>.

Check that all values in column C of T, except that in the row
which  contained the value specified as the <when operand>  in
the  <simple  when  clause>, are now the  value  specified  as
<result> in the <else clause>, and the value in the row  which
contained  the  value specified as the <when operand>  in  the
<simple when clause> is now the value specified as <result> in
the <simple when clause>.

Terminate the transaction with rollback.

Check  after each execution of an SQL statement that the value
returned in SQLSTATE indicates successful completion.

If  any  check  fails, record a verdict of  'fail';  otherwise
record a verdict of 'pass'.




CTS5 SQL2 Test Purpose 012: Feature #26

IDENTIFICATION
     TEST7535, YTS761

DESCRIPTION
     CASE expression with searched WHEN

REFERENCES
     6.9 -- <case expression>
     6.9 SR6
     6.9 GR1
     6.9 GR2
     9.3 -- Set operation result data types
     13.8 -- <insert statement>
     F# 26 -- CASE expression

     
TEST PURPOSE
To  determine  that where a <case expression> is  a  <searched
case>  that  contains more than one <search  condition>,  then
when  one or more <search condition>s is satisfied, the result
of  the <case expression> is the <result> associated with that
the  first  such  <search condition>; and  when  none  of  the
<search  condition>s  is satisfied, the result  of  the  <case
expression>  is the <result> associated with the specified  or
implied  <else  clause>. That is, if no <search condition>  is
satisfied  and there is no explicit <else clause>, the  result
of the <case expression> is the null value.

NOGO:
     None.

TEST SPECIFICATION
Explicit  column names and table names are used here only  for
purposes of reference within this Test Specification, and  are
not  intended  to  constrain  the  names  that  are  used   in
implementations of this specification.

Let  T  be  a table with at least three columns, A, B  and  C,
populated in such a way that its rows may be distinguished  by
the  values in column A, none of the values in column B is the
null value, and column C contains some non-null values and  at
least one null value. The data types of columns B and C should
be different.

Let  U be a table with columns D, E and F such that their data
types are the same, respectively, as the data types of columns
A, B and C of table T.

Let  IS  be  an <insert statement> that specifies U as  <table
name>  and specifies columns D, E and F in its <insert  column
list>. The <query expression> of IS must specify T as the only
<table  reference> in its <from clause>. The <select list>  of
the  <query expression> must specify values for columns  D,  E
and  F derived from the values in columns A, B and C of  T  as
follows:

The value for column D is the value from column A.

The value for column E is derived from the value from column B
through  a  <case  expression> that is a  <simple  case>  with
several <simple when clause>s and no <else clause>.

The value for column F is derived from the value from column C
through  a  <case  expression> that is a  <simple  case>  with
several <simple when clause>s and an <else clause>.

For  both column E and column F, the values specified  by  the
<simple  when clause>s should be such as to identify some  but
not all the values produced when the values from columns B and
C,  respectively,  are used in evaluation  of  the  respective
<value expression>s. There should also be some instances where
values from columns B and C, not necessarily in the same  row,
will cause multiple matches.

Check  that all values in column E of U that are derived  from
rows where there was a match in the <case expression> for that
column contain the corresponding <result> value from the first
such  match, and that in all rows where there was not a  match
the column contains the null value.

Check  that all values in column F of U that are derived  from
rows where there was a match in the <case expression> for that
column contain the corresponding <result> value from the first
such  match, and that in all rows where there was not a  match
the  column  contains the value specified as <result>  in  the
<else clause>.

Check  after each execution of an SQL statement that the value
returned in SQLSTATE indicates successful completion.

If  any  check  fails, record a verdict of  'fail';  otherwise
record a verdict of 'pass'.





CTS5 SQL2 Test Purpose 013: Feature #26

IDENTIFICATION
     TEST7001, XTS700

DESCRIPTION
     NULLIF producing NULL.

REFERENCES
     6.9   FT.2  -- <case abbreviation>
     6.9   SR.1
     6.9   GR1a
     6.9   GR2a
     6.9   LR.2a -- raised
     6.11 LR.2c -- raised
     F#26 -- CASE expression

TEST PURPOSE
To  check  that  when  the  two operands  of  a  NULLIF  <case
abbreviation>  are equal, the result of the <case  expression>
is the null value.

NOGO:
     None

TEST SPECIFICATION
Test  the  value returned by the application of  NULLIF  where
both <value expression>s are:
     a)  <numeric value expression>s; and
     b)  <character value expression>s
when that value is expected to be the null value.

Use  a  table from the standard schema with four columns,  two
with  numeric  data types and two with character  string  data
types.  One  column, either one of those  four  or  a  further
column, contains values that can be used to identify the  rows
of  the table. Populate the table in such a way that there  is
at  least one row where the values in the numeric columns  are
equal,  at  least  one row where the values in  the  character
string  columns are equal, there is at least one row  where  a
numeric  column contains the null value and at least  one  row
where a character string column contains the null value.  Note
that  if  the first operand of NULLIF is null, then the  value
returned  is always the null value, and if the second  operand
is  null, then the value returned is always the value  of  the
first operand, which may be null.

1)   Use  a cursor retrieve values from the rows of the table,
including  a  value derived by applying NULLIF to the  numeric
columns  of each row. Check that in rows where the  result  of
comparing  the values in the numeric columns is equality,  the
null value is returned.

2)   Use  a cursor retrieve values from the rows of the table,
including  a value derived by applying NULLIF to the character
string  columns  of  each row. Check that in  rows  where  the
result of comparing the values in the character string columns
is equality, the null value is returned.

3)  Check  the  raising of 6.11LR2c, for  the  case  that  one
operand  of  NULLIF  is again a NULLIF <case  abbreviation>,by
substituting null for a value in a column that is  the  object
of the aggregate operation SUM, where NULL values are ignored.
Use  a  <select statement: single row> to find the sum of  all
elements  in a column of the table that are not equal  to  two
different values (where the column contains these two values),
using the syntax:

          SUM(NULLIF(NULLIF(<column name>, A), B))

where A and B are values that occur in the column. A and B can
be  literals or more general <value expression>s.  Check  that
the value returned is the sum of all values that are not equal
to the two specified values.

After  execution of each SQL statement check  that  the  value
returned in SQLSTATE indicates successful completion.

If  any  of  the  checks failed record a  verdict  of  'fail',
otherwise record a verdict of 'pass'.


CTS5 SQL2 Test Purpose 014: Feature #26

IDENTIFICATION
     TEST7002, XTS798

DESCRIPTION
     NULLIF producing non-NULL

REFERENCES
     6.9   FT.2  -- <case abbreviation>
     6.9   SR.1
     6.9   GR.1b
     6.9   GR.2b
     6.11  LR2a -- Raised
     6.11  LR2c -- Raised
     F#26 -- CASE expression

TEST PURPOSE
To  check  that  when  the  two operands  of  a  NULLIF  <case
abbreviation>  are  not  equal,  the  result  of   the   <case
expression> is the value of the first operand.

NOGO:
     None.

TEST SPECIFICATION
Test  the  values returned by the application of  NULLIF  when
both <value expression>s are:
     a)  <numeric value expression>s; and
     b)  <string value expression>s
when that value is expected to be other than the null value.

Use  a  table from the standard schema with four columns,  two
with  numeric  data types and two with character  string  data
types.  One  column, either one of those  four  or  a  further
column, contains values that can be used to identify the  rows
of the table. Populate the table so that there is at least one
row where the values in the numeric columns are equal, and  at
least one row where the values in the character string columns
are  equal,  at least one row where a numeric column  contains
the  null value and at least one row where a character  string
column contains the null value. Note that if the first operand
of  NULLIF is null, then the value returned is always the null
value,  and  if  the second operand is null,  then  the  value
returned  is always the value of the first operand, which  may
be null.

1)   Use  a cursor retrieve values from the rows of the table,
including  a  value derived by applying NULLIF to the  numeric
columns  of each row. Check that in rows where the  result  of
comparing  the values in the numeric columns is not  equality,
including  rows where one of the operands is the  null  value,
the value of the first operand of NULLIF is returned.

2)   Use  a cursor retrieve values from the rows of the table,
including  a value derived by applying NULLIF to the character
string  columns  of  each row. Check that in  rows  where  the
result of comparing the values in the character string columns
is  not equality, including rows where one of the operands  is
the  null  value, the value of the first operand of NULLIF  is
returned.

3)  Use an <insert statement> to populate a table with a  copy
of  rows  from  another table, modified by applying  a  NULLIF
<case expression> to one of the rows of the source table, with
a  constant value (from a literal or otherwise) as  the  first
operand  of  NULLIF  e.g.: (NULLIF(<constant  value>,  <column
name))

Check, by retrieving rows from the destination table, that the
result  of  the NULLIF was the constant value in  those  cases
where  the value in the referenced column was not the constant
value, and the null value otherwise.

After  execution of each SQL statement, check that  the  value
returned in SQLSTATE indicates successful completion.

If  any  of  the  checks failed record a  verdict  of  'fail',
otherwise record a verdict of 'pass'.


CTS5 SQL2 Test Purpose 015: Feature #26

IDENTIFICATION
     TEST7003, XTS799

DESCRIPTION
     COALESCE with three <value expression>s.

REFERENCES
     6.9   FT.2 -- <case abbreviation>
     6.9   SR.2
     6.9   SR.3
     6.9   LR.2a
     6.11 LR.2c
     F#26  -- CASE Expression.

NOGO:
     None

TEST PURPOSE
To determine that when three <value expression>s are specified
as  operands of a COALESCE <case abbreviation>, the result  of
the  <case  expression> is the value of  the  first  of  those
operands  that is not null, or if all three operands are  null
then the result is the null value.

TEST SPECIFICATION
Use  a  table with at least seven columns, three with  numeric
<data  type>s  and three with character string  <data  type>s.
Populate  the  table  so  that  there  is  at  least  one  row
containing each of the possible combinations of null and  non-
null values (including all null and all non-null) in the three
numeric  columns,  and  similarly  for  the  character  string
columns.  The seventh column must be specified as the  primary
key  and hold values that can be used to identify the rows  of
the table.

Use  a  cursor to retrieve rows derived from the  table,  each
derived row consisting the primary key value, a numeric  value
and  a  character  string value. The numeric  value  shall  be
derived by application of COALESCE to the numeric columns. The
character  string  value shall be derived  by  application  of
COALESCE to the character string columns. For each row,  which
can  be  identified by its primary key value, check  that  the
correct numeric and character string values are returned.

Use  a  sequence  of  executions of <select statement:  single
row>,  either  separate  statements  or  one  statement   with
different parameter values or some combination of the two,  to
retrieve rows derived from the table. Each derived row  is  to
consist  of  the  primary key value, a  numeric  value  and  a
character string value. The numeric value shall be derived  by
application of COALESCE to operands consisting of two  of  the
numeric  columns  and  a  parameter (a  host  variable)  or  a
literal,  and similarly for the character string columns.  For
each  data  type, use values that will result in the selection
of  the  returned  value  from  each  of  the  three  possible
positions  in the COALESCE. For each row retrieved, identified
by  the  value  of  the primary key, check  that  the  correct
numeric and character string values are returned. If it  makes
the  programming easier, the checks for numeric  operands  and
for  character operands may be included in separate series  of
SELECT statements.

After each execution of an SQL statement, check that the value
returned in SQLSTATE indicates successful completion.

If any check failed then record a verdict of 'fail', otherwise
record a verdict of 'pass'.



CTS5 SQL2 Test Purpose 016: Feature #27

IDENTIFICATION
     TEST7004, XTS701

DESCRIPTION
     Compound char. literal in <comparison predicate>

REFERENCES
     5.3 FT.4
     5.3 SR.1
     5.3 SR.4
     5.3 GR.1
     8.2 GR.1
     8.2 GR.3
     8.2 GR.7
     5.3 LR.2.d
     6.5 FT.1 -- COUNT set function
     6.5 SR.2
     F# 27 -- Compound character literal

TEST PURPOSE
To determine that a compound character literal may be
specified in a comparison predicate, in any position where a
character  literal is permitted, and that the effect is as if
a simple character literal with the same value had been
specified.

NOGO:
     None

TEST SPECIFICATION
Specific cases of compound character literal, comparison
operators and expected result to be covered are:
          1.   A character string literal split into two fragments,
          i.   written on consecutive lines with no spaces or
          comments following the first fragment, is tested in
          conjunction with <equals operator> resulting to
          false.
          ii.       written on consecutive lines, with spaces
          following the first fragment on the same line, is
          tested in conjunction with <not equals operator>
          resulting to false.
                    iii.      written on consecutive lines, with
          comments following the first fragment on the same
          line, is tested in conjunction with <less than or
          equals operator> resulting to true.
          2.   A character string literal split into multiple
     fragments, with blank lines and lines containing comments
     between fragments,
          i.   with first fragment of literal equal to other
          operand, is tested in conjunction with <equals
          operator> resulting to false.
                    ii.       with intermediate fragment of literal
          equal to other operand, is tested in conjunction
          with <equals operator> resulting to false.
          iii.      equal to other operand apart from trailing
          spaces, is tested in conjunction with <less than or
          equals operator> resulting to true.
                    iv.       unequal to other operand, is tested
          in conjunction with both <less than> and <greater
          than> operators, with different results being
          expected.
          v.   equal to other operand apart from trailing
          spaces, is tested in conjunction with <equals
          operator> resulting to true.
          vi.       equal to other operand, is tested in
          conjunction with <less than operator> resulting to
          false.
     The tests will be committed as follows:
          a)   Insert a few long character literal values (not
          compound) in a table with suitably long column (X).
          b)   For each one of the cases in 2, count the
          tuples of the table above, into a host variable,
          where the value in X equals a (equivalent to one of
          the values) compound character literal value.
          c)   Check the cardinality of the selection, which
          should be one.
          d)   Repeat steps b) and c) for less than, less than
          or equals, not equals operators, trying each time a
          different variant of the compound character literal
          value, according to the cases mentioned above. In
          step c) the cardinality of the three selection cases
          above, should be 1, 2 and 1 respectively.
PROGRAMMING SPECIFICATION
Create a program to be run under authorisation identifier HU,
          containing the following elements:
          a)        INSERT in the T4 table the following values:
     -   STR110 field:  a compound character literal value as
     follows:
          'This is the first compound character literal.'
          'Second character literal.'
          'Third character literal.'
     -   NUM6 field: a numeric value respectively:
          1
          2
          3
     -   the rest of the fields (COL3-COL4) fields: NULL
     values

--   Test specification 1.i
          b)        Initialise the host variable num to zero.
          c)        SELECT NUM6 INTO the host variable num from the
     T4 table, WHERE STR110 equals the compound character
     literal value:
          'This is the compound '<separator>'character
          literal.'
          d)        Check that num remains zero (the result of
     comparison is false so no value is returned) and a value
     indicating the completion condition 'no data' is returned
     in SQLSTATE.

--   Test specification 1.ii
          e)        Initialise the host variable coun to zero.
          f)        SELECT COUNT(*) INTO the host variable coun
     from the T4 table, WHERE STR110 does not equal the
     compound character literal value:
          'This is the first compound '<separator>'character
          literal.'
          g)        Check that coun has the value of 2.

--   Test specification 1.iii
          h)        Initialise the host variable num to zero.
          i)        SELECT NUM6 INTO the host variable num from the
     T4 table, WHERE NUM6 equals to 2 AND STR110 is less than
     or equal to the compound character literal value:
          'Second character '<separator>'literal.'
          j)        Check that num has the value of 2.

--   Test specification 2.i
          k)        Initialise the host variable num to zero.
          l)        SELECT NUM6 INTO the host variable num from the
     T4 table, WHERE STR110 equals the compound character
     literal value:
          'Third character literal.'<separator>' second
          fragment'<separator>' third fragment.'
          m)        Check that num remains zero (the result of
     comparison is false, so no value is returned) and a value
     indicating the completion condition 'no data' is returned
     in SQLSTATE.

--   Test specification 2.ii
          n)        Initialise the host variable num to zero.
          o)        SELECT NUM6 INTO the host variable num from the
     T4 table, WHERE STR110 equals the compound character
     literal value:
          'First fragment, ' <separator> 'another fragment, '
          <separator> 'Second character literal.' <separator>
          ' fourth fragment.'
          p)        Check that num remains zero (the result of
     comparison is false, so no value is returned) and a value
     indicating the completion condition 'no data' is returned
     in SQLSTATE.

--   Test specification 2.iii
          n)        Initialise the host variable num to zero.
          o)        SELECT NUM6 INTO the host variable num from the
     T4 table, WHERE STR110 is less than or equal to the
     compound character literal value:
          'Second ' <separator> 'chara' <separator> 'cter
          liter' <separator> 'al.' <separator> '       '
          p)        Check that num acquires the value of 2.

--   Test specification 2.iv
          q)        Initialise the host variables num and num1 to
     99.
          r)        SELECT COUNT(*) INTO the host variable num from
     the T4 table, WHERE STR110 is less than the compound
     character literal value:
          'An indifferent' <separator> ' charac' <separator>
          'ter literal.'
     and
     SELECT COUNT(*) INTO the host variable num1 from the T4
     table, WHERE STR110 is greater than the compound
     character literal value:
          'An indifferent' <separator> ' charac' <separator>
          'ter literal.'
          t)        Now check that the sum of host variables num
     and num1 is 3, the number of rows in table T4.

--   Test specification 2.v
          u)        Initialise the host variable num to zero.
          v)        SELECT NUM6 INTO the host variable num from the
     T4 table, WHERE STR110 equals the compound character
     literal value:
          'Second ' <separator> 'chara' <separator> 'cter
          liter' <separator> 'al.' <separator> '       '
          <separator> '       '
          w)   Check that num acquires the value of 2.

--   Test specification 2.vi
          x)        Initialise the host variable num to zero.
          y)        SELECT NUM6 INTO the host variable num from the
     T4 table, WHERE NUM6 equals 2 AND STR110 is less than the
     compound character literal value:
          'Second ' <separator> 'chara' <separator> 'cter
          literal.'
          z)        Check that num remains zero (the WHERE
     condition is not satisfied, so no value is returned) and
     a value indicating the completion condition 'no data' is
     returned in SQLSTATE


Except where some other check is specified, check after every
execution of an SQL statement that the value returned in
SQLSTATE indicates successful completion.

If any check has failed, record a verdict of 'fail', otherwise
record a verdict of 'pass'.

Note that in all of the above cases, the separators are formed
according to the test  specification description, above.



(Revised 12 May 1995)
(Editorial revision 27 June 1995)


CTS5 SQL2 Test Purpose 017: Feature #27

IDENTIFICATION
     TEST7005,  XTS701

DESCRIPTION
     Compound character literal as inserted value

REFERENCES:
     5.3 SR.1
     5.3 SR.4
     5.3 GR.1
     5.3 LR.2.d
     13.8 FT.1 -- <insert statement>
     7.2 FT.1 -- <table value constructor>
     7.1 FT.3 -- <row value constructor element>
     6.11 FT.1 -- <value expression>
     F# 27 -- Compound character literal

TEST PURPOSE
To determine that a compound character literal may be
specified as a <row value constructor element> in a <table
value constructor> in the <query expression> that specifies
the values to be inserted in a table by an <insert statement>,
and that the effect is as if a simple character literal with
the same value had been specified.

NOGO:
     None

TEST SPECIFICATION
1. Insert the following two compound character string literals
in a table row, in the same <insert statement>:
          i.        A character string literal split into two
     fragments, written in different lines, the first of which
     is followed by spaces and comments on the same line and
     with presence of blank lines in between.
          ii.       A character string literal split into two
     fragments, written in different lines, with presence of
     blank lines and lines with comments and spaces in
     between.

2. Insert the following compound character string literals in
table rows, in separate <insert statements>:
          i.        A character string literal split into three
     fragments which will be separated using just a newline
     character as a first separator, whilst the second one
     will be constituted of a few spaces followed by a newline
     character.
          ii.       A character string literal will be split into
     ten fragments which will be separated  by blank lines and
     lines with comments and spaces.

Check that the values have been stored correctly in the
database.

PROGRAMMING SPECIFICATION
Create a program to be run under authorisation identifier HU,
containing the following elements:
a)   INSERT in the T4 table one tuple with the following
     values:
     - STR110 field: a compound character literal value as
     follows:
          'This is the first fragment of a compound character
          literal,'<separator>' and this is the second part.'
     - NUM6 field: 11(first tuple)
     - COL3 field: NULL value
     - COL4 field: a compound character literal value as
     follows:
          'Compound '<separator>'literal.'
b)   INSERT in the T4 table two other tuples with the
     following values:
     - STR110 field: a compound character literal value as
     follows:
          'This is a comp'<separator>'ound character
          literal,'<separator>' in the second table row.'
          'This is '<separator1>'a comp'<separator2>'ound
          '<separator3>'char'<separator4>'acter
          lit'<separator5>'eral, '<separator6>'in the
          th'<separator7>'ird '<separator8>'table
          '<separator9>'row.'
     - NUM6 field: 12(second tuple) - 13 (third tuple)
     - COL3 field: NULL values
     - COL4 field: NULL values

     The values for the <separator> will be specified
     according to the descriptions given in the Test Purpose
     section 1.i, 1.ii, 2.i, and 2.ii respectively.
c)   SELECT from the T4 table,  the columns STR110, COL4 into
     two host variables ccl1, ccl2 respectively, WHERE NUM6
     equals 11.
d)   Compare the value of ccl1 and ccl2 with the respective
     non compound character literal  values:
          'This is the first fragment of a compound character
          literal, and this is the second part.' (for ccl1)
          'Compound literal.' (for ccl2)
     The result of the comparison should be zero.
e)   Repeat steps c) and d) selecting only column STR110 into
     the host variable ccl1, WHERE NUM6 equals 12 - 13 and
     comparing respectively with the following values:
          'This is a compound character literal, in the second
          table row.'
          'This is a compound character literal, in the third
          table row.'
f)   ROLLBACK WORK and record results.



CTS5 SQL2 Test Purpose 17a: Feature #27

IDENTIFICATION
     TEST7006, XTS701

DESCRIPTION
     Compound character literal in a <select list>

REFERENCES
     5.3 SR.1
     5.3 SR.4
     5.3 GR.1
     5.3 LR.2.d
     7.9 FT.1 -- <query specification>
     6.11 FT.1 -- <value expression>
     F# 27 -- Compound character literal

TEST PURPOSE
To determine that a compound character literal may be
specified as a <derived column> in a <select statement: single
row> that specifies the values to be assigned to the <select
target list>, and that the effect is as if a simple character
literal with the same value had been specified.

NOGO:
     None

TEST SPECIFICATION
Assign two different compound character string literals into
variables of the <select target list>, through the same
<select statement: single row>.

          i.        A character string literal split into two
     fragments, written in different lines, with presence of
     blank lines and lines with comments and spaces in
     between.
          ii.       A character string literal split into three
     fragments which will be separated using combinations of
     different separators: First separator will be constituted
     by a few comments followed by a newline character, whilst
     the second one will be constituted  by a few consecutive
     newline characters.

PROGRAMMING SPECIFICATION
Create a program to be run under authorisation identifier HU,
containing the following elements:
          a)        SELECT into two host variables ccl1 and ccl2
     respectively, the compound character literals:
          'First fragment of a compound character literal,
          '<separator>'and second part.'
          'This is the first fragment of a compound character
          literal,'<separator>' this is the
          second,'<separator>' and this is the third part.'
     The values for the <separator> will be specified
     according to the descriptions given in the Test Purpose
     section i and ii.

          b)        Compare the variable ccl1 with the character
     literal value:
          'First fragment of a compound character literal, and
          second part.'
     and the variable ccl2 with the literal:
          'This is the first fragment of a compound character
          literal, this is the second, and this is the third
          part.'
     The comparison result in both cases should be zero.

          c)        ROLLBACK WORK and record results.



CTS5 SQL2 Test Purpose 018: Feature #28

IDENTIFICATION
     TEST7007, XTS702

DESCRIPTION
     LIKE with unrestricted <match value>

REFERENCES
     8.5 FT.2 -- <match value> format
     8.5 SR.1
     8.5 GR.3
     8.5 LR.2.a -- Raising the rule that the match value shall
be a <column reference>
     6.13 FT.5 -- <character primary>
     6.11 FT.2 -- <value expression primary>
     6.2 FT.2 -- <unsigned value specification>
     F# 28 -- LIKE enhancements

TEST PURPOSE
To determine that a character literal, a character string host
variable, or USER, can be specified as <match value> in a
<like predicate>, where both <pattern> and <escape character>
will remain <value specifications>.

NOGO:
     None

TEST SPECIFICATION
Various subtests will be specified in this main test which
will test different derivations of a <character value
expression>, the data types of which will be character
strings, in the position of a <match value>.

SELECT COUNT(*) into the host variable coun FROM a table,
WHERE 'character literal' LIKE 'equal character literal'.

Check that the result value of the host variable is equal to
the cardinality of the table in use, since the like predicate
is true.

Initialise a host variable hv with a character literal B.

SELECT COUNT(*) into a host variable coun FROM a table, WHERE
hv NOT LIKE <pattern matching to hv> ESCAPE <escape
character>,

Check that the result value of the host variable coun is zero,
since the like predicate is false.

SELECT COUNT(*) into a host variable coun FROM a table, WHERE
USER LIKE <authorisation identifier>.

Check that the result value of the host variable is equal to
the cardinality of the table in use, since the like predicate
is true.

After each execution of an SQL statement, check that the value
returned in SQLSTATE indicates successful completion.

If any check has failed, record a verdict of 'fail', otherwise
record a verdict of 'pass'.


PROGRAMMING SPECIFICATION
Create a program to be run under authorisation identifier HU,
containing the following elements:

          a)        SELECT COUNT(*) into a host variable coun FROM
     table STAFF, WHERE 'Alice' LIKE 'Alice'.

          b)        Compare the value of the variable coun with the
     number 5 which is the cardinality of STAFF.
          c)        Initialise the host variable hv2 with the
     character literal 'Equal_literal'.

          d)        SELECT COUNT(*) into a host variable coun FROM
     table STAFF, WHERE :hv2 NOT LIKE 'Eq_alS_literal%' ESCAPE
     'S'.

          e)        Compare the value of the variable coun with
     zero, since the like predicate returns false.

          f)        SELECT COUNT(*) into a host variable coun FROM
     table STAFF, WHERE USER LIKE 'HU%'.

          g)        Compare the value of the variable coun with the
     number 5 which is the cardinality of STAFF.



CTS5 SQL2 Test Purpose 019: Feature #28

IDENTIFICATION
     TEST7008, XTS702

DESCRIPTION
     LIKE with general character value for pattern and escape

REFERENCES
     8.5 FT.3 -- <pattern> format
     8.5 FT.4 -- <escape character> format
     8.5 LR.2.b -- Raising the rule that the pattern shall be
     a <value specification>
     8.5 LR.2.c -- Raising the rule that the escape character
     shall be a <value specification>
     F# 28 -- LIKE enhancements

TEST PURPOSE
To determine that a general <character value expression> and
not only a <value specification>, can be specified as
<pattern>  and/or <escape character> in the context of a <like
predicate>. Providing that the <character value expression>
derivations which also depend on other features, like support
of TRIM, SUBSTRING functions, support of CASE expression, or
support of CAST specification e.t.c, are excluded, the
alternative value for a <pattern> or an <escape character> is
a <column reference>.

NOGO:
     None

TEST SPECIFICATION
Various subtests will be specified in this main test which
will test different derivations of a <character value
expression>, the data types of which will be character
strings, in the position of a <pattern> and/or an <escape
character>.

Specific cases to be covered are:
          1.        <pattern> to be a column reference, no <escape
     character> will be specified.
          2.        <pattern> to be a column reference, <escape
     character> to be a character literal.
          3.        both <pattern> and <escape character> to be
     column references
In all of the above cases the <match value> will remain
<column reference>.
          4.        <match value> to be a char. literal, <pattern>
     to be a column reference, <escape character> to be a
     character literal.

SELECT COUNT(*) the tuples FROM a table, WHERE <column X
reference> LIKE <column X reference>.
Check that the result value is equal to the cardinality of the
afore mentioned table.

INSERT one tuple into a table, such that the value of column X
will contain the characters %, _, S_, to be used as a
<pattern>, whilst column Y will contain a value to match with
column X.

SELECT COUNT (*) the tuples FROM the table above, WHERE
<column Y reference> LIKE <column X  reference> ESCAPE <escape
char. 'S'>.
Check that the result value is equal to the cardinality of the
selection.

INSERT one tuple into a table, such that the value of column X
will contain the characters %, _, S%, to be used as a
<pattern>, whilst column Y will contain a value to match with
column X, and column Z will contain character 'S' to be used
as escape character.

SELECT COUNT (*) the tuples FROM the table above, WHERE
<column Y reference> LIKE <column X reference> ESCAPE <column
Z reference>.
Check that the result value is equal to the cardinality of the
selection.

SELECT COUNT (*) the tuples FROM the table above, WHERE
'suitable character literal' LIKE <column X reference> ESCAPE
<escape char. 'S'>,
Check that the result value is equal to the cardinality of the
selection.
After each execution of an SQL statement, check that the value
returned in SQLSTATE indicates successful completion.

If any check has failed, record a verdict of 'fail', otherwise
record a verdict of 'pass'.


PROGRAMMING SPECIFICATION
Create a program to be run under authorisation identifier HU,
containing the following elements:

          a)        SELECT COUNT(*) INTO host variable coun FROM
     table STAFF, WHERE EMPNAME LIKE EMPNAME.

          b)        Check that the variable coun equals to numeric
     literal 5 (which is the cardinality of STAFF).

          c)        INSERT INTO table STAFF VALUES ('E6',
     'Theodora_FL', 14, 'T%S_FL%%%%%%%%%').

          d)        SELECT COUNT(*) INTO host variable coun FROM
     table STAFF, WHERE EMPNAME LIKE CITY ESCAPE 'S'.

          e)        Check that the variable coun equals to numeric
     literal 1 (which is the cardinality of STAFF).

          f)        INSERT INTO table STAFF VALUES ('S',
     'Dana%ELFT', 14, 'D%S%%%%%%%%%%%%').

          g)        SELECT COUNT(*) INTO host variable coun FROM
     table STAFF, WHERE EMPNAME LIKE CITY ESCAPE EMPNUM.

          h)        Check that the variable coun equals to numeric
     literal 1 (which is the cardinality of STAFF).

          i)        SELECT COUNT(*) INTO host variable coun FROM
     table STAFF, WHERE 'Del%' LIKE CITY ESCAPE EMPNUM.

          j)        Check that the variable coun equals to numeric
     literal 1 (which is the cardinality of STAFF).

          k)        ROLLBACK WORK and record results.


CTS5 SQL2 Test Purpose 020: Feature #28

IDENTIFICATION
     TEST7009, XTS702

DESCRIPTION
     LIKE with zero-length escape

REFERENCES
     8.5 FT.4 -- <escape character> format
     8.5 GR.3.a.i -- The length of the string in <escape
     character> should be 1.
     6.7 FT.7 -- <trim function>
     8.5 LR.2.c -- Raising the rule that the escape character
     shall be a <value specification>
     F# 28 -- LIKE enhancements
     F# 7 -- TRIM support is required

TEST PURPOSE
To determine that when the length in characters of the result
of the <character value expression> specified as the <escape
character> in a <like predicate> is zero, then an exception
condition is raised: data exception --invalid escape
character.

NOGO:
     None

TEST SPECIFICATION
The case to be covered is:
     <match value>, <pattern> and <escape character> to be a
     column reference, with the content of <escape character>
     to be of zero length.
The test is expected to:
     INSERT one tuple into a table, such that the value of
     column X will contain the characters %, _, S%, to be used
     as a <pattern>, whilst column Y will contain a value to
     match with column X, and column Z will contain a sequence
     of spaces.
SELECT COUNT (*) the tuples FROM the table above, WHERE
<column Y reference> LIKE <column X reference> ESCAPE
TRIM(<column Z reference>).
Check that the result value is zero and that an exception
condition should be raised: data exception-invalid escape
character.

Except where a check for some other status is prescribed,
check after execution of an SQL statement that the value
returned in SQLSTATE indicates successful completion.

If any check has failed, record a verdict of 'fail', otherwise
record a verdict of 'pass'.

PROGRAMMING SPECIFICATION
Create a program to be run under authorisation identifier HU,
containing the following elements:
          a)        INSERT INTO table STAFF VALUES ('   ',
     'Dana%ELFT', 14, 'D%S%%%%%%%%%%%%').
          b)        SELECT COUNT(*) INTO host variable coun FROM
     table STAFF, WHERE EMPNAME LIKE CITY ESCAPE TRIM(EMPNUM).
          c)        Check that SQLCODE is negative and SQLSTATE has
     the value "22019".
          d)        ROLLBACK WORK and record results.



CTS5 SQL2 Test Purpose 021: Feature #29

IDENTIFICATION
     TEST7010, XTS703

DESCRIPTION
     UNIQUE predicate, single table, all values distinct

REFERENCES
     8.9 GR.2
     7.9 -- <query specification>
     7.10 -- <query expression>
     7.11 -- <table subquery>
     8.9 LR.2.a -- Raising the rule that Entry level of SQL
     language shall not contain  any <unique predicate>
     F# 29 -- UNIQUE predicate

TEST PURPOSE
To determine that when the operand of a <unique predicate> is
a single table with distinct rows and no null values, the
result of the test is true.

NOGO:
     None

TEST SPECIFICATION
The test is expected to:
     INSERT four distinct values in a table X with at least
     two columns A and B, of character and decimal data types
     respectively.
     Count the rows of the above table that satisfy the
     condition UNIQUE (SELECT * FROM table).
     The number of rows should be four, since the <unique
     predicate> returns true.

PROGRAMMING SPECIFICATION
Create a program to be run under authorisation identifier HU,
containing the following elements:
          a)        INSERT INTO table STAFF1:
          VALUES ('AAA','AA',1,'BBB')
          VALUES ('AAA','AA',1,'CCC')
          VALUES ('AAA','AA',2,'CCC')
          VALUES ('BBB','AA',1,'CCC')

          b)        SELECT COUNT(*) INTO host variable coun FROM
     the table above,
          WHERE UNIQUE (SELECT * FROM table).

          c)        Compare the host variable coun with number 4
     (the number of inserted rows), since the <unique
     predicate> returns true.



CTS5 SQL2 Test Purpose 022: Feature #29

IDENTIFICATION:
     TEST7011, XTS703

DESCRIPTION:
     UNIQUE predicate, table subquery with non-null duplicates

REFERENCES:
     8.9 -- UNIQUE predicate
     7.11 -- <table subquery>
     8.9 LR.2.a -- Raising the rule that Entry level of  SQL
     language shall not contain  any <unique predicate>
     F# 29 -- UNIQUE predicate

TEST PURPOSE
To determine that when the operand of a <unique predicate> is
a subquery on a multi column tables containing duplicate rows
with non-null values, the result of the test is true.

NOGO:
     None

TEST SPECIFICATION
Various subtests will be included in this main test:
     SELECT COUNT (*) into a host variable coun (initialised
     to zero), FROM a table YY with two rows which have
     identical values in the same column C1, WHERE UNIQUE
     (SELECT C1 FROM table YY).

     Check that the value of coun is 0.

     Commit a suitably complicated selection to test the
     unique predicate in conjunction with other conditions.

     Initialize hv1 to zero.SELECT COUNT(*) INTO host variable
     hv1 FROM table X above, WHERE NOT UNIQUE (SELECT <all
     other columns except Z and Y> FROM table X).

     Compare the host variable hv1 with character literal A
     and check that the result is different from zero.

PROGRAMMING SPECIFICATION
Create a program to be run under authorisation identifier HU,
containing the following elements:
          a)        SELECT COUNT (*) INTO :coun (initialised to
     zero), FROM table STAFF, WHERE UNIQUE (SELECT GRADE FROM
     table STAFF).

          b)        Check that coun is zero.

          c)        Initialise the host variable :hv to 'CCC'

          d)        SELECT EMPNUM, GRADE INTO :name, :grade FROM
     table STAFF1, WHERE UNIQUE (SELECT * FROM table STAFF1
     WHERE :hv = CITY) AND GRADE = 2.

          e)        Compare the host variable :name to 'AAA' and
     :grade to 2.

          f)        SELECT COUNT(*) INTO host variable :coun FROM
     table STAFF1, WHERE NOT UNIQUE (SELECT EMPNUM, GRADE FROM
     table STAFF1).

          g)        Compare the variable :coun with the number 4
     (the amount of inserted rows), since the <unique
     predicate> returns true.

          h)        ROLLBACK WORK and record results.

CTS5 SQL2 Test Purpose 023: Feature #29

IDENTIFICATION:
     TEST7012, XTS703

DESCRIPTION
     UNIQUE predicate, rows duplicates containing null

REFERENCES:
     8.9 -- UNIQUE predicate
     7.11 -- <table subquery>
     8.9 LR.2.a -- Raising the rule that Entry level of SQL
     language shall not contain  any <unique predicate>
     F# 29 -- UNIQUE predicate

TEST PURPOSE:
To determine that when the operand of a <unique predicate> is
a subquery on a multi column tables containing duplicate rows
including null values, the result of the test is true.

NOGO:
     None

TEST SPECIFICATION
A test is specified to:
     INSERT two rows in table X, such that:
          -     the two rows will be identical on most
          columns, they will be different on one column Y, but
          they both contain null value in the same column Z.

     SELECT COUNT(*)  INTO host variable :coun FROM table X
     above, WHERE UNIQUE (SELECT * FROM table X).

     Check that the host variable coun is zero.

     SELECT a column INTO host variable hv1 FROM table X
     above, WHERE NOT UNIQUE (SELECT <all identical columns
     except for Y and Z> FROM table X) AND a specific column
     equal to an existing value.

     Check that the host variable hv1 takes the right value.

PROGRAMMING SPECIFICATION:
Create a program to be run under authorisation identifier HU,
containing the following elements:
          a)        INSERT INTO STAFF1:
          VALUES ('E6', 'XXX', 9, NULL)
          VALUES ('E6', 'XXX', 10, NULL)

          b)        SELECT COUNT(*) INTO host variable :coun FROM
     table STAFF1, WHERE UNIQUE (SELECT * FROM table STAFF1).

          c)        Check that host variable :coun is zero, since
     the <unique predicate> is false.

          d)        SELECT EMPNUM INTO :name FROM table STAFF1,
     WHERE NOT UNIQUE (SELECT EMPNUM, EMPNAME FROM table
     STAFF1) AND GRADE = 9.

          e)        Compare the host variable :name to 'E6'.

     f)        ROLLBACK WORK and record results.

CTS5 SQL2 Test Purpose 024: Feature #30

IDENTIFICATION
     TEST7517, YTS762

DESCRIPTION
     <query expression> with EXCEPT

REFERENCES
     7.10 -- <query expression>
     7.10 -- GR1b
     7.3 -- <table expression>
     13.1 -- <declare cursor>
     13.5 -- <select statement: single row>
     F#30 -- Table operations

TEST PURPOSE
To determine that if EXCEPT is specified as an operator in a
<query expression>, then the result of the operation is a
table that consists of those rows that appear in the first
operand and not in the second operand, with unmatched
redundant duplicates eliminated unless ALL is specified.

NOGO
     None.

TEST SPECIFICATION
Let A and B be two tables of the same degree such that the
data type of the  i-th column of A and the data type of the
i-th column of B are comparable. Populate A in such a way that
it contains three or more copies of some rows, two copies of
other rows, and some rows that are not duplicated. Populate B
in such a way that it contains some rows that are duplicates
of rows in A and some that are not duplicates of rows in A.
Include cases where the multiplicity of a row in B is less
than, equal to and greater than the multiplicity of that row
in A. Check that each INSERT operation is successful and that
A and B both contain the required number of rows.

Declare a cursor that specifies "FROM P EXCEPT Q" as the
<table expression> in the <query specification> of  its <query
expression>, where P is "SELECT * FROM A" and Q is "SELECT *
FROM B. Open the cursor and retrieve all rows. Check that the
rows retrieved through the cursor are rows of A that do not
have a duplicate in B, and that exactly one instance of each
row is returned, whether or not there are multiple instances
of that row in A.

Execute an <insert statement> that specifies P EXCEPT ALL Q
as its <query expression> and inserts the result of the 
<query expression> into an otherwise empty table, ET.
Use a <select statement: single row> to determine the
number of rows and the number of distinct rows in ET.


After execution of each statement, check that SQLSTATE
indicates successful execution.

If any of the checks has failed, record a verdict of 'fail',
else record a verdict of 'pass'.


(Revised 24 April 1995)
(Revised again 10th January 1996)

CTS5 SQL2 Test Purpose 025: Feature #30

IDENTIFICATION
     TEST7518, YTS763

DESCRIPTION
     <query expression> with INTERSECT CORRESPONDING

REFERENCES
     7.10 -- <query expression>
     7.10 -- SR9a
     7.10 -- SR10a
     7.10 -- GR1b
     7.3 -- <table expression>
     13.5 -- <select statement: single row>
     13.1 -- <declare cursor>
     F#30 -- Table operations

TEST PURPOSE
To determine that if INTERSECT is specified as an operator in
a <query expression> and a <corresponding spec> is specified
for that operation, but neither ALL nor a <corresponding
column list> is specified, then the result of the operation is
a table with the following structure and content:
a)   the columns are those columns of the first operand for
     which there is a column with the same name in the second
     operand, in the order in which those columns appear in
     the first operand;
b)   the content of consists those columns from the rows that
     appear in both the first operand and the second operand,
     with redundant duplicates eliminated, with only those
     columns that appear in the result table considered in
     determining identity of rows.

NOGO
     None.

TEST SPECIFICATION
Let A and B be two tables of the different degree such that
for some, but not all, columns of A there are columns of B
with the same name, and there are columns of B for which there
is no column of A with the same name. In addition, where
columns in A and B have the same name, let the data types of
those columns be comparable. Let "corresponding columns" in
either table refer to those columns that have the same names
as columns in the other table. Ensure that the order of the
corresponding columns in the two tables is different.

Populate table A in such a way that it contains three or more
copies of some rows, two copies of other rows, and some rows
that are not duplicated. For the rows that are not duplicated,
include some where the rows would be duplicates if only the
corresponding columns were considered. Populate B in such a
way that, considering only the corresponding columns, it
contains some rows that are duplicates of rows in A and some
that are not duplicates of rows in A. Include cases where the
multiplicity of a row in B is less than, equal to and greater
than the multiplicity of that row in A. Check that each INSERT
operation is successful and that A and B both contain the
required number of rows.

Declare an ordered cursor that specifies
     SELECT * FROM A
         INTERSECT CORRESPONDING
           SELECT * FROM B
as its <query expression>, and specifies at least one
<unsigned integer> in the <sort key> where the position of the
referenced column in the cursor is different from the position
of the columns with the same name in both A and B. Open the
cursor and retrieve all rows. Check that the table retrieved
through the cursor consists of the corresponding columns from
those rows of A which are duplicates of some row in B, where
only the corresponding columns are considered in determining
duplicates, and that exactly one instance of each row of the
cursor table is returned. Check that the rows returned are
correctly ordered according to the <sort key>.

Execute a <select statement: single row> that specifies
"DISTINCT COUNT (*)" as its <select list> and
     FROM (SELECT <col list 1> FROM A
          INTERSECT CORRESPONDING SELECT <col list 2> FROM B)
          AS C
as its <table expression>, where <col list 1>  is a <select
list> that omits one or more corresponding columns from A and
<col list 2>  is a <select list> that omits one or more
different corresponding columns from B. Check that the value
returned by the statement is the number of rows of A which are
duplicates of some row of B, with only the reduced set of
corresponding columns considered in determining duplicates,
and with each set of redundant duplicates contributing only 1
to the count.

After execution of each statement, check that SQLSTATE
indicates success.

If any of the checks has failed, record a verdict of 'fail',
else record a verdict of 'pass'.


(Revised 18 January 1995)


CTS5 SQL2 Test Purpose 026: Feature #30

IDENTIFICATION
     TEST7519, YTS764

DESCRIPTION
     <query expression> with UNION ALL CORRESPONDING BY

REFERENCES
     7.10 -- <query expression>
     7.10 -- SR9a
     7.10 -- SR10a
     7.10 -- GR1b
     7.3 -- <table expression>
     13.1 -- <declare cursor>
     F#30 -- Table operations

TEST PURPOSE
To determine that if UNION ALL is specified as an operator in
a <query expression> and a <corresponding spec> with a
<corresponding column list> is specified for that operation,
then the result of the operation is a table with the following
structure and content:
a)   the columns are the columns that are named in the
     <corresponding column list> of the <column spec>, in the
     order in which those columns appear in the <corresponding
     column list>;
b)   the content consists of the columns that appear in the
     <corresponding column list> from all rows of both
     operands, with all duplicates retained.

NOGO
     None.

TEST SPECIFICATION
Let A and B be two tables of different degree such that for
some, but not all, columns of A there are columns of B with
the same name, and there are columns of B for which there is
no column of A with the same name. Let "corresponding columns"
in either table refer to those columns that are named in the
<corresponding column list>. Ensure that the order of the
corresponding columns in the two tables is different. Let
there be other columns in table A that have the same names as
columns in the table B. In addition, let corresponding columns
with the same name have comparable data types. Columns in A
and B that have the same name, but are not corresponding
columns may have comparable data types, but at least one pair
of such columns must have data types that are not comparable.

Populate table A in such a way that it contains three or more
copies of some rows, two copies of other rows, and some rows
that are not duplicated. For the rows that are not duplicated,
include some where the rows would be duplicates if only the
corresponding columns were considered. Populate B in such a
way that, considering only the corresponding columns, it
contains some rows that are duplicates of rows in A and some
that are not duplicates of rows in A. Include cases where the
multiplicity of a row in B is less than, equal to and greater
than the multiplicity of that row in A.

Check that each INSERT operation is successful and that A and
B both contain the required number of rows.

Declare a cursor that specifies

     SELECT COUNT (*), <col list>
          FROM (
               SELECT * FROM A
                UNION ALL CORRESPONDING BY (<col list>)
               SELECT * FROM B
               )
               GROUP BY <col list>
          ORDER BY <perm>

as its <query expression>, where <perm> is a sort
specification containing at least two <unsigned integer>s and
such that if the integers are interpreted incorrectly the rows
of the cursor will be returned in the wrong order. Open the
cursor and retrieve all rows. Check that the rows are
retrieved in the correct order and that the count of rows in
each group is correct.

After execution of each statement, check that SQLSTATE
indicates success.

If any of the checks has failed, record a fail, else record a
pass.


(Revised 18 January 1995)
(Editorial correction, 1 May 1995)


CTS5 SQL2 Test Purpose 027: Feature #31

IDENTIFICATION:
     TEST7013, XTS713

DESCRIPTION:
     Schema definition in an SQL statement-single table

REFERENCES:
     11.1  --  <Schema definition>
     11.1 SR.1
     11.1 SR.2
     11.1 AR.1
     11.1 GR.3
     12.5  --  <SQL procedure statement>
               12.5 LR.2.a  --     Raised. Entry SQL
               restriction "An <SQL procedure statement> shall
               not be an <SQL schema definition statement>.
     F#31 -- Schema definition statement.

TEST PURPOSE.
To determine that a schema with unspecified <schema name> can
be created within an  <SQL procedure statement>  and this will
result in a valid schema creation with a <schema name> equal
to <schema authorization identifier>.

NOGO:
     None.
          
TEST SPECIFICATION.
Let AUTH1 be the authorization identifier under which the
program will be run, and let AUTH2 be another authorization
identifier. AUTH1 must have authority to create a schema with
authorization identifier AUTH2. AUTH1 and AUTH2 (and TA and
TB, used later) are used here for convenience of reference and
are not intended to restrict the choice of names used in the
test program.

Ensure that there is no schema in the current catalog with a
schema name equal to AUTH1, and no schema in the current
catalog with a schema name equal to AUTH2.

i) Execute a <schema definition> that specifies AUTHORIZATION
AUTH1, but does not contain an explicit <schema name>, and
which contains a <table definition> that defines a table, TA,
with two columns, one of numeric data type and the other of a
character string data type.

Use a  COMMIT statement to terminate the transaction that
created the schema.

Insert five distinct rows into table TA. Use an ordered cursor
to retrieve the rows of TA, and check that the values returned
after each fetch are equal to the values that were inserted in
the table. Terminate the transaction with COMMIT. In some, but
not necessarily all references to the table TA and its
columns, include the schema name explicitly in the reference.

ii)  Execute a <schema definition> that specifies an
AUTHORIZATION AUTH2, but does not contain an explicit <schema
name> and which contains:
-    a <table definition> that defines a table, TB, with two
     columns, one of numeric data type and the other of a
     character string data type;
-    a <grant statement> that grants  SELECT and INSERT
     privileges on table TB to the authorization identifier
     under which the program is to be executed.

Use a  COMMIT statement to terminate the transaction that
created the schema.

Insert five rows in the table.

Use an ordered cursor to retrieve the rows of the table in
order to check that the table was created successfully, that
AUTH1 was granted the specified privileges, and the rows were
inserted as expected. In some, but not necessarily all
references to the table TB and its columns, include the schema
name explicitly in the reference.

After execution of each SQL statement check that the value
returned in SQLSTATE indicates successful completion.

If any of the checks failed record a verdict of 'fail'
otherwise record a verdict of 'pass'.

Since the program cannot undo the creation of the schemas and
table, unless elements from Feature #38 -- Schema Manipulation
are supported, code to do the appropriate drops can be
included but failure to execute it successfully should not
result in a 'fail' verdict. Where an implementation does not
support the necessary language elements, the schemas and their
associated <schema element>s must be dropped at the end of the
tests by external means which will be implementation dependent
(possibly a script or a program designed for this task).

(13 March 1995)


CTS5 SQL2 Test Purpose 028: Feature #31

IDENTIFICATION:
     TEST7014, XTS714

DESCRIPTION:
     Schema definition named schema, implicit auth-id.

REFERENCES:
     11.1  --  <Schema definition>
     11.1 AR.1
     11.1 SR.2
     11.1 SR.3
     11.1 GR.3
     12.5  --  <SQL procedure statement>
               12.5 LR.2.a  --    Raised. Entry SQL
               restriction "An <SQL procedure statement> shall
               not be an <SQL schema definition statement>.
     F#1  --  Dynamic SQL
     F#31  --  Schema definition statement.

TEST PURPOSE.
To determine that execution of a <schema definition> that
specifies a <schema name> without an explicit <catalog name>
and does not specify AUTHORIZATION results in the creation of
a schema with the specified name and with an authorization
identifier, equal to the module or session authorization
identifier, as applicable.

NOGO:
     None

TEST SPECIFICATION.
Ensure that there are no schemata  in the current catalog with
schema names equal to the <schema name>s about to be created.

i) Execute a <schema definition> that contains an explicit
<schema name> but does not specify AUTHORIZATION, and which
contains a <table definition> that defines a table with two
columns, one of numeric data type and the other of a character
string data type, using the following syntax:

   CREATE SCHEMA TEST2831
     CREATE TABLE TESTAB2831
        (TCHAR CHAR(10)
         TNUM   NUMERIC(5);

Use a COMMIT statement to terminate the transaction.

Insert a five rows in the table. Use an ordered cursor to
retrieve the rows of the table and check that the schema and
its table was created successfully, and the rows were inserted
and are present with the anticipated content. In some, but not
necessarily all, references to the table and its columns,
include an explicit reference to the schema name.

ii) Use dynamic SQL with a <preparable SQL schema statement>
and execute a <execute immediate statement> creating a schema
with an explicit <schema name> which also contains a <table
definition> that specifies a table with two columns, one of
numeric data type and the other of a character string data
type.

Use a COMMIT statement to terminate the transaction.

Insert five rows in the table. Use a select statement with
COUNT and check by counting the rows that five rows have been
inserted. Use a <select statement: single row> and examine the
contents of  the first row and check that the row is present
with the anticipated content. Use an ordered cursor and
retrieve the remaining rows and check that all the rows are
present and with the anticipated content. In some, but not
necessarily all, references to the table and its columns,
include an explicit reference to the schema name.

After execution of each SQL statement check that the value
returned in SQLSTATE indicates successful completion.

If any of the checks failed record a verdict of 'fail'
otherwise record a verdict of 'pass'.

Since the program cannot undo the creation of the schema and
its table, which requires elements from Feature #38 -- Schema
Manipulation, the schemas and their associated <schema
element>s will be dropped at the end of the tests by external
means which will be implementation depended (possibly a script
or a program designed for this task).

All the names used are for ease of description only, and are
not intended to constrain the choice of names in the test
program or in the database.

(13 March 1995)



CTS5 SQL2 Test Purpose 029: Feature #31

IDENTIFICATION:
     TEST7015, XTS715

DESCRIPTION:
     Schema definition named schema and auth-id.

REFERENCES:
     11.1  --  <Schema definition>
     11.1 GR.3
     12.5  --  <SQL procedure statement>
               12.5 LR.2.a  --    Raised. Entry SQL
               restriction "An <SQL procedure statement> shall
               not be  an <SQL schema definition statement>.
     21.2.4  --  SCHEMATA view.
     F#17 -- Multiple schemas per user.
     F#2   -- Basic Information schema.
     F#31 -- Schema definition statement.

TEST PURPOSE.
To determine that a named schema with a specified <schema
authorization identifier> but without specification of a
<catalog name> can be created within an <SQL procedure
statement> and this will result in a valid schema creation
with the specified schema name and schema authorization
identifier.

NOGO: None.

TEST SPECIFICATION.
Ensure that there are not any schemata present in the current
catalog with <schema name>s equal to those about to be
created.

i) Execute a <schema definition> that specifies an explicit
<schema name> and an explicit authorization identifier equal
the one under which the program will be executed, which also
contains a table definition that specifies a table with two
columns, one of numeric data type and the other of a character
string type.

Use a COMMIT statement to terminate the transaction.

Use a <select statement: single row> to determine through
access to the SCHEMATA view in the Information Schema that the
above schema was successfully created and there is one row in
the view identifying the above schema. Insert five rows in the
table and use an ordered cursor to retrieve the rows of the
table in order to check that the rows inserted in the table
are present and with the anticipated content.

ii) Execute a <schema definition> that specifies authorization
identifier different from the authorization identifier under
whom the program will run, specifying explicitly a <schema
name> without specifying an explicit <catalog name>, and
containing:

-    a <table definition> that specifies a table with two
     columns one of numeric data type and the other of
     character string data type.
-    a <grant statement>s that grants SELECT, INSERT and
     UPDATE privileges on the table to the authorization
     identifier under which the program is to be run

Use a COMMIT statement to terminate the transaction.

Insert five rows in the table and use a select statement with
COUNT to check that indeed five rows were inserted in the
table. Use an ordered cursor and retrieve the rows of the
table in order to check that all the rows that  were inserted
are present with the anticipated content.

Attempt to modify the first row of the table. Use a <select
statement: single row> to retrieve the updated row in order to
determine that the contents of the row have been updated thus
ensuring that the GRANT was successful and that the user under
which the program is run  has access and update rights to the
table.
Since the program cannot undo the creation of the schema and
its table, which requires elements from Feature #38 -- Schema
Manipulation, the schemas and their associated <schema
element>s will be dropped at the end of the tests by external
means which will be implementation depended (possibly a script
or a program designed for this task).

After execution of each SQL statement check that the value
returned in SQLSTATE indicates successful completion.

If any of the checks failed record a verdict of 'fail'
otherwise record a verdict of 'pass'.


CTS5 SQL2 Test Purpose 030: Feature #31

IDENTIFICATION
     TEST7562, YTS805

DESCRIPTION
     Schema with crossed referential constraints between
tables

REFERENCES
     11.1 -- <schema definition>
     11.8 F -- <referential constraint definition>
     11.8 SR2
     11.7 SR2b -- <unique constraint definition>
     F#31 -- Schema definition statement
     F#33 -- Constraint tables

TEST PURPOSE
To determine that execution as an <SQL statement> in an
implicit or explicit <procedure> of a <schema definition> that
specifies the creation of multiple tables with a circular
chain of referential constraints results in the creation of
the specified schema, tables and constraints. The chain of
referential constraints is such that there is a sequence of
tables A, B, C, ..., Z, where the <table definition> of A
contains a <referential constraint definition> that references
columns in B, the <table definition> of B contains a
<referential constraint definition> that references columns in
C,  and so on, with each table referencing the next in the
sequence, until finally the <table definition> of Z contains a
<referential constraint definition> that references columns in
A.

NOGO
     None

TEST SPECIFICATION
Let T1, T2, T3, T4, T5 be data types available in Entry SQL.

Ensure that the current catalog does not contain a schema
named ZZZ.

Execute a <schema definition> that specifies a <schema name>
ZZZ and the following tables:

          AAA      with five columns, A1, A2, A3, A4, A5, with
     data types T1, T2, T3, T4, T5, respectively.  Columns A1
     and A2 are identified as the primary key. Referential
     constraint RA1 specifies A3 and A4 as <referencing
     columns> and table BBB as <referenced table and columns>.
     Referential constraint RA2 specifies A5 as <referencing
     columns> and column C3 of table CCC as <referenced table
     and columns>.

          BBB      with four columns, B1, B2, A1, A2, with data
     types T3, T4, T1, T2, respectively. Columns B1 and B2 are
     identified as the primary key. Referential constraint RB1
     specifies A1 and A2 as <referencing columns> and columns
     A1 and A2 of table AAA as <referencing table and
     columns>. Unique constraint UB2 specifies columns A1 and
     A2 as its <unique column list>.

          CCC      with three columns, B1, B2, C3, with data types
     T3, T4, T5, respectively. Column C3 is identified as the
     primary key. Referential constraint RC1 specifies B1 and
     B2 as <referencing columns> and columns B1 and B2 of
     table BBB as <referenced table and columns>.

Commit the creation of the schema.

Check that the Schemata view in the Information Schema
contains a row describing schema ZZZ.

Check that the TABLE_CONSTRAINTS view contains rows describing
the referential constraints and unique constraints of schema
ZZZ.

Attempt to insert a row of non-null values into each of tables
AAA, BBB and CCC. Check that in each case that the attempt is
unsuccessful and that the value returned in SQLSTATE indicates
integrity constraint violation.

Insert a row in table AAA with non-null values in columns A1
and A2, and null values elsewhere.

Insert a row in table BBB with non-null values in all columns,
and the values in columns A1 and A2 equal respectively to the
values stored in columns A1 and A2 of table AAA.

Insert a row in table CCC with non-null values in all columns,
and the values in columns B1 and B2 equal respectively to the
values stored in columns B1 and B2 of table BBB.

Insert a second row in table AAA with non-null values in all
columns, the values in columns A3 and A4 equal respectively to
the values stored in columns B1 and B2 of table BBB, and the
value in column A5 equal to the value stored in column C3 of
table CCC.

Check that table AAA now contains two rows and that tables BBB
and CCC now each contain one row.

After each execution of an SQL statement, check that, except
where some other value is specified above, that the value
returned in SQLSTATE indicates successful completion.

If any check has failed, record a verdict of 'fail', other
wise record a verdict of 'pass'.


Although specific names are used above for tables and columns,
they are introduced for ease of reference and are not intended
to constraint implementation in any way. Constraint names are
used for ease of description, however the constraints should
not be named in the test program, as this test is not intended
to check implementation of Feature F#49, Constraint
management.


(New 4 April 1995)


CTS5 SQL2 Test Purpose 031: Feature #32

IDENTIFICATION:
     TEST7016, XTS716

DESCRIPTION:
     SET SESSION AUTHORIZATION to current auth-id.

REFERENCES
     16.4  --  <set session authorization identifier
statement>.
     16.4 GR.1
               16.4 LR.2a  --Raised. Entry SQL restriction
               that prohibits the use of any  <set session
               authorization identifier statement>.
     6.2 -- <value specification> and <target specification>.
     6.2  SR.3
     6.2  GR.9
               6.2  LR.2c  --Raised. Entry SQL restriction
               which prohibits the specification of
               CURRENT_USER, SYSTEM_USER or SESSION_USER in a
               <general value specification>.
     F#32  --  User authorization.
     F#1  --  Dynamic SQL.

TEST PURPOSE.
To determine that when a <set session authorization identifier
statement> that specifies a value equal to the current user
authorization identifier when that is equal to the session
authorization identifier is executed, the execution is
successful.

NOGO :  None.

TEST SPECIFICATION.
Ensure that the current authorization has access rights to a
table TA1.  Preserve the original authorization identifier A
into a host variable X padded with leading and trailing
spaces. Ensure that no transaction is currently active.

Use a <set session authorization identifier statement> to
change the session authorization identifier to the value in
host variable X. Check that the value returned in SQLSTATE
indicates successful execution. Use a <select statement:
single row> on table TA1 and check that the expected row is
returned, thus determining that user with authorization X has
the same access rights as before.

Use a Dynamic SQL <execute immediate statement> to execute a
<set session authorization identifier statement> with a <value
specification> of USER to change the session <authorization
identifier> to the current authorization identifier .

Check that the value returned by SQLSTATE indicates successful
execution. Use Dynamic SQL to execute a <select statement:
single row> with a <set function specification> of COUNT(*) to
count all the rows of table TA1 and check that the anticipated
number is returned, thus determining that authorization
identifier with value USER has the same access rights as
before.

If any of the checks failed record a verdict of 'fail'
otherwise record a verdict of 'pass'.


(Revised, NCC, 23 June 1995)


CTS5 SQL2 Test Purpose 032: Feature #32

IDENTIFICATION:
     TEST7017, XTS717

DESCRIPTION:
     SET SESSION AUTHORIZATION to current auth-id inside
transaction.

REFERENCES
     16.4 --  <set session authorization identifier
statement>.
     16.4 GR.1
     16.4 GR.2
     16.4 LR.2a -- Raised. Entry SQL restriction that
prohibits the use of any  <set session
                   authorization identifier statement>.
     6.2  --  <value specification> and <target
specification>.
     6.2  SR.3
     6.2  GR.9
               6.2  LR.2c -- Raised. Entry SQL restriction
               which prohibits the specification of
               CURRENT_USER, SYSTEM_USER or SESSION_USER in a
               <general value specification>.
     F#32 --   User authorization.

TEST PURPOSE.
To determine that when a <set session authorization identifier
statement> is executed during an active SQL transaction then
an exception condition of "invalid transaction state" is
raised.

NOGO : None.

TEST SPECIFICATION.
Retrieve the value of the current authorization identifier
into a host variable USR.

In order to activate an SQL transaction use a cursor and
retrieve rows from a table TA1 from the standard schema owned
by the current authorization identifier. Before all the rows
of the table are retrieved, attempt to  change the session
authorization by executing  a <set session authorization
statement> with <value specification> of  CURRENT_USER.

Check that the value returned in SQLSTATE is '25000',
indicating the raising of the exception condition: invalid
transaction state.

To ensure that an SQL transaction is active, insert a row in
table TA1 with an <insert statement>. Immediately after the
insertion of rows without committing the insertion, attempt to
change the session authorization by using a <set session
authorization statement> with <value specification> of the
host variable USR.

Check that the value returned in SQLSTATE is '25000',
indicating the raising of the exception condition: invalid
transaction state.

Except where a check for some other value is specified, after
each execution of an SQL statement check that the value
returned in SQLSTATE indicates successful completion.

If any check fails, record a verdict of 'fail', otherwise
record a verdict of 'pass'.

(Revised, NCC, 23 June 1995)


CTS5 SQL2 Test Purpose 033: Feature #32

IDENTIFICATION
     TEST7018, XTS718

DESCRIPTION:
     SET SESSION AUTHORIZATION to different value.

REFERENCES
     16.4  --  <set session authorization identifier
statement>.
     16.4 GR.2
     16.4 GR.5
     16.4 LR.2a -- Raised. Entry SQL restriction that
prohibits the use of any  <set session
                   authorization identifier statement>.
     6.2  --  <value specification> and <target
specification>.
     6.2  GR.10
     6.2  GR.11
               6.2  LR.2c -- Raised. Entry SQL restriction
               which prohibits the specification of
               CURRENT_USER, SYSTEM_USER or SESSION_USER in a
               <general value specification>.
     5.4  --  <Names and identifiers>
     5.4 SR.3
     5.4 SR.18
     F#32  --  User authorization.

TEST PURPOSE.
To determine that  on execution of a <set session
authorization identifier statement> which specifies a value as
<value specification> that is a valid authorization identifier
that is different from the current user, the session
authorization identifier becomes equal to the specified value,
and if the value specified by the <value specification> is not
a valid authorization identifier, then an exception condition
of "invalid authorization specification" is raised.

NOGO:  None.

TEST SPECIFICATION.
Ensure that the current user A has access rights to a table
TA1 from the standard schema but has no access rights to a
table TA2 owned by an authorization identifier B.  Preserve
the value of the current authorization identifier A into a
host variable. Ensure that no transaction is currently active.

Use a <set session authorization identifier statement> to
change the current session authorization identifier to user B.

Check that the value returned by SQLSTATE indicates successful
execution.

Attempt to access table TA2 using a <select statement: single
row> and check that the expected row is returned thus
determining that the current authorization identifier is B.

Execute a <set session authorization identifier statement>
that specifies a <value specification> that does not contain a
valid authorization identifier. Check that an exception
condition of "invalid authorization specification" is raised
indicated by the return of the value '28000' in SQLSTATE.

Attempt to set the session authorization specification to
PUBLIC, which will again should raise an exception condition
of "invalid authorization specification" and a value in
SQLSTATE of '28000'.

Use a Dynamic SQL <execute immediate statement> to execute a
<set session authorization identifier statement> to change the
session authorization identifier to a valid user X who has
access rights to a table TAX, with the <value specification>
containing X padded with leading and trailing spaces to a size
of more than 128 characters. Check that the value in SQLSTATE
indicates successful execution. Use a <select statement:
single row> and a <set function specification> of COUNT(*) to
count the rows of table TAX. Check that the anticipated result
is returned, thus ensuring that the current authorization
identifier is X.

Finally use a <set session authorization identifier statement>
with <value specification> of the host variable in which the
original authorization identifier A was preserved at the
beginning of the tests in order to restore the original
session authorization identifier.  Check SQLSTATE for
successful execution and use a <select statement: single row>
on table TA1 and ensure that the expected row is returned.

If any of the checks failed record a verdict of 'fail',
otherwise record a verdict of 'pass'.


(Revised, NCC, 23 June 1995)


CTS5 SQL2 Test Purpose 034: Feature #33

IDENTIFICATION
          a)  TEST7537, YTS765
     b)   TEST7538, YTS765
     c)   TEST7539, YTS765

DESCRIPTION
     (Access to TABLE_CONSTRAINTS view)
     a)   Explicit table constraints in TABLE_CONSTRAINTS view
     b)   Column constraints in TABLE_CONSTRAINTS view
     c)   Unique identification in TABLE_CONSTRAINTS view

REFERENCES
     21.2.13  --  TABLE_CONSTRAINTS view
     21.3.13  -- TABLE_CONSTRAINTS base table
     F# 33 -- Constraint tables
     F#2 -- Basic information schema

     a)   11.6 SR1 -- <table constraint definition>
          11.6 GR2
          11.7 -- <unique constraint definition>
          11.8 -- <referential constraint definition>
          11.9 -- <check constraint definition>

     b)   11.4 -- <column definition>
          11.4 SR9
          11.7 -- <unique constraint definition>
          11.8 -- <referential constraint definition>
          11.9 -- <check constraint definition>

     c)   10.6 -- <constraint name definition> and <constraint
          attributes>
          10.6  SR2
          11.6  SR2

TEST PURPOSE
a)   To determine that the TABLE_CONSTRAINTS view in the
     Information Schema is accessible to a user and contains
     rows describing the table constraints in the current
     schema that were declared explicitly as table constraints
     and are owned by that user.

b)   To determine that the TABLE_CONSTRAINTS view in the
     Information Schema is accessible to a user and contains
     rows describing the table constraints in the current
     schema that were declared as column constraints and are
     owned by that user.

c)   To determine that, for a given user, the values in each
     row in the TABLE_CONSTRAINTS view in the Information
     Schema of CONSTRAINT_CATALOG, CONSTRAINT_SCHEMA and
     CONSTRAINT_NAME  are non-null and are different from the
     corresponding values in any other row.

NOGO:
     None.

TEST SPECIFICATION
a)   Retrieve through the view TABLE_CONSTRAINTS in the
     Information Schema the rows corresponding to a known set
     of table constraints in the current schema that are owned
     by the current user and were defined explicitly as table
     constraints in a table definition in a schema
     definition.. Check that all expected rows are present and
     are returned with the anticipated content. Visibility of
     rows corresponding to constraints in the other schemata
     owned by the current user is not to be checked.
b)   Retrieve through the view TABLE_CONSTRAINTS in the
     Information Schema the rows corresponding to a known set
     of table constraints in the current schema that are owned
     by the current user and were defined as column
     constraints in a column definition in a table definition
     in a schema definition.. Check that all expected rows are
     present and are returned with the anticipated content.
     Visibility of rows corresponding to constraints in the
     other schemata owned by the current user is not to be
     checked.

c)   For each of the columns CONSTRAINT_CATALOG,
     CONSTRAINT_SCHEMA and CONSTRAINT_NAME in the
     TABLE_CONSTRAINTS view in the Information Schema, check
     that no row contains the null value. Check that the set
     of values in those columns is different for every row.

PROGRAMMING SPECIFICATION
Create a program that will execute under authorization
identifier "CTS5" using schema "CTS5". Ensure that the schema
contains at least one table constraint defined in each of the
following ways:

a) Table constraint declared as such:
     unique
     primary key
     referential
     check

b) Table constraint declared as column constraint
     NOT NULL
     unique
     references
     check

Each constraint definition must be such that the constraint
can be identified without reference to a constraint name, for
example by ensuring that the pair of columns (TABLE_NAME,
CONSTRAINT_TYPE) is sufficient to identify each of the
constraints that is the subject of this test from all other
constraints in the schema. For each of the constraints, check
that there is a row corresponding to that constraint in the
view, and  that each of the following columns contain
appropriate values:
     CONSTRAINT_SCHEMA (must be 'CTS5'),
     TABLE_SCHEMA (must be 'CTS5'),
     IS_DEFERRABLE (for Intermediate SQL, value must be
'NO'),
     INITIALLY_DEFERRED (for Intermediate SQL, value must be
'NO')

Record pass or fail separately for a) and b).

c)   For each of the columns CONSTRAINT_CATALOG,
     CONSTRAINT_SCHEMA and CONSTRAINT_NAME in the
     TABLE_CONSTRAINTS view in the Information Schema, use the
     <null predicate> to determine that none of the values in
     the column is null. Use the set functions  COUNT * and
     COUNT DISTINCT to determine that the columns
     CONSTRAINT_CATALOG, CONSTRAINT_SCHEMA and CONSTRAINT_NAME
     contain a different set of values in each row.


(Editorial change, 1 May 1995)


CTS5 SQL2 Test Purpose 035: Feature #33

IDENTIFICATION
          a)  TEST7540, YTS766
     b)   TEST7541, YTS766
     c)   TEST7542, YTS766
     d)   TEST7543, YTS766

DESCRIPTION
     (Access to REFERENTIAL_CONSTRAINTS view)
     a)   Explicit table constraints in
          REFERENTIAL_CONSTRAINTS view
     b)   Column constraints in REFERENTIAL_CONSTRAINTS view
     c)   Unique identification in REFERENTIAL_CONSTRAINTS
          view
     d)   Values in columns of REFERENTIAL_CONSTRAINTS view

REFERENCES
     21.2.14  --  REFERENTIAL_CONSTRAINTS view
     21.3.15  -- REFERENTIAL_CONSTRAINTS base table
     F# 33 -- Constraint tables
     F#2 -- Basic information schema

     a)   11.8 -- <referential constraint definition>
          11.6  SR2
          11.6 GR2 -- <table constraint definition>
          2.2.13 -- TABLE_CONSTRAINTS view

     b)   11.8 -- <referential constraint definition>
          11.4 -- <column definition>
          11.4 SR9
          11.6  SR2
          2.2.13 -- TABLE_CONSTRAINTS view

     c)   10.6 -- <constraint name definition> and <constraint
          attributes>
          10.6  SR2
          11.6  SR2

     d)   21.3.15 F
          11.8 LR 1a
          11.8 LR 2a

TEST PURPOSE
a)   To determine that the REFERENTIAL_CONSTRAINTS view in the
     Information Schema is accessible to a user and contains
     rows describing the referential constraints in the
     current schema that were declared explicitly as table
     constraints and are owned by that user.

b)   To determine that the REFERENTIAL_CONSTRAINTS view in the
     Information Schema is accessible to a user and contains
     rows describing the referential constraints in the
     current schema that were declared as column constraints
     and are owned by that user.

c)   To determine that, for a given user, in each row in the
     REFERENTIAL_CONSTRAINTS view in the Information Schema,
     the values  of CONSTRAINT_CATALOG, CONSTRAINT_SCHEMA and
     CONSTRAINT_NAME are non-null and are sufficient to
     distinguish that row from all other rows.

d)   To determine that, for a given user, in each row in the
     REFERENTIAL_CONSTRAINTS view in the Information Schema,
     the values in the columns UNIQUE_CONSTRAINT_CATALOG,
     UNIQUE_CONSTRAINT_SCHEMA, UNIQUE_CONSTRAINT_NAME,
     MATCH_OPTION, UPDATE_RULE, and DELETE_RULE are all non-
     null, and that the values in the columns MATCH_OPTION,
     UPDATE_RULE, and DELETE_RULE are all valid.
NOGO:
     None.

TEST SPECIFICATION
a)   Determine through the TABLE_CONSTRAINTS view the
     constraint names of a known set of table constraints in
     the current schema that are owned by the current user and
     were defined explicitly as table constraints in a table
     definition in a schema definition. By use of the
     constraint names and the schema name, retrieve through
     the view REFERENTIAL_CONSTRAINTS in the Information
     Schema the rows corresponding to those constraints .
     Check that all expected rows are present and are returned
     with the anticipated content. Visibility of rows
     corresponding to constraints in any other schemata owned
     by the current user is not to be checked.

b)   Determine through the TABLE_CONSTRAINTS view the
     constraint names of a known set of table constraints in
     the current schema that are owned by the current user and
     were defined as column constraints in a column definition
     in a table definition in a schema definition. By use of
     the constraint names and the schema name, retrieve
     through the view REFERENTIAL_CONSTRAINTS in the
     Information Schema the rows corresponding to those
     constraints. Check that all expected rows are present and
     are returned with the anticipated content. Visibility of
     rows corresponding to constraints in the other schemata
     owned by the current user is not to be checked.

c)   In the REFERENTIAL_CONSTRAINTS view in the Information
     Schema, check that there is no row in which any of the
     columns CONSTRAINT_CATALOG, CONSTRAINT_SCHEMA and
     CONSTRAINT_NAME contains the null value. Check that the
     set of values in those columns is different for every
     row. Apply these checks to all rows owned by the current
     user.

d)   In the REFERENTIAL_CONSTRAINTS view in the Information
     Schema, check that the values in the columns
     UNIQUE_CONSTRAINT_CATALOG, UNIQUE_CONSTRAINT_SCHEMA,
     UNIQUE_CONSTRAINT_NAME, MATCH_OPTION, UPDATE_RULE, and
     DELETE_RULE are all non-null, and that the values in the
     columns MATCH_OPTION, UPDATE_RULE, and DELETE_RULE are
     from the appropriate sets, as follows:

     MATCH_OPTION:  ( 'NONE', 'PARTIAL', 'FULL' );
     UPDATE_RULE:  ('CASCADE', 'SET NULL', 'SET DEFAULT', 'NO
     ACTION );
     DELETE_RULE:  ('CASCADE', 'SET NULL', 'SET DEFAULT', 'NO
     ACTION ).

PROGRAMMING SPECIFICATION
Create a program that will execute under authorization
identifier "CTS5" using schema "CTS5". Ensure that the schema
contains at least one table constraint defined in each of the
following ways:

a) Table constraint declared as such:
     referential referencing a table in the same schema;
     referential referencing a table in a different schema.

b) Table constraint declared as column constraint:
     references referencing a table in the same schema;
     references referencing a table in a different schema.

In order to avoid dependence on support for other FIPS
features, each of the constraints must be uniquely
identifiable within the schema 'CTS5' by the pair of columns
(TABLE_NAME, CONSTRAINT_TYPE) in the Information Schema view
TABLE_CONSTRAINTS.

a)&b)For each of the subject constraints, use the values of
     the columns (TABLE_NAME, CONSTRAINT_TYPE) to determine
     the constraint name of the constraint. (Note that this
     name will be assigned by the implementation.) Check that
     there is a row with that constraint name in the
     REFERENTIAL_CONSTRAINTS view, and  that each of the
     following columns contain appropriate values:
              UNIQUE_CONSTRAINT_SCHEMA,
          MATCH_OPTION (must be 'NONE'),
          UPDATE_RULE (must be 'NO ACTION'),
          DELETE_RULE (must be 'NO ACTION').
     Record pass or fail separately for a) and b).

c)   For each of the columns CONSTRAINT_CATALOG,
     CONSTRAINT_SCHEMA and CONSTRAINT_NAME in the
     REFERENTIAL_CONSTRAINTS view in the Information Schema,
     use the <null predicate> to determine that none of the
     values in the column is null. Use the set functions
     COUNT * and  COUNT DISTINCT * to determine that the
     columns CONSTRAINT_CATALOG, CONSTRAINT_SCHEMA and
     CONSTRAINT_NAME contain a different set of values in each
     row. Record a pass if the two counts return the same
     value and that value is non-zero, otherwise record a
     fail.

d)   For each of the columns UNIQUE_CONSTRAINT_CATALOG,
     UNIQUE_CONSTRAINT_SCHEMA, UNIQUE_CONSTRAINT_NAME,
     MATCH_OPTION, UPDATE_RULE, and DELETE_RULE in the
     REFERENTIAL_CONSTRAINTS view in the Information Schema ,
     use the <null predicate> to determine that none of the
     values in the column is null. Use the <in predicate> to
     check that the values in the columns MATCH_OPTION,
     UPDATE_RULE, and DELETE_RULE are from the appropriate
     sets, as follows:

     MATCH_OPTION:  ( 'NONE', 'PARTIAL', 'FULL' );
     UPDATE_RULE:  ('CASCADE', 'SET NULL', 'SET DEFAULT', 'NO
     ACTION );
     DELETE_RULE:  ('CASCADE', 'SET NULL', 'SET DEFAULT', 'NO
     ACTION ).

     Record a fail if any of the values is null or is not a
     member of the appropriate set. Otherwise, record a pass.


(Editorial revision, 1 May 1995)


CTS5 SQL2 Test Purpose 036: Feature #33

IDENTIFICATION
     a). TEST7544, YTS767
     b). TEST7545, YTS767
     c). TEST7546, YTS767
     d). TEST7547, YTS767

DESCRIPTION
     (Access to CHECK_CONSTRAINTS view)
     a). Explicit table constraints in CHECK_CONSTRAINTS view.
     b). Column constraints in CHECK_CONSTRAINTS view.
     c). Domain constraints in CHECK_CONSTRAINTS view.
     d). Unique identification in CHECK_CONSTRAINTS view.

REFERENCES
     21.2.15 -- CHECK_CONSTRAINTS view
     21.2.13 -- TABLE_CONSTRAINTS view
     11.4 SR9 -- <check constraint definition>
     11.6.SR1 -- <table constraint definition>
     11.9 -- <check constraint definition>
     10.6 SR2 -- <constraint name definition> and <constraint
     attributes>
     11.6 SR2 -- <table constraint definition>
     11.21 -- <domain definition>
     F#33 -- Constraint tables
     F#25 -- Domain definition.
     F#17 -- Multiple schemas per user
     F#3 -- Basic Schema Manipulation.
     F#2 -- Basic information schema

TEST PURPOSE
a)   To determine that the CHECK_CONSTRAINTS view in the
     Information Schema is accessible to a user and contains
     rows describing the check constraints in the schemas
     owned by that user that were declared explicitly as table
     constraints.

b)   To determine that the CHECK_CONSTRAINTS view in the
     Information Schema is accessible to a user and contains
     rows describing the check constraints in the schemas
     owned by that user that were declared explicitly as
     column constraints.

c)   To determine that the CHECK_CONSTRAINTS view in the
     Information Schema is accessible to a user and contains
     rows describing the check constraints in the schemas
     owned by that user that were declared as domain
     constraints.

d)   To determine that, for a given user, in each row in the
     CHECK_CONSTRAINTS view in the Information Schema, the
     values of CONSTRAINT_CATALOG,  CONSTRAINT_SCHEMA and
     CONSTRAINT_NAME are non-null and are sufficient to
     distinguish that row from all other rows.

NOGO:
     None.

TEST SPECIFICATION
Establish two or more schemas owned by the same authorization
identifier. Within those schemas, ensure that there are a
number of check constraints declared as table constraints,
column constraints and domain constraints. Ensure also that
there are in separate schemas two tables with identical
descriptions, including identical column definitions and
identical column and table constraint definitions. Similarly,
ensure that two separate schemas contain identical domain
definitions with identical domain constraint definitions.
Ensure also that there is at least one table constraint in one
schema that applies to a table in another schema owned by the
same authorisation identifier.

a)   Determine through the TABLE_CONSTRAINTS view the
     constraint names of a known set of table constraints in
     the current catalog that are owned by the current user
     and were defined explicitly as table constraints. By use
     of the constraint names and schema names, retrieve
     through the view CHECK_CONSTRAINTS in the Information
     Schema the rows corresponding to those constraints. Check
     that all expected rows are present and are returned with
     the anticipated content. Visibility of the rows
     corresponding to other constraints in any schemata owned
     by the user is not to be checked.

 b)  Determine through the TABLE_CONSTRAINTS view the
     constraint names of a known set of table constraints in
     the current catalog that are owned by the current user
     and were defined as column constraints in a column
     definition in a table definition in a schema definition.
     By use of the constraint names and schema names, retrieve
     through the view CHECK_CONSTRAINTS in the Information
     Schema the rows corresponding to those constraints. Check
     that all expected rows are present and are returned with
     the anticipated content. Visibility of rows corresponding
     to other constraints in any schemata owned by the current
     user is not to be checked.

c)   Determine through the DOMAIN_CONSTRAINTS view the
     constraint names of a known set of domain constraints in
     the current schema that are owned by the current user and
     were defined in domain definitions in a schema
     definition. By use of the constraint names and schema
     names check that the Information Schema view
     CHECK_CONSTRAINTS contains a row for each of the
     identified constraints and that the anticipated text is
     present in each column.

d)   In the CHECK_CONSTRAINTS view in the INFORMATION_SCHEMA,
     check that there is no row in which any of the columns
     CONSTRAINT_CATALOG, CONSTRAINT_SCHEMA and CONSTRAINT_NAME
     contains the NULL value. Check that the set of values in
     those columns is different for every row. Apply these
     checks to all rows owned by the current user.

After each execution of an SQL statement, check that the value
returned in SQLSTATE indicates successful completion.

If any check fails, record a verdict of 'fail', otherwise
record a verdict of 'pass'.

(Editorial revision 31 January 1995)

CTS5 SQL2 Test Purpose 037: Feature #34

IDENTIFICATION
     TEST7019, XTS719

DESCRIPTION
     Access to KEY_COLUMN_USAGE view

REFERENCES:
     21.2.16  --  KEY_COLUMN_USAGE view.
     21.3.14  --  KEY_COLUMN_USAGE base table.
     F#1  --  Dynamic SQL.
     F#2  --  Basic information schema.
     F#3  --  Basic schema manipulation.
     F#34  --  Usage tables.

TEST PURPOSE
To determine that the KEY_COLUMN_USAGE view in the Information
schema is accessible to a user and contains exactly the rows
that identify, for each constraint of the types "UNIQUE",
"PRIMARY KEY" and "FOREIGN KEY" on a table owned by the
current user, all the columns that constitute the unique
constraint or are referencing columns in the foreign key
constraint; and in each row, the values in the columns
CONSTRAINT_CATALOG, CONSTRAINT_SCHEMA, CONSTRAINT_NAME,
TABLE_NAME and COLUMN_NAME are sufficient to distinguish that
row from all other rows in the view.

NOGO
     None

TEST SPECIFICATION
The specific names of database items are used below for ease
of description only, and are not intended to constrain the
actual names that will be used in the test programs.

Connect to the database with an authorization identifier X who
owns just one schema with a name equal to X and no <schema
element>s at all. Use a <set function specification> with
COUNT(*) function and count from the KEY_COLUMN_USAGE view in
the Information Schema, the columns that describe key
constraints owned by that user. Check that the value returned
is zero, since no applicable objects are owned by X.

Create a table TA1 in schema X with four columns, two of
numeric data type and the remaining two of character string
data type, declaring the first column of numeric data type
col1 as a primary key and the second column of numeric data
type col2 with a UNIQUE constraint.

Commit the creation of the table.

Use a <select statement: single row> to retrieve a count from
the KEY_COLUMN_USAGE view of the number of rows where the
value in the column TABLE_SCHEMA is equal to X, the current
authorization identifier, and the value in the column
TABLE_NAME is 'TA1'.  Check  that the value returned equals
two.

Create a second table TA2 in schema X with four columns, two
of numeric data type and two of character string data type,
declaring a column of numeric data type as a foreign key
referencing column col2 of table TA1 and a column of character
string data type with UNIQUE and NOT NULL constraints.

Commit the creation of the table.

Use a <select statement: single row> to retrieve a count from
the KEY_COLUMN_USAGE view of the number of rows where the
value in the column TABLE_SCHEMA is equal to X, the current
authorization identifier.  Check  that the value returned
equals five.

Drop table TA1 with CASCADE <drop behavior> and commit.

Use Dynamic SQL with a <preparable statement> to prepare and
execute a <select statement: single row> to retrieve a count
from the KEY_COLUMN_USAGE view of the number of rows where the
value in the column TABLE_SCHEMA is equal to X, the current
authorization identifier. Check  that the value returned
equals three.

Restore the database in its original state by using a <drop
table statement> with <table name> TA2.

After execution of each SQL statement check that the value
returned in SQLSTATE indicates successful execution.

If any of the checks failed record a verdict of 'fail'
otherwise record a verdict of 'pass'.


CTS5 SQL2 Test Purpose 038: Feature #34

IDENTIFICATION
     TEST7020, XTS720

DESCRIPTION
     Access to VIEW_TABLE_USAGE view

REFERENCES
     21.2.21  --  VIEW_TABLE_USAGE view
     21.3.11  --  VIEW_TABLE_USAGE base table
     11.19  -- <view definition>
     11.20  --  <drop view statement>
     F#1  --  Dynamic SQL.
     F#2  --  Basic information schema.
     F#3  --  Basic schema manipulation.
     F#34  --  Usage tables.

TEST PURPOSE
To determine that the VIEW_TABLE_USAGE view in the Information
schema  is  accessible to a user and it contains  exactly  the
rows   that   identify  a  table  referenced  in  the   <query
expression> of a view for all the views in the current catalog
owned by that user, and in each row, the values in the columns
of   VIEW_CATALOG,   VIEW_SCHEMA,  VIEW_NAME,   TABLE_CATALOG,
TABLE_SCHEMA  and   TABLE_NAME are sufficient  to  distinguish
that row from all other rows in the view.

NOGO
     None.

TEST SPECIFICATION
The  names of database items are specified below for  ease  of
description only, and are not intended to constrain the actual
names that will be used in the test programs.

The   program   is  to  be  executed  under  an  authorization
identifier,  X,  which  owns just one schema,  also  named  X.
Initially, schema X contains no <schema element>s.

Use  a <set function specification> with the COUNT(*) function
and  count  from the VIEW_TABLE_USAGE view in the  Information
Schema  the  rows that describe tables that are referenced  by
the   <query  expression>  of  views  owned  by  the   current
authorization  identifier. Check that the result  returned  is
zero since no applicable objects are owned by X.

Create  two tables TA1 and TA2  and two views VA1 and  VA2  in
schema  X. Define both tables with two columns, one of numeric
data type and the other of character string data type.  Define
view VA1 with references to TA1 and TA2 and one table from one
of the standard schemas in its <query expression>. Define view
VA2  with references to TA1 and TA2 and no other tables in its
<query expression>.

Commit the creation of the tables and the views.

Use Dynamic SQL to execute a  <select statement(s):single row>
that  uses the COUNT function to determine the number of  rows
in  the  VIEW_TABLE_USAGE  view  where  the  column  VIEW_NAME
contains 'VA1'and column VIEW_SCHEMA contains 'X'. Check  that
the value returned is three.

Use Dynamic SQL to execute a  <select statement(s):single row>
that  uses the COUNT function to determine the number of  rows
in  the  VIEW_TABLE_USAGE  view  where  the  column  VIEW_NAME
contains 'VA2'and column VIEW_SCHEMA contains 'X'. Check  that
the value returned is two.

Terminate the transaction.

Use  dynamic  SQL to execute a <drop view statement>  to  drop
view VA1 with CASCADE <drop behavior>.

Commit the action.

Use   cursor  ordered  on  column  TABLE_NAME  to  access  the
VIEW_TABLE_USAGE view from the Information Schema and retrieve
all  the  rows that identify tables referenced in  the  <query
expression>  of  views  in the current catalog  owned  by  the
current   user.   Check  that  two  rows  are  returned,   all
identifying  view VA2 in the VIEW_NAME column and with  values
in  the  column TABLE_NAME of TA1 in the first row and TA2  in
the second.

Terminate the transaction.

Use  a <drop view statement> with CASCADE <drop behavior>  and
drop view VA2.

Commit the action.

Use   a  <select  statement  :  single  row>  and  access  the
VIEW_TABLE_USAGE view from the Information schema and retrieve
all  the  rows  that  identify table names referenced  in  the
<query  expression> of views in the current catalog  owned  by
the  current  user. Check that the value returned in  SQLSTATE
indicates that there are no such rows ('02000') .

Terminate the transaction.

Restore  the  database in its original state by executing  two
<drop  table  statement>s, that specify tables  TA1  and  TA2,
respectively, and CASCADE <drop behavior>. Commit the actions.

Except where a check for some other value is specified,  after
execution of each SQL statement check that the value  returned
in SQLSTATE indicates successful execution.

If  any  of  the  checks failed record a  verdict  of  'fail',
otherwise record a verdict of 'pass'.


(Revised 4 July 1995)


CTS5 SQL2 Test Purpose 039: Feature #34

IDENTIFICATION
     TEST7021, XTS721

DESCRIPTION
     Access to VIEW_COLUMN_USAGE view

REFERENCES
     21.2.22  --  VIEW_COLUMN_USAGE view
     21.3.12  --  VIEW_COLUMN_USAGE base table
     11.19 -- <view definition>
     11.20  --  <Drop view statement>
     F#34  --  Usage tables
     F#1  --  Dynamic SQL
     F#2  --  Basic information schema
     F#3  --  Basic schema manipulation
     F#43  --  Scrolled cursors

TEST PURPOSE
To   determine  that  the  VIEW_COLUMN_USAGE   view   in   the
Information  schema  is  accessible to  a  user  and  contains
exactly  the  rows  that  identify  each  a  column  that   is
implicitly  or explicitly referenced in the <query expression>
of  a  view for all the views in the current catalog owned  by
that  user;  and  in  each  row the  values  of  VIEW_CATALOG,
VIEW_SCHEMA,     VIEW_NAME,    TABLE_CATALOG,    TABLE_SCHEMA,
TABLE_NAME and COLUMN_NAME are sufficient to distinguish  that
row from all other rows in the view.

NOGO
     None.

TEST SPECIFICATION
The  names of database items are specified below for  ease  of
description only, and are not intended to constrain the actual
names that will be used in the test programs.

The   program   is  to  be  executed  under  an  authorization
identifier,  X,  which  owns just one schema,  also  named  X.
Initially, schema X contains no <schema element>s.

Use  a <set function specification> with the COUNT(*) function
and  count  from the VIEW_TABLE_USAGE view in the  Information
Schema  the  rows that describe tables that are referenced  by
the   <query  expression>  of  views  owned  by  the   current
authorization  identifier. Check that the result  returned  is
zero since no applicable objects are owned by X.

Create  a  view VA1 which references a table from one  of  the
test  system  standard  schemas  in  its  <query  expression>,
specifying  a single <query specification> that specifies  '*'
as  <select list> and references a column of the table in  the
<where clause> of its <table expression>.

Commit the creation of the view.

Use  a  cursor  ordered on column COLUMN_NAME  to  access  the
VIEW_COLUMN_USAGE  view  from  the  Information   schema   and
retrieve   all  the  rows  that  identify  columns  that   are
referenced  in the <query expression> of views  in  schema  X.
Check  that  four  rows  are  returned  with  the  anticipated
contents.

Terminate the transaction.

Drop view VA1 with CASCADE <drop behaviour>.

Commit the action.

Use  Dynamic  SQL to execute a <select statement: single  row>
that uses a <set function specification> of  COUNT to retrieve
from the VIEW_COLUMN_USAGE view in the Information schema  the
number  of rows that describe columns referenced in the <query
expression>  of  views  in the current catalog  owned  by  the
current user. Check that the result returned by COUNT is zero,
thus ensuring that the contents of the view have been updated.

After  execution of each SQL statement check  that  the  value
returned in SQLSTATE indicates successful execution.

If  any  of  the  checks failed record a  verdict  of  'fail',
otherwise record a verdict of 'pass'.


(Modified 4 July 1995)


CTS5 SQL2 Test Purpose 040: Feature #34

IDENTIFICATION
     TEST7022, XTS722

DESCRIPTION
     Access to CONSTRAINT_TABLE_USAGE view

REFERENCES
     21.2.23  --  CONSTRAINT_TABLE_USAGE view.
     21.3.18  --  CHECK_COLUMN_USAGE base table.
     21.3.15  --  REFERENTIAL_CONSTRAINTS base table.
     21.3.13  --  TABLE_CONSTRAINTS base table.
     11.6  --  <Table constraint definition>
     F#34  -  Usage tables
     F#1  --  Dynamic SQL.
     F#2  --  Basic information schema.
     F#3  --  Basic schema manipulation.

TEST PURPOSE
To  determine  that  the CONSTRAINT_TABLE_USAGE  view  in  the
Information  schema is accessible to a user  and  it  contains
exactly   the  rows  that  identify  each  a  table  used   by
referential   constraints,  unique   constraints   and   check
constraints defined in the current catalog owned by that user;
and in each row of the CONSTRAINT_TABLE_USAGE view, the values
of        TABLE_CATALOG,       TABLE_SCHEMA,       TABLE_NAME,
CONSTRAINT_CATALOG,  CONSTRAINT_SCHEMA,  CONSTRAINT_NAME   are
sufficient to distinguish that row from all other rows in  the
view.

NOGO
     None.

TEST SPECIFICATION
The  names of database items are specified below for  ease  of
description only, and are not intended to constrain the actual
names that will be used in the test programs.

The   program   is  to  be  executed  under  an  authorization
identifier,  X,  which  owns just one schema,  also  named  X.
Initially, schema X contains no <schema element>s.

Use  a <set function specification> with the COUNT(*) function
to  determine the number of rows in the CONSTRAINT_TABLE_USAGE
view in the Information Schema. Check that the result returned
is zero since no applicable objects are owned by X.

Terminate the transaction.

In  schema  X create a table, TA,  with columns TA1,  TA2  and
TA3,  which  have numeric, numeric and character  string  data
types,  respectively,  a <unique constraint  definition>  that
specifies  column  TA1 to be the PRIMARY  KEY,  and  a  <check
constraint definition> that restricts the values in column TA2
to be positive.

In  schema  X  create a table, TB, with columns TB1  and  TB2,
both  with  character string data types,  and  a  <referential
constraint  definition> that specifies that column  TB1  is  a
foreign key referencing column TA3 of table TA.

Commit the creation of the tables.

Use  a  <select statement: single row> with two <set  function
specification>s  that  specify COUNT  to  determine  from  the
CONSTRAINT_TABLE_USAGE view the number of distinct  values  in
column   TABLE_NAME  and  the  number  of  values  in   column
CONSTRAINT_NAME. Check that the values returned  are  two  for
column TABLE_NAME and three for column CONSTRAINT_NAME.

Terminate the transaction.
Drop  table  TA1 with CASCADE <drop behavior> and  commit  the
action.

Execute  an  <execute immediate  statement> that  specifies  a
<select  statement:  single row> that specifies   COUNT(*)  to
determine  the  number  of rows in the  CONSTRAINT_TABLE_USAGE
view. Check that the value returned is zero.

Terminate the transaction.

Drop  table  TA2 with CASCADE <drop behavior> and  commit  the
action.

After  execution of each SQL statement check  that  the  value
returned in SQLSTATE indicates successful execution.

If  any  of  the  checks failed record a  verdict  of  'fail',
otherwise record a verdict of 'pass'.


(Modified 4 July 1995)


CTS5 SQL2 Test Purpose 041: Feature #34

IDENTIFICATION
     TEST7023, XTS722

DESCRIPTION
     Access to CONSTRAINT_COLUMN_USAGE view

REFERENCES
     21.2.24  --   CONSTRAINT_COLUMN_USAGE view
     21.3.18  --   CHECK_COLUMN_USAGE base table
     21.3.15  --   REFERENTIAL_CONSTRAINTS base table
     21.3.14  --   KEY_COLUMN_USAGE base table
     21.3.13  --   TABLE_CONSTRAINTS base table
     F#34  --  Usage tables
     11.4  --  <Column definition>
     F#2  --  Basic information schema
     F#3  --  Basic schema manipulation

TEST PURPOSE
To  determine  that the CONSTRAINT_COLUMN_USAGE  view  in  the
Information  schema is accessible to a user  and  it  contains
exactly  the  rows that identify each a column  name  used  by
referential   constraints,  unique   constraints   and   check
constraints defined in the current catalog owned by that user;
in each row in the CONSTRAINT_COLUMN_USAGE view, the values of
TABLE_CATALOG,    TABLE_SCHEMA,    TABLE_NAME,    COLUMN_NAME,
CONSTRAINT_CATALOG,  CONSTRAINT_SCHEMA,  CONSTRAINT_NAME   are
non-null  when  applicable column constraints are  defined  by
that user and are sufficient to distinguish that row from  all
other rows in the view.

NOGO
     None.

TEST SPECIFICATION
The  names of database items are specified below for  ease  of
description only, and are not intended to constrain the actual
names that will be used in the test programs.

The   program   is  to  be  executed  under  an  authorization
identifier,  X,  which  owns just one schema,  also  named  X.
Initially, schema X contains no <schema element>s.

Use  a <set function specification> with the COUNT(*) function
to determine the number of rows in the CONSTRAINT_COLUMN_USAGE
view in the Information Schema. Check that the result returned
is zero since no applicable objects are owned by X.

Terminate the transaction.

Use    an    ordered    cursor   and   retrieve    from    the
CONSTRAINT_COLUMN_USAGE view the rows  where  the  columns  of
COLUMN_NAME  and  CONSTRAINT_NAME  identify  columns  used  by
referential,  unique  and  check constraints  in  the  current
catalog owned the current user. Check that exactly three  rows
are retrieved and that the rows have the anticipated contents.

Use  a  <select  statement: single row> with a  <set  function
specification> of COUNT and count the occurences in the column
CONSTRAINT_NAME of the CONSTRAINT_COLUMN_USAGE view of all the
column  names  that  used  by referential,  unique  and  check
constraints  in  the current catalog owned the  current  user.
Check that the value returned is zero.

After  execution of each SQL statement check  that  the  value
returned in SQLSTATE indicates successful execution.

If  any  of  the  checks failed record a  verdict  of  'fail',
otherwise record a verdict of 'pass'.


(Modified 4 July 1995)


CTS5 SQL2 Test Purpose 042: Feature #34

IDENTIFICATION
     TEST7024, XTS724

DESCRIPTION
     Access to COLUMN_DOMAIN_USAGE view.

REFERENCES
     21.2.25   --   COLUMN_DOMAIN_USAGE view.
     11.21     --   <Domain definition>.
     11.27     --   <Drop domain statement>.
     F#25 --  Domain definition.
     F#2  --  Basic information schema.
     F#3  --  Basic schema manipulation.
     F#34 --  Usage tables.

TEST PURPOSE
To   determine  that  the  COLUMN_DOMAIN_USAGE  view  in   the
Information  schema is accessible to a user  and  it  contains
exactly  the  rows that identify each a column  name  that  is
dependent on a domain defined in the current catalog owned  by
that  user;  and  in  each  row of that  view  the  values  of
DOMAIN_CATALOG,  DOMAIN_SCHEMA,  DOMAIN_NAME,   TABLE_CATALOG,
TABLE_SCHEMA,  TABLE_NAME and  COLUMN_NAME are  sufficient  to
distinguish that row from all other rows in the view.

NOGO
     None.

TEST SPECIFICATION
The  names  of database items are used for ease of description
only, and are not intended to constrain the actual names  that
will be used in the test programs.

The   program   is  to  be  executed  under  an  authorization
identifier,  X,  which  owns just one schema,  also  named  X.
Initially, schema X contains no <schema element>s.

Using   a  <set  function  specification>  with  the  COUNT(*)
function,  count the number of rows in the Information  Schema
view  COLUMN_DOMAIN_USAGE where column DOMAIN_SCHEMA  contains
'X'. Check that the value returned is zero.

Terminate the transaction.

Use  a  <domain definition statement> to create a domain named
TESTDOM  for data type INTEGER with a value range  of  greater
than 500.

Commit the creation of the domain.

In schema X, create a table TA with four columns, all based on
the domain TESTDOM. Commit the creation of the table.

Declare  a  cursor,  CR,  over  the  Information  Schema  view
COLUMN_DOMAIN_USAGE  to  retrieve the  columns  DOMAIN_SCHEMA,
TABLE_NAME,  and  COLUMN_NAME  from  the  rows  where   column
DOMAIN_NAME contains 'TESTDOM', ordered by COLUMN_NAME.

Open  the  cursor and fetch all rows. Check that exactly  four
rows  are  returned and that the values in  each  row  are  as
expected.

Terminate the transaction.

Execute  a  <drop domain statement> that specifies TESTDOM  as
<domain  name> and CASCADE as <drop behavior> to  destroy  the
domain TESTDOM.
Execute  a <drop table statement> that specifies TA as  <table
name> CASCADE <drop behavior> to destroy table TA.

Commit the destruction of the domain and the table.

Using   a  <set  function  specification>  with  the  COUNT(*)
function,  count the number of rows in the Information  Schema
view  COLUMN_DOMAIN_USAGE where column DOMAIN_SCHEMA  contains
'X'. Check that the value returned is zero.

Terminate the transaction.

After each execution of an SQL statement, check that the value
returned in SQLSTATE indicates successful completion.

If  any  of  the  checks failed record  a  verdict  of  'fail'
otherwise record a verdict of 'pass'.


(Modified 4 July 1995)


CTS5 SQL2 Test Purpose 043: Feature #35

IDENTIFICATION
     TEST7550, YTS768

DESCRIPTION
     Access to SCHEMATA view

REFERENCES
     21.2.4 -- SCHEMATA view
     F#35 -- Intermediate information schema
     F#17 -- Multiple schemas per user

TEST PURPOSE
To determine that a user can access the SCHEMATA view in the
Information Schema, and that the view contains one row for
each schema owned by that user and no rows for other schemata.

NOGO
     None

TEST SPECIFICATION
Ensure that there is more than one schema owned by the current
user, and that the names of the schemata are known.

Access the view INFORMATION_SCHEMA.SCHEMATA and use SELECT
COUNT to confirm that one row exists for each schema owned by
the current user.

Create a cursor based on the view INFORMATION_SCHEMA.SCHEMATA,
open the cursor and retrieve all rows. For each row, check
that the SCHEMA-OWNER column contains the name of the current
user and that the SCHEMA_NAME column contains the name of a
schema owned by the current user.

Check that no rows are selected from SCHEMATA view where the
SCHEMA_OWNER is not the current user.

After execution of each SQL statement, check that the value
returned in SQLSTATE indicates the expected result.

If any check fails, record the verdict 'fail'; otherwise
record the verdict 'pass'.


(Editorial changes 31 January 1995)
(Corrected 14 July 1995)



CTS5 SQL2 Test Purpose 044: Feature #35

IDENTIFICATION
     TEST7551, YTS769

DESCRIPTION
Access to DOMAINS view

REFERENCES
21.2.5 -- DOMAINS view
11.21 -- <domain definition>
F#35 -- Intermediate information schema
F#17 -- Multiple schemas per user
F#25 -- Domain definition

TEST PURPOSE
To determine that a user can access the DOMAINS view in the
Information Schema and that the view contains a row for each
of the domains defined in the current catalog that are
accessible to a given user.

NOGO
     None

TEST SPECIFICATION
Ensure that there are two or more schemas owned by the current
user and that each of those schemas contains one or more
domains with known names, and that there is at least one
domain with a known name that is owned by another user and
over which the current user has been granted the USAGE
privilege.

Using a cursor, retrieve from the view
INFORMATION_SCHEMA.DOMAINS all rows identifying the set of
known domains. Check that the value in SQLSTATE indicates that
the opening of the cursor and the retrieval of each row is
successful. Check that there is exactly one row for each known
domain and that the values in the columns of that row contain
the correct description of the domain. Close the cursor and
terminate the transaction.

Create a new domain in one schema with a name that is the same
as that of an existing domain in another schema. Check that
the value in SQLSTATE indicates that the domain has been
created. Commit the creation of the domain.

Check that the view INFORMATION_SCHEMA.DOMAINS now contains
rows for both the new domain and for the pre-existing domain
that has the same name. Terminate the transaction.

Drop the new domain.  Check that the value in SQLSTATE
indicates that the domain has been destroyed. Commit the
transaction.

Check that the view INFORMATION_SCHEMA.DOMAINS no longer
contains a row for the new domain, but still contains the row
for the pre-existing domain that has the same name.

If any of the specified checks fails, or if the value of
SQLSTATE after any SQL statement indicates that execution of
that statement has been unsuccessful, record a fail; otherwise
record a pass.



CTS5 SQL2 Test Purpose 045: Feature #35

IDENTIFICATION
     TEST7552, YTS770

DESCRIPTION
Access to DOMAIN_CONSTRAINTS view

REFERENCES
     21.2.6 -- DOMAIN_CONSTRAINTS view
     11.21 -- <domain definition>
     F#35 -- Intermediate information schema
     F#17 -- Multiple schemas per user
     F#25 -- Domain definition

TEST PURPOSE
To determine that the INFORMATION_SCHEMA.DOMAIN_CONSTRAINTS
view contains a row for each of the domain constraints of
domains defined in the current catalog that are accessible to
the current user.

NOGO
     None

TEST SPECIFICATION
Ensure that there are two or more known schemas owned by the
current user and that each of those schemas contains one or
more domains with known names and that there are domain
constraints associated with at least two of those domains.

Using a cursor, retrieve from the view
INFORMATION_SCHEMA.DOMAIN_CONSTRAINTS all rows identifying the
set of known domain constraints. Check that the value in
SQLSTATE indicates that the opening of the cursor and the
retrieval of each row is successful. Check that there is
exactly one row for each known domain constraint and that the
values in the columns of that row contain the correct
description of the domain constraint. Close the cursor and
terminate the transaction.

Create a new domain, with a domain constraint, in one schema
with a name that is the same as that of an existing domain in
another schema. Check that the value in SQLSTATE indicates
that the domain has been created. Commit the creation of the
domain.

Check that the view INFORMATION_SCHEMA.DOMAIN_CONSTRAINTS
contains a row for the new domain constraint. Terminate the
transaction.

Drop the new domain.  Check that the value in SQLSTATE
indicates that the domain has been destroyed. Commit the
transaction.

Check that the view INFORMATION_SCHEMA.DOMAIN_CONSTRAINTS no
longer contains a row for the the new domain CONSTRAINT.

Determine the number of rows in the
INFORMATION_SCHEMA.DOMAIN_CONSTRAINTS view where the
DOMAIN_SCHEMA does not contain the name of a schema owned by
the current authorisation identifier. Check that the count is
zero.

If any of the specified checks fails, or if the value of
SQLSTATE after any SQL statement indicates that execution of
that statement has been unsucessful, record a fail; otherwise
record a pass.

(TP corrected 14 July 1995)

CTS5 SQL2 Test Purpose 046: Feature #35

IDENTIFICATION
     TEST7553, YTS771

DESCRIPTION
Access to CHARACTER_SETS view

REFERENCES
     21.2.18 -- CHARACTER_SETS view
     21.3.23 DE5 -- CHARACTER_SETS base table
     F#35 -- Intermediate information schema

TEST PURPOSE
To determine that the INFORMATION_SCHEMA.CHARACTER_SETS view
is accessible to a user and contains a row for the character
set INFORMATION_SCHEMA.SQL_TEXT, and that the columns
DEFAULT_COLLATE_SCHEMA and DEFAULT_COLLATE_NAME contain,
respectively, the values 'INFORMATION_SCHEMA' and 'SQL_TEXT'.

NOGO
None

TEST SPECIFICATION
Using a <select statement: single row>, retrieve from the
CHARACTER_SETS view in the schema  INFORMATION_SCHEMA the row
in which the column CHARACTER_SET_SCHEMA contains the value
'INFORMATION_SCHEMA' and the column CHARACTER_SET_NAME
contains the value 'SQL_TEXT'. Check that the row exists.

Check that the column DEFAULT_COLLATE_CATALOG contains the
same value as the column CHARACTER_SET_CATALOG.

Check that the column DEFAULT_COLLATE_SCHEMA contains the
value 'INFORMATION_SCHEMA'.

Check that the column DEFAULT_COLLATE_NAME contains the value
"SQL_TEXT''.

If any of the specified checks fails, or if the value of
SQLSTATE after any SQL statement indicates that execution of
that statement has been unsuccessful, record a fail; otherwise
record a pass.


(Editorial changes 31 January 1995)


CTS5 SQL2 Test Purpose 047: Feature #35

IDENTIFICATION
     TEST7554, YTS772

DESCRIPTION
     Access to ASSERTIONS view

REFERENCES
     21.2.17 -- ASSERTIONS view
     F#35 -- Intermediate information schema

TEST PURPOSE
To determine that the INFORMATION_SCHEMA.ASSERTIONS view is
accessible to a user.

NOGO
     None

TEST SPECIFICATION
Declare a cursor based on the ASSERTIONS view in the schema
INFORMATION_SCHEMA and  explicitly specifying all columns of
that view. Open the cursor. Check that the value returned in
SQLSTATE indicates that the cursor has been opened
successfully.

Attempt to retrieve a row from the cursor. Check that the
value returned in SQLSTATE indicates either that a row has
been returned successfully, or that no row has been returned
(i.e. that a completion condition no data has been raised).

Check that the column IS_DEFERRABLE in the view
INFORMATION_SCHEMA.ASSERTIONS contains no null values.

Check that the column INITIALLY_DEFERRED in the view
INFORMATION_SCHEMA.ASSERTIONS contains no null values.

Check that in all rows of the view
INFORMATION_SCHEMA.ASSERTIONS, the columns IS_DEFERRABLE and
INITIALLY_DEFERRED contain one of the pairs of values:
     ( 'NO', 'NO' )
     ( 'YES', 'NO' )
     ( 'YES', 'YES' )

If any of the specified checks fails, record a verdict of
'fail'; otherwise record a verdict of 'pass'.

Note:Visibility of the ASSERTIONS view is required in
     Intermediate SQL, but support of assertions is not
     required unless conformance to Full SQL is claimed, so
     the view cannot be populated in Intermediate SQL.


(Editorial changes 31 January 1995)



CTS5 SQL2 Test Purpose 048: Feature #35

IDENTIFICATION
     TEST7555, YTS773

DESCRIPTION
     Access to SQL_LANGUAGES view

REFERENCES
     21.2.26 -- SQL_LANGUAGES view
     21.3.26 -- SQL_LANGUAGES base table
     F#35 -- Intermediate information schema

TEST PURPOSE
To determine that the INFORMATION_SCHEMA.SQL_LANGUAGES view is
accessible to a user; that it contains at least one row
identifying the programming language and binding style in
which the test is implemented; and that all rows in the view
satisfy the constraints on the content of the view.

NOGO
     None

TEST SPECIFICATION
Declare a cursor based on the SQL_LANGUAGES view in the schema
INFORMATION_SCHEMA and  explicitly specifying all columns of
that view. Open the cursor. Check that the value returned in
SQLSTATE indicates that the cursor has been opened
successfully.

Attempt to retrieve a row from the cursor. Check that the
value returned in SQLSTATE indicates that a row has been
returned successfully, and that the value is  derived from the
column SQL_LANGUAGE_SOURCE is non-null.

Check that for all rows in the view, the value in the column
SQL_LANGUAGE_SOURCE is non-null.

Check, using <select statement: single row> and the <set
function specification> COUNT (*), that there is at least one
row that identifies the programming language and binding style
in which the test is implemented.

Check, using <select statement: single row> and the <set
function specification> COUNT (*), that, in every row where
the column SQL_LANGUAGE_SOURCE contains the value 'ISO 9075',
the value in  column SQL_LANGUAGE_IMPLEMENTATION is null, and
the values in the columns SQL_LANGUAGE_CONFORMANCE and
SQL_LANGUAGE_YEAR are non-null.

Check, using <select statement: single row> and the <set
function specification> COUNT (*), that, in every row where
the column SQL_LANGUAGE_SOURCE contains the value 'ISO 9075',
the values in columns SQL_LANGUAGE_YEAR,
SQL_LANGUAGE_INTEGRITY, SQL_LANGUAGE_CONFORMANCE,
SQL_LANGUAGE_BINDING_STYLE and
SQL_LANGUAGE_PROGRAMMING_LANGUAGE satisfy the constraint
SQL_LANGUAGES_STANDARD_VALID_CHECK.

If any of the specified checks fails,  or if the value
returned in SQLSTATE following execution of any SQL statement
does not indicate successful execution, record a verdict of
'fail'; otherwise record a verdict of 'pass'.

Note:Checks on specific language source, year, or conformance
     level are excluded in order to permit use of this test
     with implementations that claim support for this feature
     but not necessarily for any complete level of standard
     SQL.

(Editorial revision 31 January 1995)


CTS5 SQL2 Test Purpose 049: Feature #35

IDENTIFICATION
     TEST7556, YTS774

DESCRIPTION
     Access to INFORMATION_SCHEMA_CATALOG_NAME base table

REFERENCES
     21.2.2 -- INFORMATION_SCHEMA_CATALOG_NAME base table
     TC1 21.2.2 -- Table constrained to have a single row
     F#35 -- Intermediate information schema

TEST PURPOSE
To determine that the table
INFORMATION_SCHEMA.INFORMATION_SCHEMA_CATALOG_NAME is
accessible to a user; that it contains exactly one row; and
that the column CATALOG_NAME in that row contains the name of
the catalog that contains the Information Schema.

NOGO
     None

TEST SPECIFICATION
Retrieve a row from the Information Schema table
INFORMATION_SCHEMA_CATALOG_NAME, using <select statement:
single row>. Check that exactly one row is returned, and that
neither the completion condition no data nor the exception
cardinality violation is raised.

Check that the value returned in the column CATALOG_NAME is
not null.

Check that there is a row in the view
INFORMATION_SCHEMA.TABLES where the value in the column
TABLE_CATALOG is the value retrieved from the column
CATALOG_NAME in the Information Schema table
INFORMATION_SCHEMA_CATALOG_NAME, and that the values in the
columns TABLE_SCHEMA, TABLE_NAME and TABLE_TYPE are
'INFORMATION_SCHEMA', 'TABLES' and 'BASE TABLE', respectively.

If any of the specified checks fails, or if the value returned
in SQLSTATE following execution of any SQL statement does not
indicate successful execution, record a verdict of 'fail';
otherwise record a verdict of 'pass'.



(Editorial changes 31 January 1995)


CTS5 SQL2 Test Purpose 050: Feature #36

IDENTIFICATION
     TEST7557, YTS775

DESCRIPTION
     SQL host program with duplicate local variable names

REFERENCES
     19.1 -- <embedded SQL host program>
     19.1 SR1 -- multiple SQL <embedded SQL declare section>s
     permitted
     19.1 LR2b)
     F# 36 -- Subprogram support

TEST PURPOSE
To determine that two or more <host variable definition>s in
an <embedded SQL host program> may specify the same variable
name, provided that when each such <host variable definition>
is replaced by a data definition in the target host language
the resulting program is a valid program in that host
language. To determine that if reference to that variable name
is made from an <embedded SQL statement> that is an <SQL
procedure statement> in a position where such a reference may
be made according to the rules for the host language, then the
correct variable is referenced.

Note that this Test Purpose is applicable only to the Embedded
SQL language interfaces defined in clause 19 of the SQL
standard, and is not applicable to Module or Direct Invocation
interfaces.

Note also that the detailed realisation of this Test Purpose
in any particular host language may depend on the rules of
that language regarding the structure of compilation units and
the scope of variable names.

NOGO:
     None.

TEST SPECIFICATION
In those host languages, such as COBOL, that permit
duplication of variable names within the same scope provided
that those names are not referenced, declare two host language
variables with the same name and different data types that are
not referenced in the host program.

Create an embedded host language compilation unit with a
program structure consisting of a main program and two
disjoint subprograms. Let X and Y be two valid variable names
in that host language. In the main program and at least one of
the subprograms, declare variables named X of the same data
type. In both subprograms, declare variables named Y with the
same data type, different from the data type of the variables
named X.

At a point where the instance of X declared in the main
program is in scope, retrieve a value from the database, using
a <select statement: single row>, into the instance of X in
the main program.  Check that the correct value has been
retrieved, and that, if the rules of the host language permit,
the value of the instance of X declared in the subprogram has
not been changed.

At a point where the instance of X declared in the subprogram
is in scope, retrieve a value from the database, using a
<fetch statement> and a suitable declared cursor, into the
instance of X declared in the subprogram. Check that the
correct value has been retrieved, and that the value of the
instance of X declared in the main program has not been
changed.

In the first subprogram, retrieve a value from the database,
using a <select statement: single row>, into the instance of Y
in the scope of that subprogram.  Check that the correct value
has been retrieved, and that, if the rules of the host
language permit, the value of the instance of Y in the scope
of the other subprogram has not been changed.

At a point where the instance of Y declared in the second
subprogram is in scope, retrieve a value from the database,
using a <fetch statement> and a suitable declared cursor, into
the instance of Y declared in the second subprogram. Check
that the correct value has been retrieved, and that the value
of the instance of Y declared in the first program has not
been changed.

The terms "scope" and "subprogram" should be interpreted
according to the conventions of each particular host language.


CTS5 SQL2 Test Purpose 051: Feature #37

IDENTIFICATION
     TEST7025, XTS725

DESCRIPTION
     Flagging - Full SQL INSENSITIVE cursor.

REFERENCES
     13.1  --  <declare cursor>
     4.21  --  Cursors
     13.1 LR.1a  --  Intermediate SQL restriction which
prohibits the specification of  INSENSITIVE cursors.
     13.2  --  <open statement>
     13.2  --  13.GR3.e i
     F#79  --  Insensitive cursors.
     F#37  --  Intermediate SQL flagging.

TEST PURPOSE
To check that when Intermediate Syntax Only flagging is
enabled, an implementation will flag declaration of a cursor
as INSENSITIVE, and to check that when the content of a table
on which an insensitive cursor is based while the cursor is
open, the change is not visible through that cursor before it
is closed.

NOGO:
     None

TEST SPECIFICATION
Use a table from the standard schema with four columns, two of
numeric data type and two of character string data type. The
table will already be populated with at least five rows.

Declare an ordered insensitive non scrolled cursor referencing
columns of the above table in its <query specification>.

Open the cursor and immediately insert one row in the table
with values such that it would occur in the cursor ordering
before any of the row that were present in the table when the
cursor was opened.. Check that the row was inserted
successfully with a <select statement: single row>.

Fetch all rows from the cursor, checking that the rows are
fetched with the anticipated order and content. Check that the
row that was inserted in the table is not fetched.

Close the cursor and open it again. Retrieve all the rows of
the cursor, checking that the inserted row is now included.

If all the checks were successful then record a verdict of
'pass', indicating visually that the vendor must demonstrate
FIPS flagger warning for the underlying test, otherwise record
a verdict of 'nogo'.


(Revised, 26 June 1995)


CTS5 SQL2 Test Purpose 052: Feature #37

IDENTIFICATION
     TEST7026, XTS726

DESCRIPTION
     Flagging - Full SQL - cursor with FOR UPDATE and ORDER BY

REFERENCES
     13.1  --  <declare cursor>
               13.1 LR.2b --  Entry SQL restriction which
               prohibits the use of an <updatability clause>
               within a <cursor specification>.
               13.1 LR.1b --  Intermediate SQL restriction
               which prohibits the use of <order by clause >
               in a cursor which was specified with an
               <updatability clause> of FOR UPDATE.
     13.9  --  <update statement: positioned>
     13.10  --  <update statement: searched>
     13.9 SR.4
     F#37  --  Intermediate SQL flagging.

TEST PURPOSE
To check that when Intermediate SQL Syntax Only flagging is
enabled, an implementation will flag the presence of FOR
UPDATE and ORDER BY in the same cursor declaration, and that
the underlying table may be updated through that cursor.

NOGO:
     None.

TEST SPECIFICATION
Use a table TA from the standard schema with four columns, TA1
and TA3 with numeric data types and TA2 and TA4 with character
string data types. The table will already be populated with at
least five rows each with unique values in every column.

The cursor specified in the following test (a) is valid
Intermediate SQL and should be flagged when Entry SQL flagging
is specified but not when Intermediate flagging is specified.

a) Declare a non-ordered cursor on TA with an <updatability
clause> of  FOR UPDATE with <column name list> of TA2 and TA3,
raising the rule 13.1LR.2b. In the <query specification> of
the <cursor specification> specify a <where clause> that
identifies one row of TA: the row where TA1 holds a value 'P6'
and TA2 a value 'E1'.

Open the cursor and fetch the first row, Z. Use an <update
statement: positioned> to modify row Z.

Check that the value returned in SQLSTATE indicates successful
execution, close the cursor and use a <select statement:
single row> to ensure that the contents of row Z have been
modified.

The cursor specified in the following test (b) is an extension
to Intermediate SQL and should be flagged when Intermediate
SQL flagging is specified.

b) Declare an ordered cursor on TA with an <updatability
clause> of FOR UPDATE with a <column name list> of TA2,
raising the rule 13.1 LR.1b, and specifying TA3 as <sort key>
of the <order by clause>. In the <query specification> of the
<cursor specification>  specify a <where clause> that
identifies one row of TA: the row, R, where column TA1 holds
the value 'D4'.

Open the cursor, and before any rows are fetched execute an
<update statement: searched> and update row R, setting the
value of column TA2 to 'ZF' with a <search condition> that
specifies the value in column TA4 being equal to 145. Check
that the value returned by SQLSTATE indicates successful
execution. Fetch all the rows and check that the rows are
returned with the anticipated contents, including row R.


The specified names for the table, columns and rows are used
for ease of description only and they are not meant to
constrain the names used in the development.

If all the checks were successful then record a verdict of
'pass', otherwise record a verdict of 'nogo'.

(Editorial revision, 26 June 1995)


CTS5 SQL2 Test Purpose 053: Feature #37

IDENTIFICATION
     TEST7027, XTS727

DESCRIPTION
     Flagging - Full SQL - <explicit table> in <query
expression>

REFERENCES
     7.10 -- <query expression>
     7.10 SR.2
     7.10 SR.5b
               7.10 LR.1b  -- Intermediate SQL restriction
               which prohibits the use of <explicit table> in
               a <simple table> in a <query expression>.
     F#37  --  Intermediate SQL flagging.

TEST PURPOSE
To check that when Intermediate SQL Syntax Only flagging is
enabled, an implementation will flag the presence of an
<explicit table> in a <simple table> in a <query expression>,
and that such a table is accessed correctly.

NOGO:
     None.

TEST SPECIFICATION
The use of <explicit table> effectively expands into TABLE
<table name> and the requirement is to insert "TABLE X" for
some table X in a place where it is permissible to use a <
query expression>.

Use a table TA from the standard schema with four columns, TA1
and TA2 of numeric data type and TA3 and TA4 of character
string data type. The table will already be populated with at
least five rows each with unique values in every column.

Use a <select statement : single row> and retrieve a row with
syntax :
     SELECT TA1, TA2 INTO :hv1, :hv2
          FROM TABLE TA
          WHERE TA3 = 'XX'


Check that the contents of the row where TA3 contains the
specified value are returned.

Use an <insert statement> with <explicit table> in <simple
table> with syntax - INSERT INTO TABLE TA ...- and insert one
row in table TA. Check that the value returned by SQLSTATE
indicates successful execution.

Use a <select statement: single row> and retrieve the inserted
row to determine that all the columns are present and with the
anticipated content.

If all the tests were successful then record a verdict of
'pass',  otherwise record a verdict of 'nogo'.

(New 27 June 1995)


CTS5 SQL2 Test Purpose 054: Feature #37

IDENTIFICATION
     TEST7028, XTS728

DESCRIPTION
     Flagging - Full SQL - <null predicate> with two-col row

REFERENCES
     8.6   -- <null predicate>.
     7.1   -- <row value constructor>.
     7.1 SR.1
               7.1 LR.1a  --  Intermediate SQL restriction
               which prohibits the use of more than one <row
               value constructor element> in a <row value
               constructor> that is not simply contained in a
               <table value constructor>.
     F#37  --  Intermediate SQL flagging

TEST PURPOSE
To check that when Intermediate SQL Syntax Only flagging is
enabled, an implementation will flag the use of a two columned
<row value constructor> that is contained in a <null
predicate>.

NOGO:
     None.


TEST SPECIFICATION
Use two tables, TA1 and TA2, each with two columns colA1 and
colA2, both of character string data type. In  table TA1 four
rows will exist where two rows will not contain any null
values, one row where one column will contain a null value and
one row where both columns will be null. Table TA2 will
initially be empty.

Use an <insert statement> that does not satisfy rule 7.1 LR.1a
with the syntax :

    INSERT INTO TA2
      SELECT  * FROM TA1
       WHERE (colA1,colA2) IS NOT NULL;

Check that the value returned by SQLSTATE indicates successful
execution. Use a <select statement: single row> twice and
examine the contents of table TA2 and check it contains two
rows identical to the two rows in table TA1 where neither
column contained the null value.

If all the tests were successful then record a verdict of
'pass', indicating that the vendor must demonstrate FIPS
flagger warning when elements of Full SQL are supported for
the underlying test; otherwise record a verdict of 'nogo'.



CTS5 SQL2 Test Purpose 055: Feature #38

IDENTIFICATION
     TEST7510, YTS776

DESCRIPTION
     DROP SCHEMA - empty schema with RESTRICT

REFERENCES
     11.2 <drop schema statement>
     11.1 <schema definition>
     F#38 schema manipulation
     F#3  basic schema manipulation
     F#31 schema definition statement
     F#17 multiple schemas per user
     F#35 Intermediate information schema

TEST PURPOSE
     To determine that execution of a <drop schema statement>
     that references an empty schema and specifies RESTRICT is
     successful, destroying the schema.

NOGO
     None

TEST SPECIFICATION
     Create an empty schema using the CREATE SCHEMA statement.
     Check that SQLSTATE indicates that the execution of the
     statement has been successful. Check that the schema
     exists by retrieving the row describing that schema from
     the SCHEMATA view in the Information Schema.

     Destroy the schema using a DROP SCHEMA name RESTRICT
     statement. Check that SQLSTATE indicates that the
     execution of the statement has been successful. Check
     that the schema no longer exists by determining that the
     row describing that schema no longer exists in the
     SCHEMATA view in the Information Schema.

     If all checks are successful, record a pass, otherwise
     record a fail.

PROGRAMMING SPECIFICATION.
     Check that the SCHEMATA view in the Information Schema
     does not contain a row describing a schema with schema
     'MARPLE'. If such a schema exists, terminate the program
     with an appropriate diagnostic message without recording
     a verdict.

     Create a schema with <schema name> 'MARPLE' and <schema
     authorization identifier> equal to the authorization
     identifier under which the program will be run, with no
     <schema element>s.

     Check that the  SCHEMATA view in the Information Schema
     now contains a row describing a schema with SCHEMA_NAME
     equal to  'MARPLE' and SCHEMA_OWNER equal to the current
     user.

     Execute the SQL statement:
          DROP SCHEMA MARPLE RESTRICT

     Check the  SCHEMATA view in the Information Schema no
     longer contains a row describing a schema with
     SCHEMA_NAME equal to  'MARPLE'.

     Check the values in SQLCODE and SQLSTATE at every stage
     of the program.

     If the program completes without error record a 'pass'
     else record a 'fail'.

CTS5 SQL2 Test Purpose 056: Feature #38

 Identification
     TEST7511, YTS777

 Description
      DROP SCHEMA - non-empty schema

 References
     11.2 -- <drop schema statement>
     11.2 SR3 -- Syntactic requirement for schema to be non-
     empty
     11.1 -- <schema definition>
     F#38 -- schema manipulation
     F#3 -- Basic schema manipulation
     F#1 -- Dynamic SQL

 TEST PURPOSE
     To determine that execution of a <drop schema statement>
     that references a non-empty schema is unsuccessful,
     leaving the schema intact, if the <drop schema statement>
     specifies RESTRICT, and is successful, destroying the
     schema,  if the <drop schema statement> specifies
     CASCADE.

 NOGO
     None.

 TEST SPECIFICATION
     Create a schema containing three tables and a view. Check
     that SQLSTATE indicates that the creation has been
     successful. Populate the three tables with a small number
     of rows that also effectively populate the viewed table.
     Check that SQLSTATE indicates that all statements used to
     populate the tables are successful, and make a further
     check by retrieving a row through the view.

     Attempt to drop the schema by executing a <drop schema
     statement> that specifies RESTRICT behaviour. Check that
     the execution of the statement is unsuccessful, with
     SQLCODE indicating a Syntax Rule or Access Rule violation
     ("42000"). Check that the tables in  the schema can still
     be accessed and contain information that was present
     before the attempt to drop the schema.

     Attempt to drop the schema by executing a <drop schema
     statement> that specifies CASCADE behaviour. Check that
     the value returned in SQLSTATE indicates that the
     execution of the statement is successful. Check that an
     attempt to access the schema is unsuccessful.

     If any check failed, record a fail; otherwise record a
     pass.

PROGRAMMING SPECIFICATION
     Use Dynamic SQL for those statements that can potentially
     be rejected as syntactically incorrect before execution
     by those implementations that make pre-execution-time
     checks against the content of the relevant schema.



CTS5 SQL2 Test Purpose 057: Feature #38

IDENTIFICATION
     TEST7520, YTS778

DESCRIPTION
     ALTER TABLE SET COLUMN DEFAULT

REFERENCES
     11.12 -- <alter column definition>
     11.13 -- <set column default clause>
     11.5 GR2 -- <default clause>
     F#38 -- Schema manipulation
     F#3 -- Basic schema manipulation
     F#25 Domain Definition

TEST PURPOSE
     To determine that execution of an <alter table statement>
     that contains a <set column default clause> sets the
     default value for the referenced column, whether or not
     there has previously been such a default value, and that
     where the column is defined on a domain with a domain
     default, the column default takes precedence over the
     domain default.

NOGO:
     None.

TEST SPECIFICATION
Ensure that table A, which is to be created for this test,
does not exist, destroying the table if necessary.

Create a table, A, with four columns, K, L, M and N, where a
column default is specified for L, and no column default is
specified for M. Column N is to be based on a domain for which
a domain default is defined. Column K is to contain an integer
used to identify rows in the table, and a distinct value is to
be provided in this column for each row inserted into the
table.

Insert three rows into table A, where:
          1)   K contains 1, and values are provided for
          columns L, M and N.
     2)   K contains 2, a value is provided for column L, and
          no value is provided for column M, which should thus
          contain the null value, and a value is provided for
          column N..
     3)   K contains 3, a value is provided for column M, and
          no values are provided for columns L, which should
          thus contain the default value for that column, and
          N, which should thus contain the default value for
          the domain.

Check that all three rows exist in table A and check that they
contain the expected values .

Set  column defaults for columns L and M and N, such that the
new default for column L differs from the old column default
for L and the column default for N differs from the applicable
domain default. The new defaults should also be different to
the existing values in the applicable columns.

Check that the content of the three rows has not changed.

Insert three more rows into table A where :
          1)   K contains 4, and values different from the
          relevant defaults are provided for each of columns
          L, M and N.
     2)   K contains 5, a value different from its default is
          provided for column L, and no values are provided
          for columns M and N, which should both assume the
          applicable defaults.
     3)   K contains 6, a value different from its default is
          provided for column M, and no values are provided
          for columns L and N, which should both assume the
          applicable defaults.

Check all six rows in table A to ensure that the values are as
expected.

After the execution of each  SQL statement, check that
SQLSTATE indicates successful execution.

If any check fails, record a fail else record a pass.



CTS5 SQL2 Test Purpose 058: Feature #38

IDENTIFICATION
     TEST7521, YTS779

DESCRIPTION
     ALTER TABLE DROP COLUMN DEFAULT

REFERENCES
     11.10 F2 -- <alter table statement>
     11.12 GR1 -- <alter column definition>
     11.13 -- <set column default clause>
     11.14 -- <drop column default clause>
     11.5 -- <default clause>
     F#38 -- Schema Manipulation
     F#3     Basic schema manipulation

TEST PURPOSE
     To determine that when an <alter table statement> that
     specifies the dropping of a column default is executed,
     then the values in that column in existing rows of the
     table are not affected, and that for any new rows
     inserted into the table the default value is the
     applicable domain default if one exists, and otherwise
     the null value.

NOGO
     None.

TEST SPECIFICATION
Use the table, A, created and populated in test TEST7520 in
the state in which it is left by that test. In separate
transactions, drop the column defaults for each of columns L,
M and N of table A. In each case, check that the value
returned in SQLSTATE indicates that execution of the statement
has been successful.

Retrieve all rows of table A. Check that each retrieval is
successful and that none of the values has changed.

Insert a new row into table A, with the value 7 in column K
and no values specified for the other columns. Check that the
insertion is successful. Check that a new row has been
inserted, and that in this row column K contains 7, columns L
and M contain the null value, and column N contains the
default value for the domain on which it is based.

If any check has failed, record a verdict of 'fail'; otherwise
record a verdict of 'pass'.



CTS5 SQL2 Test Purpose 059: Feature #38

IDENTIFICATION
     TEST7052, XTS752

DESCRIPTION
     ALTER TABLE ADD TABLE CONSTRAINT

REFERENCES
     11.10  --  <Alter table statement>
     11.10 AR.1
     11.16  --  <Add table constraint definition>
     F#38  --  Schema manipulation
     F#1  --  Dynamic SQL
     F#2  --  Basic Information Schema
     F#15  --  PRIMARY KEY enhancement
     F#49  --  Constraint management


TEST PURPOSE
To determine that when an <alter table statement> with an <add
table constraint definition> as <alter table action> is
executed then the target table's definition is changed and the
table constraint is added to the table descriptor.

NOGO:
     None

TEST SPECIFICATION
Create two tables TA1 and TA2 in the current schema owned by
the current authorization identifier, with the following
structure:

 TABLE TA1
     col1 NUMERIC(5),
     col2 CHAR(15) NOT NULL UNIQUE,
     col3 CHAR(15);

TABLE TA2
     c1 NUMERIC(5) PRIMARY KEY,
     c2 CHAR(15),
     c3 NUMERIC(5);

Commit the creation of the tables and leave both empty.

Using a <select statement: single row> with COUNT(*), access
the KEY_COLUMN_USAGE view from the Information Schema and
check that there are no rows where the values of the columns
CONSTRAINT_NAME, TABLE_NAME and COLUMN_NAME are equal to
TA1_prkey, TA1 and col1, respectively, and the value of column
TABLE_SCHEMA is the name of the current schema.

Terminate the transaction with commit or rollback.

Use an <alter table>  statement with an <add table constraint
definition> as <alter table action> and modify the definition
of table TA1 by adding a constraint with syntax :

 ALTER TABLE TA1 ADD CONSTRAINT TA1_prkey  PRIMARY KEY (col1);

Commit the change.

Using a <select statement: single row> with COUNT(*), access
the KEY_COLUMN_USAGE view from the Information Schema and
check that there is exactly one row where the values of the
columns CONSTRAINT_NAME, TABLE_NAME and COLUMN_NAME are equal
to TA1_prkey, TA1 and col1, respectively, and the value of
column TABLE_SCHEMA is the name of the current schema.

Using a <set function specification> with COUNT(*), access the
KEY_COLUMN_USAGE view  from the Information Schema and check
that there are no rows where the values of the columns
CONSTRAINT_NAME, TABLE_NAME and COLUMN_NAME are TA2_fkey, TA2
and c2, respectively,  and the value of column TABLE_SCHEMA is
the name of the current schema.

Terminate the transaction with commit or rollback.

Use Dynamic SQL to execute an <alter table>  statement with an
<add table constraint definition> as <alter table action> and
modify the definition of table TA2 by adding a constraint with
syntax :

ALTER TABLE TA2 ADD CONSTRAINT TA2_fkey FOREIGN KEY (c2)
REFERENCES TA1 (col2);

Commit the change.

Using a <set function specification> with COUNT(*), access the
KEY_COLUMN_USAGE view from the Information Schema and check
that there is exactly one row where the values of the columns
CONSTRAINT_NAME, TABLE_NAME and COLUMN_NAME are TA2_fkey, TA2
and c2, respectively,  and the value of column TABLE_SCHEMA is
the name of the current schema.

Terminate the transaction using COMMIT or ROLLBACK.

Use an <alter table>  statement with an <add table constraint
definition> as <alter table action> and modify the definition
of table TA1 by adding a constraint with syntax :

ALTER TABLE TA1
 ADD CONSTRAINT col3_check CHECK(col3 IN
('ATHENS','CORFU','PYLOS')));

Commit the change.

Insert one row in table TA1 attempting to insert a value in
column col3 which violates the <check constraint>.
Check that the value returned in SQLSTATE indicates the
exception condition integrity constraint violation ('23000').

Except where a check for some other value is specified, after
every execution of an SQL statement check that the value
returned in SQLSTATE indicates successful completion.

If any check fails, record a verdict of 'fail', otherwise
record a verdict of 'pass,'.

Drop the tables TA1 and TA2 with CASCADE <drop behaviour>.

All the names used are for ease of description only, and are
not intended to constrain the choice of names in the test
program or in the database.

(New 28 June 1995)


CTS5 SQL2 Test Purpose 060: Feature #38

IDENTIFICATION
     TEST7053, XTS753

DESCRIPTION
     ALTER TABLE ADD COLUMN with data type

REFERENCES
     11.10  --  <alter table statement>
     11.10 AR.1
     11.11  --  <add column definition>
     11.1 GR.1
     11.1 LR.2a  --  Raised. Entry SQL restriction which
prohibited the use of an <add column definition>.
     F#38  --  Schema manipulation.
     F#2  --  Basic Information Schema
     F#6  --  VARCHAR data type

TEST PURPOSE
To determine that when an <alter table statement> with an <add
column definition> as <alter table action> is executed then
the target table's definition is changed and the new <column
definition> is added to the table.

NOGO:
     None.

TEST SPECIFICATION
In the current schema, create a table TA1 with three columns,
two of character string data types and one of a numeric data
type.

Commit the creation of the table.

Using a <select statement: single row>, access the COLUMNS
view from the Information Schema and check that there are no
rows with values in the columns TABLE_NAME and COLUMN_NAME of
'TA1' and 'COLNUM2', respectively, and the name of the current
schema in the column TABLE_SCHEMA.

Terminate the transaction.

Use an <alter table statement> with an <add column definition>
and add one column of numeric data type to TA1 with syntax:

 EXEC SQL ALTER TABLE TA1 ADD COLUMN COLNUM2 NUMERIC(7);

Commit the alteration of the table.

Using a <select statement: single row>, access the COLUMNS
view from the Information Schema and check that there is
exactly one row with values in the columns TABLE_NAME and
COLUMN_NAME of 'TA1' and 'COLNUM2', respectively, and the name
of the current schema in the column TABLE_SCHEMA.

Using a <select statement: single row>, access the COLUMNS
view from the Information Schema and check that there are no
rows with values in the columns TABLE_NAME and COLUMN_NAME of
'TA1' and 'COLSTR3', respectively, and the name of the current
schema in the column TABLE_SCHEMA.

Terminate the transaction.

Use an alter table statement and add one column of character
string data type to table TA1 with syntax:

EXEC SQL ALTER TABLE TA1 ADD COLUMN COLSTR3 VARCHAR(7);

Commit the alteration of the table.
Using a <select statement: single row>, access the COLUMNS
view from the Information Schema and check that there is
exactly one row with values in the columns TABLE_NAME and
COLUMN_NAME of 'TA1' and 'COLSTR3', respectively, and the name
of the current schema in the column TABLE_SCHEMA.

Insert two rows into table TA1, assigning values to the
columns COLSTR3 and COLNUM2.

Commit the table insertion and retrieve with an ordered cursor
the rows of table TA1. Check that the added columns are
present and contain the expected values.

Terminate the transaction.

After each execution of an SQL statement, except where a check
for some other value is specified, check that the value
returned in SQLSTATE indicates successful completion.

If any check fails, record a verdict of 'fail', otherwise
record a verdict of 'pass'.

Restore the database in its original state with a <drop table
statement> with TA1 as <table name> with CASCADE <drop
behaviour>.

All the names used are for ease of description only, and are
not intended to constrain the choice of names in the test
program or in the database.

(New 28 June 1995)


CTS5 SQL2 Test Purpose 061: Feature #38

IDENTIFICATION
     TEST7054, XTS754

DESCRIPTION
     ALTER TABLE ADD COLUMN with domain and constraint

REFERENCES
     11.10  --  <Alter table statement>
     11.10 AR.1
     11.11  --  <add column definition>
     11.11 GR.1
               11.11 LR.2a  --     Raised. Entry SQL
               restriction which prohibited the use of an <add
               column definition>.
     11.4  --  <column definition>
     F#2  --  Basic Information Schema.
     F#25  --  Domain Definition.
     F#34  --  Usage tables
     F#38  --  Schema manipulation.

TEST PURPOSE
To determine that after execution of an <alter table
statement> with an <add column definition> that specifies a
<domain name> and a <column constraint definition> as <alter
table action>, the new <column definition> has been added to
the descriptor of the target table.

NOGO:
     None.

TEST SPECIFICATION
Let NUMDOM be a domain with a data type of INTEGER and with a
check constraint that limits the domain to values greater than
1000 and less than 2000 over which the current user holds the
USAGE privilege.

In the current schema, create a table TAV  with two columns,
one of character string type, and the other of numeric type.

Commit the creation of the table.

Use a <select statement: single row> and determine by access
to the COLUMN_DOMAIN_USAGE view in the Information Schema that
there is no row where the values of the columns TABLE_NAME,
COLUMN_NAME and DOMAIN_NAME are equal to 'TAV' and 'COLDOM'
and 'NUMDOM' respectively, and the values in columns
DOMAIN_SCHEMA and TABLE_SCHEMA are, respectively, the schema
containing domain NUMDOM and the current schema.

Terminate the transaction.

Use an <alter table statement> that specifies an <add column
definition> that specifies a domain of NUMDOM an a <check
constraint definition> to add one column to table TA1 with
syntax:

 EXEC SQL ALTER TABLE TAV ADD COLUMN COLDOM NUMDOM
     CONSTRAINT coldom_check CHECK (COLDOM <=1998);

Commit the alteration of the table.

Use a <select statement: single row> and determine by access
to the COLUMN_DOMAIN_USAGE view in the Information Schema that
there exists exactly one  row where the values of the columns
TABLE_NAME, COLUMN_NAME and DOMAIN_NAME are equal to 'TAV' and
'COLDOM' and 'NUMDOM' respectively, and the values in columns
DOMAIN_SCHEMA and TABLE_SCHEMA are, respectively, the schema
containing domain NUMDOM and the current schema.

Insert one row in table TAV where the value in column COLDOM
does not violate neither the domain constraint or the check
constraint.

Attempt to insert one more row in table TAV, specifying a
value of 1999 for column COLDOM. Check that the value returned
SQLSTATE indicates that an exception was raised: integrity
constraint violation ( '23000').

After each execution of an SQL statement, except where some
other check is specified, check that the value returned in
SQLSTATE indicates successful completion.

If any check fails, record a verdict of 'fail', otherwise
record a verdict of 'pass'.

Restore the database in its original state by dropping table
TA1, using a <drop table statement> with CASCADE <drop
behaviour>.

All the names used are for ease of description only, and are
not intended to constrain the choice of names in the test
program or in the database.

(New 28 June 1995)


CTS5 SQL2 Test Purpose 062: Feature #38

IDENTIFICATION
     TEST7055, XTS755

DESCRIPTION
     ALTER TABLE DROP COLUMN RESTRICT

REFERENCES
     11.10  --  <Alter table statement>
     11.10 AR.1
     11.15  --  <Drop column definition>
     11.15 SR.4
     11.15 LR.2a  --  Raised. Entry SQL restriction which
prohibited the use of a <drop column definition>
     F#38  --  Schema manipulation
     F#2  --  Basic Information Schema
     F#16 --  PRIMARY KEY enhancement

TEST PURPOSE
To determine that when an <alter table statement> with a <drop
column definition> that specifies RESTRICT is executed, then
it will not destroy a column that has is not referenced by a
table constraint descriptor that contains references to other
column(s) contained in the same table or any other table or
view, otherwise a condition of access rule violation will be
raised.

NOGO: None.

TEST SPECIFICATION
Create two tables TAV1 and TAV2 under the current schema with
the following structure :
for TABLE TAV1
     col_1     NUMERIC(7) PRIMARY KEY,
     col_2     CHAR(10),
     ENAME CHAR(25);

for TABLE TAV2
     c1 NUMERIC(7) ,
     c1_LEKTIKO CHAR(10) ,
     FOREIGN KEY(C1) REFERENCES TAV(col_1);

Commit the creation of the tables.

Using a <select statement:single row>, access the COLUMNS view
from the Information schema, and check that there is exactly
one row where the values in the columns TABLE_NAME and
COLUMN_NAME are equal to TAV2 and c1_LEKTIKO, respectively,
and the value of the column TABLE_SCHEMA is the name of the
current schema.

Terminate the transaction.

Use an <alter table statement> that specifies <drop column
definition> as <alter table action> with RESTRICT <drop
behaviour> and drop column c1_LEKTIKO from table TAV2.

Commit the dropping of the column.

Using a <select statement:single row>, access the COLUMNS view
from the Information schema, and check that there are no rows
where the values in the columns TABLE_NAME and COLUMN_NAME are
equal to TAV2 and c1_LEKTIKO, respectively, and the value of
the column TABLE_SCHEMA is the name of the current schema.

Terminate the transaction.

Use an <alter table statement> that specifies <drop column
definition> as <alter table action> with RESTRICT <drop
behaviour> and attempt to drop from table TAV the column col_1
(which is being referenced by table TAV2). Check that the
value returned in SQLSTATE indicates that an exception has
been raised syntax error or access rule violation ('42000').

Terminate the transaction.

Except where a check for some other value is specified, after
every execution of an SQL statement check that the value
returned in SQLSTATE indicates successful completion.

If any check fails, record a verdict of 'fail', otherwise
record a verdict of 'pass'.

Restore the database in its original state by dropping the two
created tables with CASCADE <drop behaviour>.

All the names used are for ease of description only, and are
not intended to constrain the choice of names in the test
program or in the database.



CTS5 SQL2 Test Purpose 063: Feature #38

IDENTIFICATION
     TEST7056, XTS756

DESCRIPTION
     ALTER TABLE DROP COLUMN CASCADE.

REFERENCES
     11.10  --  <Alter table statement>
     11.10 AR.1
     11.15  --  <Drop column definition>
     11.15 SR.4
     11.15 GR.2
     11.15 LR.2a  --  Raised. Entry SQL restriction which
prohibited the use of a <drop column definition>
     11.37  --  <Revoke statement>
     F#2  --  Basic Information Schema.
     F#25  --  Domain Definition.
     F#38  --  Schema manipulation.

TEST PURPOSE
To determine that when an <alter table statement> that
contains a <drop column definition> with CASCADE <drop
behaviour> for a column X is executed, then it will destroy X
along with views that reference X in their <query expression>,
and if X participates in table or domain descriptors these
objects will be effectively dropped when X is dropped.

NOGO:
None.

TEST SPECIFICATION
Let CHARDOMAIN be a domain with data type of VARCHAR and a
check constraint named cons_strdom that restricts the values
of the domain to 'ATHENS', 'CORFU' and 'RHODES' over which the
current user has the USAGE privilege.

Create two tables in the current schema with the following
structure:

TABLE TA1
     756a_col1 NUMERIC(3) PRIMARY KEY,
     dname VARCHAR(15),
     loc CHARDOMAIN;

TABLE TA2
     756b_col1 NUMERIC(5) PRIMARY KEY
     ename VARCHAR(15) NOT NULL
     FOREIGN KEY (ENAME) REFERENCES TA1(loc);

Commit the creation of the tables.

Create two views in the current schema named VA1 and VA2 which
both reference column loc from table TA1 in their <query
expression>.

Commit the creation of the views.

Access the COLUMNS view from the Information Schema and check
that there is exactly one row with values in columns
TABLE_SCHEMA, TABLE_NAME and COLUMN_NAME equal to the name of
the current schema, 'TA1' and 'LOC', respectively.

Terminate the transaction.

Use an <alter table statement> with <drop column definition>
as <alter table action> with CASCADE <drop behaviour> to drop
column loc from table TA1.

Commit the dropping of the column.

Access the COLUMNS view from the Information Schema and check
that there are no rows present with values of columns
TABLE_SCHEMA, TABLE_NAME and COLUMN_NAME equal to the name of
the current schema, 'TA1' and 'LOC', respectively.

Use two <select statement: single row> statements and access
the VIEWS view from the Information Schema and check that no
rows are present where column TABLE_NAME contain the value VA1
or VA2 and column TABLE_SCHEMA contains the name of the
current schema, thus ensuring that these views were dropped
when the column loc was dropped.

Except where a check for some other value is specified, after
every execution of an SQL statement check that the value
returned in SQLSTATE indicates successful execution.

If any check failed, record a verdict of 'fail', otherwise
record a verdict of pass.

Restore the database to its original state by dropping both
tables TA1 and TA2 with CASCADE <drop behaviour>.

All the names used are for ease of description only, and are
not intended to constrain the choice of names in the test
program or in the database.

(New 28 June 1995)


CTS5 SQL2 Test Purpose 064: Feature #39

IDENTIFICATION:
     TEST7029, XTS729

DESCRIPTION:
     Column name with 19 and 128 characters - regular.

REFERENCES:
     11.4 -- <column definition>
     5.4   -- <Names and identifiers >
     5.4 GR.4
     5.4 SR.3
     5.2  -- <Token and separator>
     5.2 SR.8
     5.2 SR.10
     5.2 SR.11
               5.2 L.R.2a --  Raised. Entry SQL restriction
               which restricted the length of a <regular
               identifier> up to 18 <character
               representation>s.
     21.2.29  -- COLUMNS view.
     F#1 -- Dynamic SQL.
     F#2 -- Basic information schema.
     F#3 -- Basic schema manipulation.
     F#39 -- Long identifiers.


TEST PURPOSE.
To determine that a <column name> in a <column definition>
specified in a <table definition> can be a <regular
identifier> with length more than 18 and up to 128 characters.

 NOGO
     None.

TEST SPECIFICATION.
Ensure that no tables exist in schemas in the current catalog
which are owned by the current authorization identifier with
table names equal to the table names about to be created.

i) Create consisting of 4 columns, two with numeric <data
type>s and two with character string <data type>'s. The
<column name>s of all the columns are <regular identifier>s
with length 19 characters (raising of 5.2 L.R 2.a) and are of
the following structure:

a)   <simple Latin upper case letter>...<simple Latin upper
     case letter>

b)   <simple Latin lower case letter>...<simple Latin lower
     case letter> with different value from (i) only at the
     last character (disregarding the case of letters).

c)   <simple Latin letter>...<simple Latin
     letter><underscore><digit>

d)   As (iii) but with different <digit>

ii) Create a second table with the same structure, as in i),
and where the <column name>s are also all <regular
identifier>s with the same description as above but with
length 128 characters.

Commit the creation of the tables.

iii) Insert one row in the table that has column names of
length 19 characters. Use a <select statement: single row> on
that table to ensure that the row was inserted and it has the
anticipated content.

iv) Insert five rows in the table with has column names of
length 128. Use an ordered cursor to determine that the rows
were inserted and have the anticipated content.

v) Use a cursor and determine through access from the COLUMNS
view in the Information Schema that for each of the above
column names of length 128 it contains a row describing the
column.

vi) Use Dynamic SQL and create a table with two columns both
of character string <data type> and the first with length of
19 and the second of length 128. Insert three rows in the
table and use a cursor to determine that the rows are present
and with the anticipated content.

vii)Use an <add column definition> and add a column to the
table created in ii) above, with a <column name> of length 128
which is identical to a column name in the same table except
that the <SQL language character> in the last position is
different. Insert one row in this table and check with a
<select statement: single row> that the new column has the
anticipated content, thus ensuring that all the positions of
an identifier are significant.

After execution of each SQL statement check that the value
returned in SQLSTATE indicates successful completion.

If any of the checks failed record a verdict of 'fail'
otherwise record a verdict of 'pass'.


(15 March 1995)



CTS5 SQL2 Test Purpose 065: Feature #39

IDENTIFICATION:
     TEST7030, XTS730

DESCRIPTION:
     Table name with 19 characters - delimited.

REFERENCES:
     11.3 -- <table definition>
     5.4  --  <Names and identifiers>.
     5.4 GR.1
     5.2  --   <Token and separator>
     5.2 SR.9
     5.2 SR.13
     5.2 SR.14
               5.2 L.R.2a --  Raised. Entry SQL restriction
               which restricted the length of a <regular
               identifier> up to 18 <character
               representation>s.
     F#3 --  Basic Schema manipulation.
     F#2 --  Basic information schema.
     F#39 -- Long identifiers.


TEST PURPOSE.
To ensure that a <table name> in a <table definition> can be a
<delimited identifier> with <delimited identifier body> of
length more than 18 <delimited identifier part>s.

NOGO : None.

TEST SPECIFICATION.
Ensure that no tables exist in schemas in the current catalog
which are owned by the current authorization identifier with
table names equal to the table names about to be created.

Create five tables with 1 column of numeric <data type> each.
The <table name>s are all <delimited identifier>'s with
<delimited identifier body> of length 19 <delimited identifier
part>s (raising of 5.2 L.R 2.a).

The syntax of the five <table name>s is :
1.   <double quote><simple Latin upper case letter>...<simple
     Latin upper case letter><double quote>
2.   <double quote><simple Latin lower case letter>...<simple
     Latin lower case letter><double quote>  with the same
     characters (including the case of letters) as (1) except
     the last one.
3.   <double quote><digit><double quote symbol><simple Latin
     letter>...<simple Latin letter><underscore><digit><double
     quote>
4.   As (3) but with different <digit>
5.   <double quote> <simple Latin letter> ...<simple Latin
     letter> <percent> <space> <period> <comma> <left paren>
     <right paren> <double quote>

Commit the creation of the  tables.

Use a <select statement : single row> to find through the view
TABLES in the Information Schema the count of the rows where
the column TABLE_NAME is equal to any of the above table
names. Check that the result returned by COUNT is 5.

Use a cursor and access the TABLES view in the Information
Schema to check that for each of the five tables created above
there is a row describing the table, including its <table
name>.

After execution of each SQL statement check that the  returned
in SQLSTATE indicates successful completion.

If any of the checks failed record a verdict of 'fail'
otherwise record a verdict of 'pass'.
(15 March 1995)


CTS5 SQL2 Test Purpose 066: Feature #39

IDENTIFICATION:
     TEST7031, XTS731

DESCRIPTION:
     View name with 128 characters - delimited.

REFERENCES:
     11.19 -- <view definition>
     5.4 -- <Names and identifiers>
     5.4 GR.1
     5.2 -- <Token and separator>
     5.2 SR.9
     5.2 SR.13
     5.2 SR.14
               5.2 L.R.2a --   Raised. Entry SQL restriction
               which restricted the length of a <regular
               identifier> up to 18 <character
               representation>s.
     F#3 --  Basic schema manipulation.
     F#2 --  Basic information schema.
     F#39 -- Long identifiers.

TEST PURPOSE.
To ensure that a <table name> in a <view definition> can be a
<delimited identifier> with <delimited identifier body> of
length up to 128 <delimited identifier part>'s.

NOGO:
     None.

TEST SPECIFICATION
Create five views each one to view one table from the standard
schema. The <table name>'s of the views are all <delimited
identifier>'s with <delimited identifier body> of length 128
<delimited identifier part>. The syntax of the five <table
name>'s is :

1.   <double quote><simple Latin upper case letter>...<simple
     Latin upper case letter> <double quote>
2.   <double quote><simple Latin lower case letter>...<simple
     Latin lower case letter> <double quote>  with the same
     characters (including the case of letters) as (1) except
     the last one.
3.   <double quote> <digit> <double quote symbol> <simple
     Latin letter> ... <simple Latin letter> <underscore>
     <digit> <double quote>
4.   As (3) but with different <digit>
5     <double quote> <simple Latin letter> ...<simple Latin
     letter> <percent> <space> <period> <comma> <left paren>
     <right paren> <double quote>

 Commit the creation of the views.

Use an ordered cursor and determine through accessing the
VIEWS view in the Information Schema that five rows are
present, each describing one of the above created views along
with the anticipated names.

Use a <select statement: single row> to compare the name of a
view X of the above created ones by accessing the VIEWS view
in the Information Schema, with a literal of length 128 which
contains a value identical to the name of view X up to the
127th position but with different <SQL language character> in
the last position. Check that no equality has occurred thus
ensuring that all 128 positions of the identifier are
significant.

After execution of each SQL statement check that the value
returned in SQLSTATE indicates successful completion.

If any of the checks failed record a verdict of 'fail'
otherwise record a verdict of 'pass'.

(15 March 1995)


CTS5 SQL2 Test Purpose 067: Feature #40

IDENTIFICATION
     TEST7032, XTS732

DESCRIPTION:
     NATURAL FULL OUTER JOIN <table ref> -- static.

REFERENCES:
   7.10 -- <query expression>
   7.10 LR.2c -- Raised. Entry SQL restriction which
prohibited the use of a <joined table> within
          a <query expression>.
   6.3 -- <Table reference>.
   6.3 LR.2a -- Raised. Entry SQL restriction which prohibited
the use of a <joined table> in a
                <table reference>.
   7.5 -- <joined table>.
   7.5 SR.2a
   7.5 GR.1d
   7.5 LR.2a --Raised.  Entry SQL restriction which prohibited
the use of a <joined table> in a
                <table reference>.
    F#4  --    Joined table.
    F#11 -- Transaction isolation.
    F#40  --    Full outer join.


TEST PURPOSE.
To determine that if a <joined table> in a <query expression>
or simply contained in a <table reference> specifies NATURAL
FULL OUTER JOIN then the result is valid and equivalent to a
FULL OUTER JOIN with a <join condition> that the corresponding
join columns are equal or without <join condition> if no
corresponding join columns exist.

NOGO : none.

TEST SPECIFICATION.
Use two tables, TA and TB, with two columns each, one with
numeric <data type> and the other with character string <data
type>. Ensure that the two tables are empty and that the
numeric <data type> columns of the two tables have the same
<column name>, CC, but the character string <data type>
columns have different names from each other and from the
numeric <data type> columns..

Use a <select statement : single row> to count the rows for
each of the following <joined table>s:
     TA NATURAL FULL OUTER JOIN TB
     TA NATURAL FULL JOIN TB

Check in each case that the value returned is zero.

Insert a row of non null values into TA.
Declare a cursor, ca, as :
     DECLARE ca CURSOR
          FOR TA NATURAL FULL OUTER JOIN TB FOR READ ONLY

Use cursor ca to retrieve the rows of the above <joined
table>. Check that only one row is returned and that this row
is equal to the row of TA extended on the right with two
columns containing the null value.

Declare a cursor, cb, as :
     DECLARE cb CURSOR
          FOR TB NATURAL FULL JOIN TA FOR READ ONLY

Use cursor cb to retrieve the rows of the above <joined
table>. Check that only one row returned equal to the row of
TA extended on the left with two columns containing the null
value.
Insert two rows of non null values into TB. The first row
shall contain a numeric value equal to the numeric value
inserted into TA and the second row a numeric value not equal
to this.

Use a <select statement : single row> to count the rows for
each of the following <joined table>s:

i)   TA NATURAL FULL OUTER JOIN TB
ii)  TB NATURAL FULL JOIN TA

Check in each case that the value returned is three.

Use one more table, TC, with two columns, one with numeric
<data type> and the other with character string <data type>.
Ensure that the <columns name>s of TC are different from
<column name>s of TA. Populate the table with two rows.

Ensure that no view with <table name> vtcta exist. Create a
view, vtcta, as:
     CREATE VIEW vtcta (<view column list>)
          AS TC NATURAL FULL OUTER JOIN TA

Check that the view contains two rows equal to the rows of TC
extended on the right with two columns containing the values
of table TA row. So the result is equal to TC CROSS JOIN TA.

After execution of each SQL statement check that the value
returned in SQLSTATE indicates successful completion.

If any of the checks failed record a verdict of 'fail'
otherwise record a verdict of 'pass'.

All the names used are for ease of description only, and are
not intended to constrain the choice of names in the test
program or in the database.


(15 March 1995)


CTS5 SQL2 Test Purpose 068: Feature #40

IDENTIFICATION
     TEST7033, XTS733

DESCRIPTION:
     FULL OUTER JOIN <table ref> ON <search condition> --
static.

REFERENCES:
     7.10 -- <query expression>
               7.10 LR.2.c -- Raised. Entry SQL restriction
               which prohibited the use of a <joined  table>
               within a <query expression>.
     6.3 --    <Table reference>.
               6.3 LR.2.a --  Raised. Entry SQL restriction
               which prohibited the use of a <joined table> in
               a <table reference>.
     7.5 -- <joined table>
     7.5 GR.1.c
     7.5 GR.5.d
     7.5 GR6b
               7.5 LR.2.a --  Raised. Entry SQL restriction
               which prohibited the use of a  <joined table>
               in a <table reference>.
     F#4  --  Joined table.
     F#40  --  Full outer join.
     F#24 -- Keyword relaxations

TEST PURPOSE.
To determine that if a <joined table> in a <query expression>,
or simply contained in a <table reference>, specifies FULL
OUTER JOIN and a <join condition> then the result is valid.

NOGO
     None.

TEST SPECIFICATION.
Use two tables, T1 and T2, with two columns each, one with
numeric <data type> and <column name>s NA and NB,
respectively, and the other with character string <data type>
and <column name>s CA and CB, respectively. Populate T1 with
rows (1,'A') , (2,'B') and T2 with rows (2, 'C'), (3, 'A').

For each of the following cases use a cursor ordered on column
NA, to retrieve values from the specified <joined table>s:

(i) T1 FULL OUTER JOIN T2 ON NA = NB

(ii) T1 FULL JOIN T2 ON CA = CB

Check that the rows returned are, for case (i):
     (1,'A',NULL,NULL),
     (2,'B',2,'C'),
     (NULL,NULL,3,'A')

and for case (ii):
     (1,'A',3,'A'),
     (2,'B',NULL,NULL),
     (NULL,NULL,2,'C')

Use one more table, T3 with four columns, the first and the
third with numeric <data type> and the other with character
string <data type>. Ensure that the table T3 is empty.

Use the following <insert statement>:
     INSERT INTO T3
          T1 FULL OUTER JOIN T2 ON NA = 2

Check that the following three rows were inserted to table T3:
     (1,'A',NULL,NULL),
     (2,'B',2,'C'),
     (2,'B',3,'A')

For each of the following cases use a cursor to retrieve
values from the specified <join table>s :
(i)  (T2 FULL JOIN T1 AS CN1 ON T2.CB = CN1.CA)
      FULL JOIN T1 AS CN2
          ON T2.NB = CN2.NA

(ii) (T1 AS CN3 FULL OUTER JOIN T1 AS CN4 ON CN3.NA = CN4.NA)
     FULL OUTER JOIN
     (T2 AS CN5 FULL OUTER JOIN T2 AS CN6 ON CN5.CB = CN6.CB)
          ON SN3.NA = SN5.NB

Check that the rows returned are, for case (i):
     (2, 'C', NULL, NULL, 2, 'B'),
     (3, 'A', 1 ,'A', NULL, NULL),
     (NULL, NULL, 2, 'B', NULL, NULL),
     (NULL, NULL, NULL, NULL, 1, 'A')

and for case (ii):
     (1, 'A', 1, 'A', NULL, NULL, NULL, NULL),
     (2, 'B', 2, 'B', 2, 'C', 2, 'C'),
     (NULL, NULL, NULL, NULL, 3, 'A', 3, 'A')

After execution of each SQL statement check that the value
returned in SQLSTATE indicates successful completion.

If any of the checks failed record a verdict of 'fail'
otherwise record a verdict of 'pass'.

All the names used are for ease of description only, and are
not intended to constrain the choice of names in the test
program or in the database.


(16 March 1995)


CTS5 SQL2 Test Purpose 069: Feature #40

IDENTIFICATION
     TEST7563, YTS806

DESCRIPTION:
     NATURAL FULL OUTER JOIN <table ref> -- Dynamic

REFERENCES:
     7.5 -- <joined table>
     7.5 SR.6
     7.5 GR.1d
     7.5 GR5d
     7.5 GR6a
     17.1 -- Description of SQL item descriptor areas
     17.2 -- <allocate descriptor statement>
     17.3 -- <deallocate descriptor statement>
     17.4 -- <get descriptor statement>
     17.6 -- <prepare statement>
     17.7 -- <deallocate prepared statement>
     17.8 -- <describe statement>
     17.9 -- <using clause>
     17.12 -- <dynamic declare cursor>
     17.14 -- <dynamic open statement>
     17.15 -- <dynamic fetch statement.
     17.16 -- <dynamic close statement>
     F#4 -- Joined table.
     F#40 -- Full outer join.
     F#1 -- Dynamic SQL


TEST PURPOSE
To determine that when a <joined table> that specifies NATURAL
FULL OUTER JOIN is contained in an <SQL statement> that is
executed using Dynamic SQL, then:
a)   the <joined table> describes a table in which the columns
     are, in order, the common columns, those columns of the
     first operand which are not common columns, and those
     columns of the second operand which are not common
     columns;
b)   the content of the table is such that for every pair of
     rows in the two operand tables in which the values in
     each pair of common columns are equal, there is one row
     where the values are effectively determined by
     concatenating the two rows, deleting the common columns
     that came from one of the tables, and rearranging the
     remaining columns in the appropriate order; and for every
     row in either operand table that does not have a match in
     the other operand table, there is one row effectively
     formed by concatenating that row with null values
     corresponding to the non-common columns of the other
     table, and arranging the columns in the appropriate
     order.

NOGO: none.

TEST SPECIFICATION.
Use two tables, TA and TB. Let table TA have columns CC1, TA2,
TA3, and CC2. Let table TB have columns TB1, CC2, CC1, TB4,
TB5. Let the data types of columns TA.CC1 and TB.CC1 be the
same numeric data type, and let the data types of columns
TA.CC2 and TB.CC2 be the same character string data type.

Populate the two tables such that there are rows in table TA
with zero, one and more than one matching rows in table TB,
and vice versa. In addition, ensure that the value in column
TA2 is different in every row of TA, and that the value in
column TB5 is different in every row of TB.

In a host variable, hv, construct (or pre-define) the
character string:

     SELECT * FROM TA NATURAL FULL OUTER  JOIN (SELECT * FROM
     TB)
     ORDER BY CC1, CC2, TA2, TB5

Execute a PREPARE statement that specifies sn as <SQL
statement name> and :hv as <SQL statement variable>.

Execute an ALLOCATE DESCRIPTOR statement that specifies dn as
<descriptor name> and 7 as <occurrences>. If an exception is
raised : dynamic SQL error - invalid descriptor index, ignore
this and the next part of the test, report the error, but do
not for this reason report a 'fail' verdict.

Using a DESCRIBE statement that specifies sn as <SQL statement
name> and dn as <descriptor name> and a GET DESCRIPTOR
statement, check that the names of the columns of the table
defined by the SELECT are, in order,  CC1, CC2, TA2, TA3, TB1,
TB4, TB5, and the data types are the data types of the columns
with those names in tables TA and TB.

Execute a <dynamic declare cursor> that specifies cn as
<cursor name> and sn as <statement name>, and which specifies
neither INSENSITIVE nor SCROLL.

Open cursor cn and fetch all rows using a <dynamic fetch
statement>. Check that the correct values are returned, and
that no data is reported on attempting to fetch the row after
the last row. Note that whether null values are ordered either
before or after non-null values is implementation-dependent,
but the relative positions must always be the same for a given
implementation.

Close the cursor, deallocate the prepared statement, and
deallocate the descriptor area.

Except where some other check is specified above, check after
each execution of an SQL statement that the value returned in
SQLSTATE indicates successful execution.

If any of the checks failed record a verdict of 'fail'
otherwise record a verdict of 'pass'.

All the names used are for ease of description only, and are
not intended to constrain the choice of names in the test
program or in the database.


(3 May 1995)


CTS5 SQL2 Test Purpose 070: Feature #40

IDENTIFICATION
     TEST7567, YTS810

DESCRIPTION:
     FULL OUTER JOIN <table ref> ON <search condition> --
Dynamic

REFERENCES:
     7.5 -- <joined table>
     7.5 SR5
     7.5 GR1c
     7.5 GR5d
     7.5 GR6b
     17.1 -- Description of SQL item descriptor areas
     17.2 -- <allocate descriptor statement>
     17.3 -- <deallocate descriptor statement>
     17.4 -- <get descriptor statement>
     17.6 -- <prepare statement>
     17.7 -- <deallocate prepared statement>
     17.8 -- <describe statement>
     17.9 -- <using clause>
     17.12 -- <dynamic declare cursor>
     17.14 -- <dynamic open statement>
     17.15 -- <dynamic fetch statement.
     17.16 -- <dynamic close statement>
     F#4 -- Joined table.
     F#40 -- Full outer join.
     F#1 -- Dynamic SQL


TEST PURPOSE
To determine that when a <joined table> that specifies FULL
OUTER JOIN <table reference> ON <search condition> is
contained in an <SQL statement> that is executed using Dynamic
SQL, then:
a)   the <joined table> describes a table in which the columns
     are, in order, the columns of the first operand and the
     columns of the second operand;
b)   the content of the table is the union of:
          (i)  those rows of the Cartesian product of the two
          operand tables for which the <search condition> is
          true;
          (ii) for each row of the first operand for which
          there is no row in (i) formed by concatenating that
          row with some row from the second operand, a row
          formed by extending the row from the first operand
          to the right with a number columns equal to the
          degree of the second operand, with each of the
          extending columns containing the null value;
          (iii)     for each row of the second operand for
          which there is no row in (i) formed by concatenating
          some row from the first operand with that row, a row
          formed by extending the row from the second operand
          to the left with a number columns equal to the
          degree of the first operand, with each of the
          extending columns containing the null value;

NOGO: none.

TEST SPECIFICATION.
Use two tables, TA and TB. Let table TA have columns TA1, TA2,
TA3, and TA4. Let table TB have columns TB1, TB2, TB3, TB4,
TB5. Let the data types of columns TA.TA1 and TB.TB5 be
numeric, and let the data types of columns TA.TA2 and TB.TB3
be the same character string data type.

Populate the two tables such that there are rows in table TA
where the value is column TA1 is less than every value in
column TB5 of table TB; the value in column TA2 is the same in
every row of table TA; and there is only one row in table TB
where the value in column TB3 is not the common value of
column TA2 in table TA. Let the common character value in
column TA2 collate as less than the one different character
value in column TB3.
In a host variable, hv, construct (or pre-define) the
character string:

     SELECT TA1, COUNT (*) AS CC, TB3 FROM TA FULL JOIN TB
          WHERE TA1 > TB5 AND TB3 = TA2
               GROUP BY TA1, TB3
               ORDER BY TB3 DESC, TA1

Execute a PREPARE statement that specifies sn as <SQL
statement name> and :hv as <SQL statement variable>.

Execute an ALLOCATE DESCRIPTOR statement that specifies dn as
<descriptor name> and 3 as <occurrences>. If an exception is
raised : dynamic SQL error - invalid descriptor index, ignore
this and the next part of the test, report the error, but do
not for this reason report a 'fail' verdict.

Using a DESCRIBE statement that specifies sn as <SQL statement
name> and dn as <descriptor name> and a GET DESCRIPTOR
statement, check that the names of the columns of the table
defined by the SELECT are, in order,  TA1, CC, TB3, that the
data types of columns TA1 and TB3 are the data types of the
columns with those names in tables TA and TB, and that the
data type of column CC is exact numeric with scale 0.

Execute a <dynamic declare cursor> that specifies cn as
<cursor name> and sn as <statement name>, and which specifies
neither INSENSITIVE nor SCROLL.

Open cursor cn and fetch all rows using a <dynamic fetch
statement>. Check that the correct values are returned, and
that no data is reported on attempting to fetch the row after
the last row. Check that in the first row returned, column TA1
contains the null value.

Close the cursor, deallocate the prepared statement, and
deallocate the descriptor area.

Except where some other check is specified above, check after
each execution of an SQL statement that the value returned in
SQLSTATE indicates successful execution.

If any of the checks failed record a verdict of 'fail'
otherwise record a verdict of 'pass'.

All the names used are for ease of description only, and are
not intended to constrain the choice of names in the test
program or in the database.


(15 May 1995)


CTS5 SQL2 Test Purpose 071: Feature #41

IDENTIFICATION
     TEST7560, YTS780
DESCRIPTION
     <time zone interval> in literal

REFERENCES
     5.3 F30
     5.3 SR16
     5.3 GR8
     6.1 SR27
     6.1 GR5
     6.4 SR6 -- <column reference>
     6.4 SR7
     6.4 GR2
     6.6 GR3 -- <extract expression>
     6.14 GR4 -- <datetime value expression>
     8.3 -- <between predicate>
     F#41 -- Time zone specification
     F#5 -- DATETIME data types

TEST PURPOSE
To determine that a <time zone interval> may be specified in a
<time string> and in a <timestamp string> in a <time literal>
and that the <time literal> then represents a datetime in the
specified time zone.

NOGO:
     None.

TEST SPECIFICATION
Explicit column names are used here only for purposes of
reference within this Test Specification, and are not intended
to constrain the names that are used in implementations of
this specification.

Let the following columns have the specified data types. The
columns may be in the same or different tables, but in each
table there should be one or more columns that can be used to
identify rows containing particular time or timestamp values.
There may be further columns not described here.

     COLT:          time (without time zone)
     COLTZ:         time with time zone
     COLS:          timestamp (without time zone)
     COLSZ:         timestamp with time zone

Populate the tables containing the named columns, giving each
of those columns a series of values, each specified as an
appropriate type of <time literal> which contains a <time zone
interval>. For each column, select the literals such that when
the <time zone interval> is taken into account, the order of
UTC times is different from what the order that would be if
the <time zone interval> is ignored. Select values for <time
zone interval> which are not all integral multiples of 30
minutes. For each time and timestamp value, insert a numeric
value into the same row in another column such that the order
of these numeric values is the same as the order of the
corresponding UTC times with the <time zone interval> taken
into account.

Declare cursor on the table containing COLT, ordered on
ascending UTC equivalent of the values in COLT and including
all rows of the table. Open the cursor and fetch, for all
rows, the numeric value indicating the UTC order of the rows,
and the UTC hour, the UTC minute, the local hour and the local
minute corresponding to the value in COLT. Check that the rows
are returned in the correct order and with the correct values
in the UTC hour and UTC minute columns. Check that the
displacement from UTC time to local time is the same for each
row. Take account of the possibility that because the time
zone in which the test is executed cannot be determined in
advance, some UTC times early in the day may be returned as
local times late in the day, and vice versa, so that
computations involving hours must be done modulo 24.

Declare a cursor on the table containing COLTZ, ordered on
COLTZ  descending, selecting only those rows which satisfy a
<between predicate> on  the values in COLTZ in which the range
of values is specified by two <time literal>s, each of which
contains a <time zone interval>, specifying, respectively, the
values '-08:23' and '+04:37'. Open the cursor and fetch, for
all rows, the numeric value indicating the UTC order of the
rows, and the UTC hour, the UTC minute, the local hour and the
local minute corresponding to the value in COLTZ. Check that
the rows are returned in the correct order and with the
correct values in the UTC hour and UTC minute. Check that the
displacement from UTC time to local time is the same for each
row. Take account of the possibility that because the time
zone in which the test is executed cannot be determined in
advance, some UTC times early in the day may be returned as
local times late in the day, and vice versa so that
computations involving hours must be done modulo 24.

Using a <select statement: single row>, retrieve a row from
the table containing COLS, selecting the row by the value of
the numeric key. Retrieve from the row the numeric key, and
the local hour and local minute of the value in COLS. Use the
value of the default time zone displacement that can be
deduced from the checks on COLT to check that the correct
values are returned from COLS.

Using the value of the default time zone displacement that can
be deduced from the checks on COLT, use a <select statement:
single row> to retrieve the key value from a row of the table
containing COLSZ, selecting the row by the value in column
COLSZ using a <between predicate> that will be satisfied for
only one row. Specify the range for the <between predicate> by
means of two <timestamp literal>s each specifying a <time zone
interval>. Check that exactly one row is selected, and that
the expected key value is returned.

After execution of each SQL statement for which a more
specific check is not specified, check that the value returned
in SQLSTATE indicates successful completion.

If any check was not satisfied, record a verdict of 'fail',
otherwise record a verdict of 'pass'.

PROGRAMMING SPECIFICATION

Use an <extract expression> to retrieve the hour and minute
components of datetime values.

The following <cursor specification> will satisfy the
requirements of the test specified for COLT:

     SELECT    numx, colthu, coltmu
               EXTRACT (HOUR FROM COLT ) AS colthl,
               EXTRACT (MINUTE FROM COLT) AS coltml,
        FROM (SELECT num AS numx,
          EXTRACT (HOUR FROM
                COLT AT TIME ZONE INTERVAL '00:00' HOUR TO
MINUTE) AS colthu,
          EXTRACT (MINUTE FROM
                COLT AT TIME ZONE INTERVAL '00:00' HOUR TO
MINUTE) AS coltmu,
               COLT
                        FROM tab)
        ORDER BY colthu, coltmu


(Revised 6 April 1995)
(Revised 15 May 1995)


CTS5 SQL2 Test Purpose 072: Feature #41

IDENTIFICATION
     TEST7536, YTS781

DESCRIPTION
     Set local time zone - valid value

REFERENCES
     16.5 GR1a -- <set local time zone statement>, LOCAL
     16.5 GR1b -- <set local time zone statement>, <interval
     value expression>
     6.6 GR3 -- <extract expression>
     6.15 F -- <interval value expression>
     F#41 -- Time zone specification
     F#5 -- DATETIME data types

TEST PURPOSE
To determine that the default local time zone may be changed
by execution of the <set local time zone statement> to the
default value for the current session or to a specified value.

NOGO:
     None.

TEST SPECIFICATION
Explicit column names and table names are used here only for
purposes of reference within this Test Specification, and are
not intended to constrain the names that are used in
implementations of this specification.

Since there are no mappings between datetime data types and
host language data types, <extract expression> should be used
for access to the component values of datetime data types.

Let TT be a table with columns including PK, TTV and TSV, with
data types integer, time, and timestamp, respectively. Let PK
be the primary key for TT.

Using a <set local time zone statement> that specifies an
interval of zero hours and zero minutes, set the default local
time zone displacement to zero with respect to UTC. Populate
TT with a number of rows, including rows in which the values
in TTV and TSV represent times and timestamps of noon and
within two hours of each end of the day.

Execute a <set local time zone statement> that specifies
LOCAL.

Retrieve values from a row of TT that contains noon, UTC, in
column TTV, including the hour and minute components of the
value in column TTV. Determine, using these values, the local
time zone displacement from UTC.

Using a cursor, retrieve appropriate values all rows from TT,
and check for each row that the values returned from columns
TTV and TSV are offset by the local time zone displacement
from UTC from the values that were originally stored, allowing
for times and timestamps near one end of the day being moved
to near the other end of the next or previous day.

Execute a <set local time zone statement> that specifies,
using an <interval value expression> that is not a literal, a
time zone value that is neither zero nor the value associated
with LOCAL, and not an integral multiple of 30 minutes. Using
a cursor, retrieve appropriate values from all rows from TT,
and check for each row that the values from columns TTV and
TSV are offset by the specified time zone displacement from
UTC from the values that were originally stored, allowing for
times and timestamps near one end of the day being moved to
near the other end of the next or previous day.

Execute a <set local time zone statement> that specifies a
time zone value that is not the value associated with LOCAL
and is in the range (-'12:59', -'12:01'). Retrieve a count of
the number of rows in which the value in TTV is now within
some specified range, allowing for times near one end of the
day being moved to near the other end of the next or previous
day. Check that the value returned is that expected.

Execute a <set local time zone statement> that specifies a
time zone value that is not the value associated with LOCAL
and is in the range (+'12:03', +'13:00'). Retrieve a count of
the number of rows in which the value in TTV is now within
some specified range, allowing for times near one end of the
day being moved to near the other end of the next or previous
day. Check that the value returned is that expected.

After each execution of an SQL statement, check that the value
returned in SQLSTATE indicates successful completion.

If any check was not satisfied, record a verdict of 'fail',
otherwise record a verdict of 'pass'.

PROGRAMMING SPECIFICATION


(Revised 6 April 1995)


CTS5 SQL2 Test Purpose 073: Feature #41

IDENTIFICATION
     TEST7561, YTS782

DESCRIPTION
     Set local time zone - invalid value, exception

REFERENCES
     16.5 GR1b -- <set local time zone statement>, <interval
     value expression>
     6.10 GR5e -- <cast specification>
     6.15 F -- <interval value expression>
     F#41 -- Time zone specification
     F#5 -- DATETIME data types
     f~20 -- CAST functions

TEST PURPOSE
To determine that an attempt to set the default  local time
zone to a value outside the range [-12:59,+13:00] or to the
null value causes an exception condition to be raised: data
exception - invalid time zone displacement.

NOGO:
     None.

TEST SPECIFICATION
Explicit column names and table names are used here only for
purposes of reference within this Test Specification, and are
not intended to constrain the names that are used in
implementations of this specification.

Let TT be a table with columns including PK and TTV, with data
types integer and time, respectively. Let PK be the primary
key for TT.

Using a <set local time zone statement> that specifies an
interval of zero hours and zero minutes, set the default local
time zone displacement to zero with respect to UTC. Populate
TT with a number of rows.

Execute a <set local time zone statement> that specifies,
using an <interval value expression> that is not a literal, a
time zone value of +'13:01'. Check that the value returned in
SQLSTATE indicates that an exception condition has been
raised: data exception -- invalid time zone displacement
value.  Using a <select statement: single row>, retrieve from
TT a row containing a known value in column TTV, casting that
value to fixed length character string, and check that the
value returned is the expected value.

Execute a <set local time zone statement> that specifies,
using an <interval value expression> that is not a literal, a
time zone value of -'13:00'. Check that the value returned in
SQLSTATE indicates that an exception condition has been
raised: data exception -- invalid time zone displacement
value.  Using a <select statement: single row>, retrieve from
TT a row containing a known value in column TTV, casting that
value to fixed length character string, and check that the
value returned is the expected value.

Execute a <set local time zone statement> that specifies,
using an <interval value expression> that evaluates as the
null value. Check that the value returned in SQLSTATE
indicates that an exception condition has been raised: data
exception -- invalid time zone displacement value.  Using a
<select statement: single row>, retrieve from TT a row
containing a known value in column TTV, casting that value to
fixed length character string, and check that the value
returned is the expected value.

Check after each execution of an SQL statement that, except in
those cases where some other condition is specified, the value
returned in SQLSTATE indicates successful completion.

If any check was not satisfied, record a verdict of 'fail',
otherwise record a verdict of 'pass'.


(Revised 7 April 1995)



CTS5 SQL2 Test Purpose 074: Feature #41

IDENTIFICATION
     TEST7564, YTS807

DESCRIPTION
     TIMEZONE_HOUR and TIMEZONE_MINUTE in <extract expression>

REFERENCES
     6.6 SR6b -- <numeric value function>
     6.6 SR4
     6.6 GR3)a)ii
     6.10 GR10 -- <cast specification>
     F#41 -- Time zone specification
     F#5 -- DATETIME data types
     F#20 -- CAST functions

TEST PURPOSE
To determine that when TIMEZONE_HOUR or TIMEZONE_MINUTE is
specified as <extract field> in an <extract expression>, the
value returned is hour or minute, respectively, of the time
zone of the <extract source>.

NOGO:
     None.

TEST SPECIFICATION
Explicit column names and table names are used here only for
purposes of reference within this Test Specification, and are
not intended to constrain the names that are used in
implementations of this specification.

Let TT be a table with columns including PK, TTV, TTZ, and
TTSZ, with data types integer, time, time with time zone and
timestamp with time zone, respectively. Let PK be the primary
key for TT.

Populate table TT with several rows, including at least one
row where the time-zone hour, tzh,  of the value in column TTZ
is different from the time-zone hour of the value in column
TTZ in all other rows, and at least two rows where the time-
zone minute, tzm,  of the value in column TTSZ is the same and
different from the time-zone minute of the value in column
TTSZ in all other rows.

Use a <select statement: single row> that specifies
          EXTRACT (TIMEZONE_HOUR FROM TTZ) = tzh
     to retrieve the primary key value (from column PK) and
both the time zone hour and time zone minute from the other
three columns. Note that it will be necessary to use a CAST to
generate time zone fields for column TTV. A possible <select
list> is:

     PK, EXTRACT (TIMEZONE_ HOUR FROM CAST (TTV AS TIME WITH
TIME ZONE)),
          EXTRACT ( TIMEZONE_MINUTE FROM CAST (TTV AS TIME
WITH TIME ZONE)),
          EXTRACT (TIMEZONE_ HOUR FROM TTZ),
          EXTRACT ( TIMEZONE_MINUTE FROM TTZ),
          EXTRACT ( TIMEZONE_HOUR FROM TTSZ),
          EXTRACT (TIMEZONE_ MINUTE FROM TTSZ)

Check that exactly one row is returned, and that the values
from columns PK, TTZ and TTSZ are as expected. check that the
values returned from column TTV are in the range -12 to +13
hours and 0 to 59 minutes. These two values together give the
current session time zone displacement.

Execute a <select statement: single row> that specifies:

     SELECT COUNT (*) INTO :hv
          FROM (SELECT EXTRACT ( TIMEZONE_ MINUTE FROM TTSZ)
AS AA
                    FROM TT
                         GROUP BY AA)

Check that the value returned into host variable hv is the
number of distinct values time zone displacement minute in
column TTSZ.

Insert a row into table TT where the source values for columns
TTZ and TTSZ do not specify time zone displacements. Retrieve
the time zone hour and minute values for columns TTZ and TTSZ
in that row, and check that they are equal to the default time
zone displacement values for the session.

Except where a check for some other status value is specified,
check after execution of each SQL statement that the status
values returned indicate successful completion.

If any check has failed, record a verdict of 'fail', otherwise
record a verdict of 'pass'.

(New, 1 June 1995)
(Corrected, 5 June 1995)
(Further corrections, 13 June 1995)


CTS5 SQL2 Test Purpose 075: Feature #41

IDENTIFICATION
     TEST7565, YTS808

DESCRIPTION
     LOCAL time zone in <datetime value expression>

REFERENCES
     6.14 GR4a  --  <datetime value expression>
     6.1 GR5  --  <data type>, WITH TIME ZONE
     F#41 -- Time zone specification
     F#5 -- DATETIME data types

TEST PURPOSE
To determine that when a <timezone specifier> of LOCAL is
specified in a <datetime value expression>, the result of the
<datetime value expression> is adjusted to the current time
zone of the SQL session.

NOGO:
     None.

TEST SPECIFICATION
Explicit column names and table names are used here only for
purposes of reference within this Test Specification, and are
not intended to constrain the names that are used in
implementations of this specification.

Let TT be a table with columns including PK, TTV, TTZ, and
TTSZ, with data types integer, time, time with time zone and
timestamp with time zone, respectively. Let PK be the primary
key for TT.

Populate table TT with several rows, such that columns TTZ and
TTSZ each contain a variety of  values, not all of which need
be distinct.

Use a <select statement: single row> that specifies COUNT (*)
as its <select list> and
          TTZ AT LOCAL > some time literal
in its <search condition> to find the number of rows in the
table that satisfy that <comparison predicate>. Use another
<select statement: single row> to find the number of rows that
satisfy the complementary condition
          an equivalent time literal NOT < TTZ AT LOCAL
The two literals should not be identical, but should specify
the same UTC time using times in different time zones.

Check that the sum of the two counts is the number of rows in
the table.

Make equivalent checks using column TTSZ.


Except where a check for some other status value is specified,
check after execution of each SQL statement that the status
values returned indicate successful completion.

If any check has failed, record a verdict of 'fail', otherwise
record a verdict of 'pass'.

(New, 2 June 1995)
(Corrected, 5 June 1995)
(References corrected, 13 June 1995)


CTS5 SQL2 Test Purpose 076: Feature #41

IDENTIFICATION
     TEST7566, YTS809

DESCRIPTION
     TIME ZONE in <time zone specifier> in <datetime value
     expression>

REFERENCES
     6.14 GR4b  --  <datetime value expression>
     F#41 -- Time zone specification
     F#5 -- DATETIME data types

TEST PURPOSE
To determine that when a <time zone specifier> that specifies
TIME ZONE is specified in a <datetime value expression>, the
result of the <datetime value expression> is adjusted to the
time zone specified by the <interval value expression>
contained in the <time zone specifier>.

NOGO:
     None.

TEST SPECIFICATION
Explicit column names and table names are used here only for
purposes of reference within this Test Specification, and are
not intended to constrain the names that are used in
implementations of this specification.

Let TT be a table with columns including PK, TTV, TTZ, and
TTSZ, with data types integer, time, time with time zone and
timestamp with time zone, respectively. Let PK be the primary
key for TT.

Populate table TT with several rows, such that columns TTZ and
TTSZ each contain a variety of  values, not all of which need
be distinct.

Use a <select statement: single row> that specifies COUNT (*)
as its <select list> and

          TTZ AT TIME ZONE  some-interval-value-expression <
some-time-literal

in its <search condition> to find the number of rows in the
table that satisfy that <comparison predicate>. Use another
<select statement: single row> to find the number of rows that
satisfy the complementary condition

          an-equivalent-time-literal NOT > TTZ AT TIME ZONE an-
equivalent-interval-value-expression

The two literals should not be identical, but should specify
the same UTC time using times in different time zones, and
similarly the two <interval value expression>s should not be
identical but should specify the same time zone displacement.

Construct one of the <interval value expression>s by taking
the difference of two known times from the table, and
construct the other by taking the difference of another pair
of times and adding or subtracting a constant to produce the
same value as in the first case.

Check that the sum of the two counts is the number of rows in
the table.

Make equivalent checks using column TTSZ.


Declare a cursor on table TT that specifies in its <query
specification> a <date time value expression> that specifies a
<time zone specifier> of  TIME ZONE <interval value
expression>. Let the <interval value expression> be derived
from the difference of two values from column TTV of table TT,
and be outside the range -'12.59' to +'13.00'.

Open the cursor. Check that the value returned in SQLSTATE
indicates either successful completion or an exception
condition :data exception - invalid time zone displacement
value.

If the opening of the cursor was successful, fetch one row.
Check that the FETCH is unsuccessful, with the  exception
condition :data exception - invalid time zone displacement
value.

Except where a check for some other status value is specified,
check after execution of each SQL statement that the status
values returned indicate successful completion.

If any check has failed, record a verdict of 'fail', otherwise
record a verdict of 'pass'.

(New, 12 June 1995)


CTS5 SQL2 Test Purpose 077: Feature #42

IDENTIFICATION
     TEST7034, XTS734

DESCRIPTION
       National Character data type in comparison predicate

REFERENCES
   8.2 -- <comparison predicate>
   7.1 -- <row value constructor>
   6.1 -- <data type>
   6.1 SR.2
   6.1 LR.2c   --     Raised.   Entry  SQL  restriction   that
            prohibited   the  specification  of  a   <national
            character string type> in a <data type>.
   F#42 --  National character.

TEST PURPOSE
To  determine  that  the <data type> of  <value  expression>'s
contained   in  a  <comparison  predicate>  can  be  <national
character string type>.

NOGO
     None.

TEST SPECIFICATION
All  the  specific  table  and column  names  used  below  are
specified  for ease of description only, and are not  intended
to constrain the choice of names in the test program or in the
database.

Use  one  table, NTA in the standard schema, with two columns,
C1  and  C2, declared with <data type>s NCHAR(10)  and   NCHAR
VARYING(12),  respectively. The table will be  populated  with
four rows. Within each column, all values are different. There
is  exactly one value that occurs in both columns in the  same
row,  and  otherwise no value occurs in both columns.  In  one
row, C1 contains the null value, and otherwise all values  are
non-null.

Use a <select statement : single row> that specifies COUNT (*)
in  its <select list> to retrieve the number of rows where the
values  in C1 and C2 are equal. Check that the value  returned
is 1.

Let  L1 be a National Character literal that specifies a value
that  occurs  in column C1. Use a <select statement  :  single
row> that specifies COUNT (*) in its <select list> to retrieve
the  number  of  rows  in  table NTA where  the  value  in  C1
satisfies the comparison predicate:
          NOT C1 = L1
 Check that the value returned is 3.

Let  L2 be a National Character literal that specifies a value
that  occurs  in column C2. Use a <select statement  :  single
row>  that  specifies  COUNT (C2)  in  its  <select  list>  to
retrieve the number of rows in table NTA where the value in C2
satisfies the comparison predicate:
          C2 = L2
 Check that the value returned is 1.

Let  L3 be a National Character literal that specifies a value
that  occurs  in column C1. Use a <select statement  :  single
row> that specifies COUNT (*) in its <select list> to retrieve
the  number  of  rows  in  table NTA where  the  value  in  C1
satisfies the comparison predicate:
          NOT C1 <> L3
Check that the value returned is 2.

Let  L4 be a National Character literal that specifies a value
that  occurs  in column C1. Use a <select statement  :  single
row>  that  specifies  COUNT (C1)  in  its  <select  list>  to
retrieve the number of rows in table NTA where the value in C1
satisfies the comparison predicate:
          C1 <> L4
Check that the value returned is 2.

Let  L5 be a National Character literal that specifies a value
that  occurs  in column C2. Use a <select statement  :  single
row> that specifies COUNT (*) in its <select list> to retrieve
the  number  of  rows  in  table NTA where  the  value  in  C2
satisfies the comparison predicate:
          NOT L5 <> C2
Check that the value returned is 3.

Let  L6 be a National Character literal that specifies a value
that  does  not occur in column C2. Use a <select statement  :
single row> that specifies COUNT (C2) in its <select list>  to
retrieve the number of rows in table NTA where the value in C1
satisfies the comparison predicate:
          L6 <> C2
Check that the value returned is 4.

After  execution of each SQL statement check  that  the  value
returned in SQLSTATE indicates successful completion.

If  any  of  the  checks failed record a  verdict  of  'fail,'
otherwise record a verdict of 'pass'.

N.B.  It is assumed that when NATIONAL CHARACTER is used  that
the  underlying  implementation will invoke an  implementation
defined character set and a collation for it and this  is  the
case  why the above specifications are restricted to test only
equality or non - equality.


(Modified 5 July 1995)


CTS5 SQL2 Test Purpose 078: Feature #42

IDENTIFICATION
     TEST7035, XTS735

DESCRIPTION
       INSERT National Character literal in NCHAR column

REFERENCES
   13.8 -- <insert statement>
   5.3  --  <Literal>
   5.3 LR.2a   --     Raised.  Entry  SQL  restriction   which
            prohibited the use of a <national character string
            literal> in a <general literal>.
   6.1 --  <Data type>
   6.1 SR.2
   6.1 LR.2c  --   Raised. Raised. Entry SQL restriction  that
            prohibited   the  specification  of  a   <national
            character string type> in a <data type>.
   F#3  --  Basic Schema manipulation.
   F#42 -- National Character.

TEST PURPOSE
To  ensure  that  <national character string literal>  can  be
inserted  into  columns  of <national character  string  type>
through the use of <insert statement>.

NOGO
     None

TEST SPECIFICATION
All  specific names used are specified for ease of description
only, and are not intended to constrain the choice of names in
the  test  program or in the database. The characters  <space>
and  !  are  used  in the National Character literals  because
<space>  is  included in all implementation-defined  character
sets   and  !  is  included  in  most  implementation  defined
character sets. The program should include a comment  to  this
effect and a statement that other characters from the National
Character set may be substituted if necessary,

Create  a  table  NTA  under the current  schema  ,  with  two
columns, the first column C1 will be of numeric data type  and
the  second C2 will be of data type NCHAR(12). The  column  C1
will  contain  unique values and will be used to identify  the
rows of the table.

Commit the creation of the table.

Use  an  <insert statement> to insert to table NTA three  rows
with the following contents :

1)   1, N' '
2)   2, N' !'
3)   3, N'   !'

Commit the table and rows insertion.

Using  an  ordered cursor with C1 as <sort key>, compare  each
row against the values that were inserted into it in order  to
ensure  that the <insert statement>s were successful and  that
every column has the expected content stored.

Terminate the transaction.

After  execution of each SQL statement check  that  the  value
returned in SQLSTATE indicates successful completion.

Restore  the  database in its original state  by  executing  a
<drop  table statement> with NTA as <table name> with  CASCADE
<drop behavior> and commit the action.
If  any  of  the  checks failed record  a  verdict  of  'fail'
otherwise record a verdict of 'pass'.

N.B.  It  is assumed that when NATIONAL CHARACTER is used  the
underlying   implementation  will  invoke  an   implementation
defined character set and a collation for it and this  is  the
case  why the above specifications are restricted to test only
equality or non - equality .

(Modified 5 July 1995)


CTS5 SQL2 Test Purpose 079: Feature #42

IDENTIFICATION
     TEST7036, XTS736

DESCRIPTION
       Update  NCHAR  VARYING  column with  value  from  NCHAR
       domain

REFERENCES
   11.21 -- <domain definition>
   11.5 -- <default clause>
   6.1  --  <data type>
   6.1 SR.2
   6.1 SR.9b
   6.1 LR.2c   --    Raised.   Entry  SQL  restriction   which
            prohibited  the use of <national character  string
            type> in a <data type>
   5.3   --  <Literal>
   5.3 LR.2a   --    Raised.   Entry  SQL  restriction   which
            prohibited the use of a <national character string
            literal> in a <general literal>
   11.3 -- <table definition>
   11.4 -- <column definition>
   11.4 LR.2c   --   Raised.   Entry  SQL  restriction   which
            prohibited the use of a <domain name> in a <column
            definition>
   13.10 -- <update statement : searched>
   F#42 --  National character
   F#3  --   Basic schema manipulation
   F#6  --   VARCHAR data type
   F#25 --  Domain definition
   F#22 --  Explicit defaults

TEST PURPOSE
To  determine that a <domain definition> can specify  a  <data
type>  of  <national character string type> and  the  optional
element  <default clause>, and that when a <column definition>
in  a  <table  definition> specifies  a  <domain  name>  which
references such a domain, the default value for this column is
the  value  specified  in  <default  clause>  of  the  <domain
definition>.

NOGO
     None

TEST SPECIFICATION
All  specific names are used for ease of description only, and
are  not intended to constrain the choice of names in the test
program or in the database.

The  specific National Character strings specified  below  are
used  for ease of description only. For execution of the  test
program   they   may   be  replaced  by   strings   from   the
NationalCharacter set.

Ensure   that   the   Schema  associated  with   the   current
authorisation   identifier  does  not   contain   any   domain
descriptor  for  a  domain with the same domain  name  as  the
domain  names that is to be created or a table descriptor  for
the table that is to be created.

Create three domains , DOMAIN1, DOMAIN2, and DOMAIN3 as :
1)     CREATE DOMAIN DOMAIN1 AS NATIONAL CHARACTER VARYING(10)
          DEFAULT <national character string literal>
2)     CREATE DOMAIN DOMAIN2 AS NATIONAL CHAR VARYING(12)
          DEFAULT <national character string literal>
3)     CREATE DOMAIN DOMAIN3 AS NCHAR VARYING(16)
          CHECK ((VALUE  IN 'NEW YORK', 'ATHENS', 'ZANTE'));

 Commit the creation of domains.
Create a table under the current schema, NTAB, as :
     CREATE TABLE NTAB
          ( COLNUM1 DECIMAL(4) PRIMARY KEY,
            COL1 DOMAIN1,
            COL2   DOMAIN2,
            COL3   DOMAIN3 )

Commit the creation of the table.

Populate the table NTAB with two rows, with default values for
COL1,  COL2 and values of ATHENS and ZANTE, respectively,  for
COL3, and 1 and 2, respectively, for COLNUM1.

Update the second row using an <update statement : searched> :
     UPDATE NTAB
          SET COL1 = DEFAULT,
          COL2 = DEFAULT,
          COL3 = 'NEW YORK'
               WHERE COLNUM1 = 2;

Commit the update of the row.

Use  an  ordered  cursor using as <sort  key>  the  column  of
numeric data type and retrieve the two rows of NTAB, and check
both  rows  are  returned with the anticipated  contents  thus
ensuring that the update was successful.

After  execution of each SQL statement check  that  the  value
returned in SQLSTATE indicates successful completion.

Restore  the  database in its original state by  dropping  the
three domains by executing three <drop domain statement>s with
<domain name>s DOMAIN1, DOMAIN2 and DOMAIN3 respectively,  and
executing  a <drop table statement> with NTAB as <table  name>
with CASCADE <drop behavior>.

Commit the action

If  any  of  the  checks failed record  a  verdict  of  'fail'
otherwise record a verdict of 'pass'.


(Modified 5 July 1995)


CTS5 SQL2 Test Purpose 080: Feature #43

IDENTIFICATION:
     TEST7037, XTS737

DESCRIPTION:
     Scrolled cursor with ORDER BY DESC, FETCH NEXT.

REFERENCES:
     13.1 -- <declare cursor>
     13.1 GR3
     13.3 -- <fetch statement>
     13.3 GR.3
     F#43 -- Scrolled cursors
     F#24 -- Keyword relaxations

TEST PURPOSE:
To determine that when a <declare cursor> specifies SCROLL and
ORDER BY with DESC <ordering specification> without FOR UPDATE
:

          a)   when the cursor is in the open state, the order of
     rows in the table defined by the <cursor specification>
     is as defined in the <order by clause> of the <cursor
     specification>.

          b)   the first execution of  FETCH NEXT after the cursor
     is opened returns the first row, and subsequent
     executions of FETCH NEXT return the successor of the
     current row.

NOGO  : None.

TEST SPECIFICATION.
Declare two scrolled, ordered, non-updatable cursors based on
the same table that contains some columns of numeric data
types and some columns of character string data types. Ensure
that the table is populated with at least five rows.

In the first <declare cursor>, specify a column with numeric
data type as <sort key> and specify an <ordering
specification> of DESC for that column. In the second <declare
cursor>, specify a column of character string data type as
<sort key> and specify an <ordering specification> of DESC for
that column.

          a)   Open the cursor that is ordered by a character
     string data type column reference and retrieve the first
     row of the table using an implicit <fetch orientation> of
     NEXT. Retrieve the rest of the rows using an explicit
     <fetch orientation> of NEXT checking that the order of
     rows that have been fetched are as expected and according
     to the <ordering specification> (DESC) of the column that
     was designated as a <sort key>, and check that a
     completion condition no data is raised when attempting to
     retrieve the row after the last row.

          b)   Use the same approach as used in a) for the cursor
     that is ordered by a numeric data type column reference
     and checking with the same criteria as a) for successful
     execution.

After all the rows have been fetched by both cursors and the
cursors have been closed, use a third cursor to check that the
contents of the table were preserved after the use of the
ordered cursors.

After each execution of an SQL statement, except for those
where a check for some other result status is specified, check
that the value returned in SQLSTATE indicates successful
execution.

If any of the checks has failed record a verdict of 'fail',
otherwise record a verdict of 'pass'.



CTS5 SQL2 Test Purpose 081: Feature #43

IDENTIFICATION:
     TEST7038, XTS738

DESCRIPTION:
     Scrolled cursor with ORDER BY DESC, FETCH PRIOR.

REFERENCES:
     13.1 -- <declare cursor>
     13.1 GR3
     13.3 -- <fetch statement>
     13.3 GR.2c
     13.3 GR.3c
     F#24 -- Keyword relaxations.
     F#43 -- Scrolled cursors.

TEST PURPOSE:
To determine that when a <declare cursor> specifies SCROLL and
ORDER BY with DESC <ordering specification> without FOR UPDATE
:

          a)   when the cursor is in the open state, the order of
     the rows in the table defined by the <cursor
     specification> is as defined in the <order by clause> of
     the< cursor specification>.

          b)   execution FETCH PRIOR returns the predecessor of the
     current row, except when the current row is the first
     row, in which case a completion condition of no data is
     raised.

NOGO:  None.

TEST SPECIFICATION.
Declare two scrolled, ordered, non-updatable cursors based on
the same table that contains some columns of numeric data
types and some columns of character string data types. Ensure
that the table is populated with at least five rows.

In the first <declare cursor>, specify a column with numeric
data type as <sort key> and specify an <ordering
specification> of DESC for that column. In the second <declare
cursor>, specify a column of character string data type as
<sort key> and specify an <ordering specification> of DESC for
that column.

          a)   Open the cursor that will be ordered by a character
     string data type as <sort key> and retrieve the last row
     of the table using an explicit <fetch orientation> of
     FETCH LAST. Retrieve the rest of the rows of the table in
     reverse order using an explicit <fetch orientation> of
     PRIOR checking that the order of rows that have been
     fetched are as expected and according to the <ordering
     specification> (DESC) of the column that was designated
     as a <sort key>. Check that a completion condition no
     data is raised when attempting to retrieve the row before
     the first row.

          b)   Use the same test procedure as in a) for the cursor
     that is ordered by a numeric data type <sort key>, and
     check with the same criteria as a) for successful
     execution.

After all the rows have been fetched by both cursors and the
cursors have been closed, use a third cursor to check that the
contents of the table were preserved after the use of the
ordered cursors.

After each execution of an SQL statement, except for those
where a check for some other result status is specified, check
that the value returned in SQLSTATE indicates successful
execution.

If any of the checks has failed record a verdict of 'fail',
otherwise record a verdict of 'pass'.



CTS5 SQL2 Test Purpose 082: Feature #43

IDENTIFICATION:
     TEST7039, XTS739

DESCRIPTION:
     Scrolled cursor with ORDER BY int, name ASC, FETCH FIRST,
FETCH LAST.

REFERENCES:
     13.1 -- <declare cursor>
     13.1 SR10b
     13.1 GR3
     13.3 -- <fetch statement>
     13.3 GR2b
     13.3 GR2c
     F#43 -- Scrolled cursors.
     F#24 -- Keyword relaxations.

TEST PURPOSE:
To determine that when a <declare cursor> specifies SCROLL and
ORDER BY an <unsigned integer> and a <column name> as <sort
specification list>:

          -    Successive passes through the table by <fetch
     statement>s return the rows in the same order.
          -    FETCH FIRST returns the first row of the table.
          -    FETCH LAST returns the last row of the table.
          -    The rows fetched are ordered by according to the
     <sort specification list> of the cursor specification and
     in the case of the <unsigned integer> to reference the
     column which is in the specified ordinal position.

NOGO:  None.

TEST SPECIFICATION.
Declare two scrolled, ordered, non-updatable cursors based on
a the same schema table that contains some columns of numeric
data types and some columns of character string data types.
Ensure that the table is populated with at least five rows.

For the first cursor, say A, specify a <sort specification
list > of an <unsigned integer> and a <column name>, where ASC
is specified for one <sort specification> and implied for the
other, and where both referenced columns have character string
data types. For the second cursor, say B, specify a <sort
specification list> of an <unsigned integer> and a <column
name>, where ASC is specified for one <sort specification> and
implied for the other, and where both referenced columns have
numeric string data types.
          
          a)   Open cursor A and retrieve the last row of the
     table, using <fetch statement> with an explicit <fetch
     orientation> of LAST. Retrieve the rest of the rows in
     reverse order using an explicit <fetch orientation> of
     PRIOR. Check that the order of rows that have been
     fetched is as expected according to the <ordering
     specification> of the columns that were designated as a
     <sort key>, and check that a completion condition no data
     is raised when attempting to retrieve the row before the
     first row.

     Attempt to retrieve the last row of the table by using an
     explicit <fetch orientation> of FETCH LAST. Check that
     the last row of the table is retrieved. Attempt to
     retrieve the first row the table by using an explicit
     <fetch orientation> of FETCH FIRST. Start retrieving the
     rest of the rows of the table again by using a <fetch
     orientation> of NEXT checking the order of the rows that
     have been fetched are as expected and check that a
     completion condition is raised when attempting to
     retrieve the next row after the last row.

          b)   Use the same approach as in a) for cursor B, which
     is ordered by columns with numeric data type, checking
     with the same criteria as a) for successful execution.

After all the rows have been fetched by both cursors and the
cursors have been closed, use a third cursor to check that the
contents of the table were preserved after the use of the
ordered cursors.

After each execution of an SQL statement, except for those
where a check for some other result status is specified, check
that the value returned in SQLSTATE indicates successful
execution.

If any of the checks has failed record a verdict of 'fail',
otherwise record a verdict of 'pass'.



CTS5 SQL2 Test Purpose 083: Feature #43

IDENTIFICATION
     TEST7512, YTS783

DESCRIPTION
     Scr. cursor, no ORDER, FETCH all, FIRST, LAST, NEXT

REFERENCES
     13.1 -- <declare cursor>
     13.3 -- <fetch statement>
     13.3 GR3a
     13.3 GR3b
     F# 43 -- Scrolled cursors

TEST PURPOSE
To determine that when a <declare cursor> specifies SCROLL and
specifies neither ORDER BY nor FOR UPDATE, then, on any
occasion when that cursor is in the opened, the order of rows
in the table defined by the cursor specification is preserved
until the cursor is closed, and in particular that:
     - on successive passes through the table <fetch
     statement>s return the rows in the same order;
     - FETCH FIRST returns the first row of the table;
     - FETCH LAST returns the last row of the table;
     - FETCH NEXT returns the successor of the previous row
     returned, if there is such a row.

NOGO:
     None.

TEST SPECIFICATION
Declare a scrolled, unordered, non-updatable cursor based on a
single schema table such that the rows of the table specified
by the <query expression> of the <cursor specification> each
have a different value in some column. (i.e. the column is a
candidate key for the table and the rows of the table are
distinguishable.) The table should have at least five rows.

Open the cursor and retrieve all rows of the table in turn,
using FETCH with an implicit <fetch orientation> of NEXT. Note
the order of the rows. Check that all expected rows are
returned, and that a completion condition no data is raised
when attempting to retrieve the row after the last row.

Attempt to retrieve a row from the table with <fetch
orientation> LAST. Check that the last row of the table is
returned.

Attempt to retrieve a row from the table with <fetch
orientation> FIRST. Check that the first row of the table is
returned.

Fetch the remaining rows of the table using FETCH with an
explicit <fetch orientation> of NEXT. Check that the rows are
returned in the same order as before and that a completion
condition no data is raised when attempting to retrieve the
row after the last row.

Close the cursor.

If any check failed, record a fail, otherwise record a pass.

PROGRAMMING SPECIFICATION
The <query expression> should reference only one table and
should exclude some rows from that table. If possible, use a
table that has been created and populated for some other test
and which will have known content when this test is executed.
Otherwise, add an appropriate table to one of the existing
schemas and populate it, outside the test program, with
suitable rows. The <where clause> should include a reference
to a host variable.

Use a column with a numeric data type as the key column.

On the first pass through the table, record the order of the
key values in data items in the host program. Use this record
to check that rows are returned in the appropriate order by
subsequent fetches.


CTS5 SQL2 Test Purpose 084: Feature #43

IDENTIFICATION
     TEST7513, YTS784

DESCRIPTION
     Scroll cursor with joined table, FETCH ABSOLUTE literal

REFERENCES
     13.1 -- <declare cursor>
     13.3 -- <fetch statement>
     13.3 -- GR3a
     7.5 -- <joined table>
     F#43 -- Scrolled Cursor
     F#4 -- Joined Table

TEST PURPOSE
To determine that when a <declare cursor> specifies SCROLL and
the <query expression> of its <cursor specification> specifies
a <joined table>, then when that cursor is opened, the row
retrieved by a FETCH statement with orientation ABSOLUTE is
the row which corresponds to the specified line number.

NOGO
     None.

TEST SPECIFICATION
Declare a scrolled, unordered cursor based on a <joined
table>. Specify the <joined table> using an outer join, and
ensure that the contents of the tables and the specification
of the <query expression> are such that the rows of the cursor
are all distinct, and that there are more than ten and fewer
than twenty rows.

Open the cursor. Retrieve all rows of the cursor, recording
the values in three pre-determined rows, p, q and r, where
p<q<r and row r exists. Check that the value in SQLSTATE after
each operation indicates either success, or, after the last
expected row, no data.

Retrieve row p, using a <fetch statement> with an explicit
<fetch orientation> of ABSOLUTE and the target row p specified
as a literal. Check that SQLSTATE indicates success and that
row p is returned.

Retrieve row r, using a <fetch statement> with an explicit
<fetch orientation> of ABSOLUTE and the target row r success
and that row r is returned.

Retrieve row q, using a <fetch statement> with an explicit
<fetch orientation> of ABSOLUTE and the target row q specified
as a literal. Check that SQLSTATE indicates success and that
row q is returned.

Attempt to retrieve the thirtieth row using a <fetch
statement> with an explicit <fetch orientation> of ABSOLUTE
and the target row specified as a literal. Check that SQLSTATE
indicates a completion condition 'no data'.

Close the cursor.

If any check failed, record a verdict of 'fail'; otherwise
record a verdict of 'pass'.


(Editorial changes 31 January 1995)



CTS5 SQL2 Test Purpose 085; Feature #43

IDENTIFICATION
     TEST7514, YTS785

DESCRIPTION.
     Scroll cursor, FETCH RELATIVE to before deleted row

REFERENCES
     13.1 -- <declare cursor>
     13.3 -- <fetch statement>
     13.6 -- <delete statement : positioned>
     13.6 -- GR6
     F#43 -- Scrolled Cursor
     F#11 -- Transaction isolation

TEST PURPOSE
To ensure that if a row has been deleted from a scrolled
updatable cursor at a position that is before the current
position, then the deleted row is not counted in establishing
the row that is to be returned by a <fetch statement> that
specifies RELATIVE and a negative value for the relative
motion.

NOGO
None.

TEST SPECIFICATION.
Declare a scrolled, unordered, updatable cursor based on a
single table such that the rows of the table specified by the
<query expression> of the <cursor expression> each have a
different value in some column. The table must have at least
five rows.

Open the cursor. Check that the value returned in SQLSTATE
indicates that the cursor has been opened. Fetch the first
five rows of the table, recording the identifiers of those
rows. Check that the value returned in SQLCODE indicates
success in each case.

Position the cursor on the third row. Delete the third row
using <delete statement : positioned>. Check that the value
returned in SQLCODE indicates success.

Fetch a row with a <fetch orientation> of NEXT. Check that the
value returned in SQLCODE indicates success. Check that the
row returned is the fourth row in the original cursor.

Fetch a row with a <fetch orientation> of RELATIVE -1. Check
that the value returned in SQLCODE indicates success. Check
that the row returned is the second row in the original
cursor.

Close the cursor. Check that the value returned in SQLCODE
indicates success.

If any check failed, record a verdict of 'fail', otherwise
record a verdict of 'pass'.



CTS5 SQL2 Test Purpose 086: Feature #43

IDENTIFICATION
     TEST7515, YTS786

DESCRIPTION
     Scr Cursor ORDER BY mixed, FETCH ABS after deleted row

REFERENCES
     13.1 -- <declare cursor>
     13.3 -- <fetch statement>
     13.6 -- <delete statement: positioned>
     F#43 -- Scrolled Cursor.

TEST PURPOSE
To determine that when a scrolled ordered cursor with ordering
on a mixture of ascending and descending keys is opened, then
the rows in the table are in the specified order, and when a
row is deleted the order is maintained and the deleted row is
not counted in establishing the row that is to be returned by
a <fetch statement> that specifies ABSOLUTE and a position
after the row that was deleted.

NOGO
     None.

TEST SPECIFICATION
Populate a table, A, that has at least two columns, P and Q,
with at least 15 rows such that the rows can be distinguished
by the values in those columns P and Q.

Declare a scrolled, updatable cursor on A, ordered it on
column Q ASCENDING followed by column P DESCENDING.

Open the cursor and check that the rows in the table are in
the anticipated order by retrieving all the rows using <fetch
statement>s with a <fetch orientation> of NEXT. Check that the
value in SQLSTATE after each operation indicates that the
operation has been successful.

Position the cursor on the tenth row by means of a <fetch
statement> that specifies a <fetch orientation> of ABSOLUTE
10. Check that the value in SQLSTATE indicates that the
statement has been successful. Check that the correct row has
been returned.

Delete the row that is the current row of the cursor from the
table on which the cursor is based by executing a <delete
statement: positioned>. Check that the value in SQLSTATE
indicates that the statement has been successful.

Retrieve the next row of the cursor by executing a <fetch
statement> that specifies a <fetch orientation> of NEXT. Check
that the value in SQLSTATE indicates that the statement has
been successful. Check that the row that was originally in
position 11 has been returned.

Position the cursor on the first row by means of a <fetch
statement> that specifies a <fetch orientation> of ABSOLUTE 1.
Check that the value in SQLSTATE indicates that the statement
has been successful. Check that the correct row has been
returned.

Execute a <fetch statement> that specifies a <fetch
orientation> of ABSOLUTE 12. Check that the value in SQLSTATE
indicates that the statement has been successful. Check that
the row that was originally in position 13 has been returned.

If check has failed, record a verdict of 'fail'; otherwise
record a verdict of 'pass'.

(Editorial changes 31 January 1995)

CTS5 SQL2 Test Purpose 087: Feature #43

IDENTIFICATION
     TEST7516, YTS787

DESCRIPTION
     Scr. Cursor, UPDATE with position before first row

REFERENCES
     13.1 -- <declare cursor>
     13.2 GR3e -- <open statement>
     13.9 -- <update statement:positioned>
     13.3 -- <fetch statement>
     F#43 -- Scrolled Cursor.

TEST PURPOSE
To determine that when a scrolled updatable cursor> is
positioned before the first row, an attempt to execute an
<update statement: positioned> is unsuccessful, and an
exception condition is raised: invalid cursor state.

NOGO
None.

TEST SPECIFICATION
Declare a scrolled, updatable cursor Ensure the there are at
least two rows in the table specified by the <query
expression> of the <cursor specification> and that one column
is of type INTEGER. Also ensure that none of the rows have
value 0 in the column of type INTEGER.

Open the Cursor. Check that the value returned in SQLSTATE
indicates success.

Attempt to execute an <update statement: positioned> that sets
the value in the INTEGER column to 0. Check that SQLSTATE
indicates the exception condition: invalid cursor state.

Retrieve the first row of the cursor be executing a <fetch
statement> with <fetch orientation> ABSOLUTE 1 and all
subsequent rows by executing t<fetch statement>s with <fetch
orientation> NEXT. In each case check that the value in
SQLSTATE indicates that the execution of the statement has
been successful, and check that the value in the INTEGER
column is not zero.

If any check has failed, record a verdict of 'fail'; otherwise
record a verdict of 'pass'.


CTS5 SQL2 Test Purpose 088: Feature #43

IDENTIFICATION
     TEST7057, XTS757

DESCRIPTION
     Scrolled cursor FETCH ABSOLUTE at position of deleted row

REFERENCES
     13.1  --  <declare cursor>
     13.3  --  <fetch statement>
     13.7  --  <delete statement: searched>
     13.6 GR.6
     F#11  --  Transaction isolation.
     F#43  --  Scrolled cursors.

TEST PURPOSE
To  determine  that  if a row has been deleted  from  scrolled
cursor,  and  this  row  is  to be  retrieved  with  a  <fetch
orientation>  of ABSOLUTE, the row returned by fetch  will  be
the successor of the deleted row.

NOGO
     None

TEST SPECIFICATION
Specific  table and column names are below used  for  ease  of
description only and are not intended to constrain the  choice
of identifiers in the test programs.

Let  TAV be a table with at least two columns, TAV1 of numeric
data  type  declared  as primary key, and  TAV2  of  character
string data type, which contains at least five rows.

Let  CR be a scrolled cursor over table TAV, ordered by column
TAV1,  that  specifies columns TAV1 and TAV2  in  its  <select
list> and which contains at least five rows.

Open  cursor  CR  and before any rows are  fetched  execute  a
<delete statement: searched> and delete the row of TAV  which,
based  on the <order by clause> of CR would be fourth  row  of
CR.

Fetch  the  fourth  row  of CR with a <fetch  orientation>  of
ABSOLUTE.  Check that the row returned is the row  that  would
have  been the fifth row prior to the deletion of the original
fourth row.

Close CR.

Execute  a  ROLLBACK statement to return the database  to  its
original state.

After  execution of every SQL statement check that  the  value
returned in SQLSTATE indicates successful completion

If  any  of the checks have failed record a verdict of 'fail',
otherwise record a verdict of 'pass'.


(Modified, 6 July 1995)


CTS5 SQL2 Test Purpose 089: Feature #43

IDENTIFICATION
     TEST7058, XTS758

DESCRIPTION
      Scrolled cursor, FETCH ABSOLUTE non-literal, after  last
row.

REFERENCES
     13.1  --  <declare cursor>
     13.3  -- <fetch statement>
     13.3 GR.5b
     F#24  --  Keyword relaxations.
     F#43  --  Scrolled cursors.

TEST PURPOSE
To  determine  that when a <declare cursor> specifies  SCROLL,
then  when that cursor is opened and attempts to retrieve  the
row after the last row of a table with a FETCH orientation  of
ABSOLUTE  without  a literal as <simple value  specification>,
then  a  completion  condition of no data is  raised  and  the
cursor remains positioned after the last row.

NOGO
       None

TEST SPECIFICATION
Specific  table and column names are below used  for  ease  of
description only and are not intended to constrain the  choice
of identifiers in the test programs.

Let TAV be a table that has at least two columns, TAV1 with  a
numeric data type and declared as primary key, and TAV2 with a
character  string data type, and which contains at least  five
rows.

Let  CR be a scrolled cursor over table TAV, ordered by column
TAV1,  that  specifies columns TAV1 and TAV2  in  its  <select
list> and which contains five rows.

Open cursor CR.

Retrieve  the  last  row  of CR with a  FETCH  orientation  of
ABSOLUTE  :X  where  X is a host variable which  contains  the
value 5. Check that the fifth row is returned.

Increment  X  by one and retrieve the next row of  the  table,
which is the row after the last row, with FETCH orientation of
ABSOLUTE  :X.  Check  that  the  value  returned  by  SQLSTATE
indicates that a completion condition of no data was raised.

To  ensure  that CR is still positioned at the row  after  the
last  row,  retrivea row with FETCH orientation of PRIOR,  and
check that the fifth row was returned.

Close CR.

Terminate   the  transaction  with  ROLLBACK,  restoring   the
database to its initial state.

Except where a check for some other values is specified, after
execution of each SQL statement check that the value  returned
in SQLSTATE indicates successful execution.

If  any  of the checks has failed record a verdict of  'fail',
otherwise record a verdict of 'pass'.

(Modified, 6 July 1995)

CTS5 SQL2 Test Purpose 090: Feature #43

IDENTIFICATION
     TEST7059, XTS759

DESCRIPTION
      Scrolled cursor on grouped view, FETCH RELATIVE,  FIRST,
ABSOLUTE

REFERENCES
     13.1  --  <declare cursor>
     13.3  --  <fetch statement>
     13.3 GR5bi
     F#3  --  Basic Schema manipulation.
     F#24  --  Keyword relaxations.
     F#43  --  Scrolled cursors.

TEST PURPOSE
To determine that when a <declare cursor> specifies SCROLL and
neither ORDER BY nor FOR UPDATE and the <query expression>  of
its  <cursor  specification> specifies a  <table  name>  of  a
grouped view , then on any occasion when that cursor is in the
opened position, the order of rows in the view defined by  the
cursor  specification is preserved until the cursor is closed,
and in particular that:

-      on   successive   passes  through   the   view   <fetch
       statement>s return the rows in the same order;
-      FETCH FIRST returns the first row of the grouped view;
-      FETCH  ABSOLUTE  returns the row of  the  grouped  view
       which corresponds to the <simple   value specification>
       of the <fetch orientation> ;
-      FETCH  RELATIVE   returns the row which corresponds  to
       the  <simple  value specification> which specifies  the
       value  of  the  relative  motion  either  positive   or
       negative.

NOGO
     None

TEST SPECIFICATION
Specific names are below used for ease of description only and
are  not intended to constrain the choice of names used in the
test programs.

Let  TA  be a table with columns including TA1, with a numeric
data  type,  and TA2, with a character string data  type,  and
possibly  other columns. Let TA contain more than  five  rows,
such  that  there are exactly five distinct values  in  column
TA2.

Let VA be the view defined by:
     CREATE VIEW VA AS
          SELECT TA2 AS VA1, SUM (TA1) AS VA2
               FROM TA
               GROUP BY VA1

Let  CR be a scrolled, unordered cursor that contains all rows
and columns of the view VA.

Open   CR  and  fetch  all  rows,  using  an  implicit  <fetch
orientation>  of  NEXT, and record the two  values  from  each
rowin host variables. Check that there are exactly five rows.

Fetch  the third row of CR by specifying a <fetch orientation>
of  ABSOLUTE  :X where X is a host variable that contains  the
value 3. Check that the row returned is the third row of CR.

Use  a  FETCH with <fetch orientation> of FIRST to retrieve  a
row of CR. Check that the row returned is the first row.

Use a FETCH with <fetch orientation> of RELATIVE specifying  a
value of zero. Check that the first row is again returned.
Use a FETCH with <fetch orientation> of RELATIVE :Y where Y is
a  host  variable which contains the value 4. Check  that  the
fifth row of CR is returned.

Execute   five   successive  FETCH  statements   with   <fetch
orientation> of RELATIVE -1. Check that for the first four the
rows  of CR are returned in reverse order, and that after  the
fifth  the  value returned in SQLSTATE indicates a  completion
condition of no data.

Except where a check for some other value is specified,  after
execution of each SQL statement check that the value  returned
in  SQLSTATE indicates successful completion.

If any of the tests has failed record a fail, otherwise record
a pass.

(Modified, 6 July 1995)




CTS5 SQL2 Test Purpose 091: Feature #44

IDENTIFICATION:
     TEST7040, XTS740

DESCRIPTION:
     COUNT (ALL <column name>) with nulls in column.

REFERENCES:
     6.5   GR.1b
     6.5   GR.2
     6.5   SR.1
     6.5   LR 2a  -- raised
     F#44 -- Intermediate set function
     F#5 -- DATETIME data types

TEST PURPOSE:
To  determine  that when the <value expression>  in  the  <set
function  specification> COUNT (ALL <value expression>)  is  a
single <column reference>, the function returns the number  of
non-null  values  in the referenced column and  that  it  also
raises a warning completion condition when any null values are
present.

NOGO
     None.

TEST SPECIFICATION:
Use  a  table, TA, with five columns. Let the <data type>s  of
two  columns be character string, let the <data type>s of  two
columns  be  numeric, and let the >data  type>  of  the  other
column be time. Ensure that the table TA is empty.

For  each column TAx of table TA, execute a <select statement:
single  row>  that specifies "COUNT ( TAx ) ...  FROM  TA"  or
"COUNT ( ALL TAx ) ...  FROM TA". Use each form at least once.
Check  in each case that the value returned is zero, and  that
the value returned in SQLSTATE indicates successful completion
without a warning.

  Populate  table TA in such a way that one of  the  character
string  columns  contains no null values, one of  the  numeric
columns contains all null values, and in the remaining columns
some values are null and some are non-null.

For  each column TAx of table TA, execute a <select statement:
single  row>  that specifies "COUNT ( TAx ) ...  FROM  TA"  or
"COUNT  ( ALL TAx ) ...  FROM TA". Use the form without  "ALL"
(which  implies "ALL") in one case, and an explicit  "ALL"  in
the  others. Check in each case that the value returned is the
number of non-null values in the column. Check that the  value
returned in SQLSTATE indicates successful completion without a
warning  for  the column without null values, and is  "01003",
indicating  warning - null value eliminated in  set  function,
for the other columns.

If  any  of the checks has failed, record a verdict of 'fail',
otherwise record a verdict of 'pass'.


CTS5 SQL2 Test Purpose 092: Feature #44

IDENTIFICATION:
     TEST7041, XTS741

DESCRIPTION:
     COUNT (ALL NULLIF ...) with generated nulls.

REFERENCES:
     6.5   FT.1 --<set function specification>
     6.9   FT.2 --<case abbreviation>
     6.9   SR.1
     F#44 -- Intermediate set function
     F#26    --  CASE expression.

TEST PURPOSE:
To  determine  that when the <value expression>  in  the  <set
function specification> COUNT ( ALL <value expression>)  is  a
NULLIF <case abbreviation>, the function returns the number of
non-null  values resulting from the application of the  NULLIF
<case  abbreviation>, and when any null values are present  it
also  raises the  completion condition: warning -  null  value
eliminated in set function.

NOGO : None.

TEST SPECIFICATION:
Use  a  table, TA, with five columns. Let the <data type>s  of
two  columns be character string, let the <data type>s of  two
columns  be  numeric, and let the >data  type>  of  the  other
column  be time. Populate table TA in such a way that  one  of
the  character string columns contains no null values, one  of
the  numeric  columns contains all null  values,  and  in  the
remaining columns some values are null and some are non-null.
(Note: The table to used for this test may be the same as that
used for test purpose 91.)

For  each  of  the  cases described below, execute  a  <select
statement: single row> that specifies

       "COUNT  (  ALL  NULLIF ( <value expression  1>,  <value
     expression 2> ) ...  FROM TA"

and  may specify other values that should not cause the return
of  any status other than successful completion. Check in each
case  that the value returned from the specified COUNT is  the
number  of  non-null values resulting from the application  of
the  NULLIF <case abbreviation>. Check that the value returned
in  SQLSTATE indicates successful completion without a warning
for  the cases where there are no values to be eliminated, and
is  "01003", indicating warning - null value eliminated in set
function, for the other cases. The cases to be checked are:

1)   <value  expression 1> and <value expression 2>  are  both
     <literal>s that are not identical but are equal according
     to  the  rules of the <comparison predicate>.  The  value
     returned  should  be  zero,  and  there  should   be   an
     indication that null values have been eliminated.

2)   <value expression 1> is a reference to the column  of  TA
     with  a character string data type that contains no  null
     value,  and <value expression 2> is a <literal>  that  is
     not equal to any of the values that occur in that column.
     The  value returned should be the number of rows  in  the
     table,  and  there should be no indication of elimination
     of null values.

3)   <value  expression 1> is a <literal>  that  is  equal  to
     exactly one of the values that occur in the column of  TA
     that contains no null value, and <value expression 2>  is
     a  reference to that column. The value returned should be
     one  less than the number of rows in the table, and there
     should  be  an  indication that  null  values  have  been
     eliminated.

4)   <value expression 1> is a reference to a column, TAA,  of
     TA  that  contains  at least one null  value  and  <value
     expression 2> is a reference to another column,  TAB,  of
     TA  that has a <data type> that is comparable to that  of
     column  TAA.  There should be one or more rows  in  which
     columns TAA and TAB contain the same non-null value.  The
     value returned should be the number of rows in which  the
     value  in  column  TAA is non-null and different  to  the
     value  in  column TAB, and there should be an  indication
     that null values have been eliminated.
5)   <value expression 1> is a reference to a column, TAA,  of
     TA  that  contains  at least one null  value  and  <value
     expression 2> is a reference to another column,  TAB,  of
     TA  that has a <data type> that is comparable to that  of
     column  TAA.  There should be one or more rows  in  which
     columns TAA and TAB contain the same non-null value.  The
     value returned should be the number of rows in which  the
     value  in  column  TAA is non-null and different  to  the
     value  in  column TAB, and there should be an  indication
     that null values have been eliminated.

6)   <value expression 1> is a reference to a column, TAC,  of
     TA  that has a numeric <data type> and contains at  least
     one  null  value, and <value expression 2> is a reference
     to  the column, TAD, of TA that has a numeric <data type>
     and  contains all null values. The value returned  should
     be the number of rows in which the value in column TAC is
     non-null,  and  there should be an indication  that  null
     values have been eliminated.

7)   <value expression 1> is a reference to the column  of  TT
     with  a  time data type, and <value expression  2>  is  a
     <literal>  that is equal to one of the values that  occur
     in  that column. The value returned should be the  number
     of  rows in the table in which the value in column TT  is
     not null and is not equal to the specified <literal>, and
     there should be an indication that null values have  been
     eliminated.

If  any  of the checks has failed, record a verdict of 'fail',
otherwise record a verdict of 'pass'.


CTS5 SQL2 Test Purpose 093: Feature #44

IDENTIFICATION:
     TEST7042, XTS742

DESCRIPTION:
     COUNT (ALL literal).

REFERENCES:
     6.5  --  <set function specification>
     6.5 GR1b
               6.5  LR.2a   --  Raised. Entry SQL  restriction
               which prohibited the use of COUNT if a <general
               set function> implied or specified ALL.
     5.3  --  <literal>
     F#44  --  Intermediate set function

TEST PURPOSE:
To  determine  that when the <value expression>  in  the  <set
function  specification> COUNT (ALL <value expression>)  is  a
literal  and  thus does not include a reference to  the  table
that  is  the argument of the set function, the value returned
is the number of rows in that table.

NOGO
     None

TEST SPECIFICATION:
Use a table with four columns, with <data type>s respectively:
CHAR,  NUMERIC, DEC, REAL. Populate the table with  six  rows,
none of which contains any null values.

Execute a <select statement: single row> that references  that
table and specifies as its <select list> three instances of
     COUNT (ALL <literal>)
and one instance of
     COUNT (*).
The  types  of  the  literals should include character,  exact
numeric and approximate numeric, and the order of the elements
in  the  <select list> should be such that no literal has  the
same  position  in  the list as a column of the  corresponding
data type has among the columns of the table.

Check that the same value (6) is returned for each item in the
<select list>.

Insert  two  rows  into the table such  that  one  column  now
contains one null value, one column contains two null  values,
and all other entries in the table are non-null.

Execute  a <select statement: single row> that references  the
table and specifies as its <select list>:
     COUNT    (ALL   <literal>),   COUNT(*),   COUNT   (cola),
     COUNT(colb).
The  <literal>  may be of any type, and cola and  colb  should
reference  the  columns that contain one null and  two  nulls,
respectively.

Check that the values returned are, respectively, 8, 8, 7  and
6.

Insert a row that contains all null values into the table  and
execute  a <select statement: single row> that references  the
table  and  apart from the literal value is the  same  as  the
previous  <select  statement: single row>.  The  type  of  the
literal should be different in the two statements.

Check that the values returned are, respectively, 9, 9, 7  and
6.

After  execution of each SQL statement, check that  the  value
returned in SQLSTATE indicates successful completion.

If  any of the checks fails,  then record a verdict of 'fail',
otherwise record a verdict of 'pass'.

(New 3 April 1995)


CTS5 SQL2 Test Purpose 094: Feature #44

IDENTIFICATION:
     TEST7043, XTS743

DESCRIPTION:
     AVG with outer reference not a <column reference>.

REFERENCES:
6.5      -- <general set function>
6.5     SR.4
6.5     SR.5
6.4     SR.8
6.5     LR.2c --    Raised. Entry SQL restriction which stated
          that  "if  a  <value expression> in a <set  function
          specification> contains a <column reference> that is
          an  outer  reference  then, the  <value  expression>
          shall be a <column reference>".
F#44  --  Intermediate set function

NOGO: NONE.

TEST PURPOSE:
To  determine that when the <value expression> of an AVG  <set
function specification> is not a simple <column reference>, it
may contain a <column reference> that is an outer reference.

TEST SPECIFICATION:
Use  a  table, EMP, with three columns, two, referred here  as
DEPTNO and SAL and representing department number employee and
salary,   with  numeric data type and the third,  referred  to
here  as  ENAME and representing employee name, with character
string  data  type.  Populate the  table  with  at  least  ten
different rows.

Create   an   ordered  cursor  that  will  select   the   rows
corresponding to those employees whose salary is Y (where Y is
any  numeric value) times greater than the average from  their
department,  ordered by department number  and  employee  name
within department. Use the syntax :

     SELECT DEPTNO, ENAME, SAL
          FROM EMP AS X
               WHERE Y < (SELECT AVG(X.SAL / SAL) FROM EMP
                         WHERE X.DEPTNO = DEPTNO)
          ORDER BY DEPTNO, ENAME;

Check  that the rows are returned with the anticipated results
and order.

After  execution of each SQL statement check  that  the  value
returned in SQLSTATE indicates successful completion.

If  any  check  fails, record a verdict of  'fail',  otherwise
record a verdict of 'pass'.


(New 3 April 1995)
(Revised 15 May 1995)


CTS5 SQL2 Test Purpose 095: Feature #44

IDENTIFICATION:
     TEST7060, XTS760

DESCRIPTION:
     MAX of column derived from <set function specification>.

REFERENCES:
     6.5 GR2  --  <set function specification>
               6.5  LR.2d  -     Raised. Entry SQL restriction
               which   stated   that  no  <column   reference>
               contained  in  a  <set function  specification>
               shall  reference a column derived from a <value
               expression>  that  generally  contains  a  <set
               function specification>
     F#44 -- Intermediate set function.

TEST PURPOSE
To  determine that a <column reference> may be contained in  a
<set  function specification> of MAX which references a column
derived  from a <value expression> that generally  contains  a
<set function specification>.

NOGO  : None.

TEST SPECIFICATION.
Use  a table TAV from the standard schema which contains three
columns, two of numeric data type and one of character  string
data type, and which is populated with at least five rows.

Use  a  <select statement: single row> on table TAV  with  the
following syntax:

SELECT MAX(avsal), dept
     INTO :HOST1
     FROM (
        SELECT dept, AVG(salary) avsal
        FROM TAV
        GROUP BY dept);

The first 'avsal' is a <column reference> as a simple instance
of   a   <value  expression>  contained  in  a  <set  function
specification>  that has MAX as its <set  function  type>.  It
references  the  column  derived from the  <value  expression>
'AVG(salary)'  correlated as 'avsal' that  generally  contains
the <set function specification> 'AVG(salary)'.

Check  that the value returned in the host variable  HOST1  is
the  anticipated  one i.e. the greatest  of  all  the  average
salaries of all the departments.

All  the names used are for ease of description only, and  are
not  intended  to constrain the choice of names  in  the  test
program or in the database.

If  any  check failed, record a verdict of 'fail',  otherwise,
record a verdict of 'pass'.


(New 19 June 1995)


CTS5 SQL2 Test Purpose 096: Feature #44

IDENTIFICATION:
     TEST7568, YTS811

DESCRIPTION:
       WHERE   <search  cond.>  referencing  column  generally
containing SUM

REFERENCES:
     7.6  --  <where clause>
     6.5 GR1b  --  <set function specification>
     3.3.4.2  -- Syntactic containment
     7.6 LR2a -- Raised
     F#44  --  Intermediate set function

NOGO:
     None

TEST PURPOSE:
To  determine that a <value expression> directly contained  in
the  <search  condition> in a <where  clause>  may  include  a
reference to a <derived column> that generally contains a <set
function specification> that specifies SUM.

TEST SPECIFICATION:
Let  TA  be  a  table with columns TA1, TA2, TA3 and  possibly
other  columns,  where the data type of  column  TA1  is  some
numeric type. Let VTA be a view defined as:
     CREATE VIEW VTA AS
          SELECT SUM (TA1) AS VT1, TA2 AS VT2, TA3 AS VT3
          FROM TA
          GROUP BY VT2, VT3

Ensure  that table TA is populated in such a way that one  row
of  TA has the null value in column TA1, VTA contains at least
three  rows, there are distinct values in column VT1, and  VTA
contains fewer rows than TA. Let n be the value in column  VT1
in  the  group that contains the row of TA that has  the  null
value in column TA1.

Declare   an  ordered  cursor  CR   on  VTA  with   a   <query
specification> that contains the <comparison predicate>
     VT1 NOT = n

Open  cursor  CR and fetch all rows. Check that  all  expected
rows are present. Close CR.

Execute  a  <select  statement:  single  row>  that  retrieves
columns VT1, VT2 and VT3 from table VTA, and specifies
     VT1 = n
in  the  <where clause> of its <table expression>. Check  that
the correct values are returned and that the value returned in
SQLSTATE  indicates the completion condition: warning  -  null
value eliminated in set function.

Execute a <select statement: single row> that specifies
     SELECT TB2.SUMTA1, TB3.SUMTA1 INTO :hv1, :hv2
          FROM (SELECT SUM(TA1) AS SUMTA1 FROM TA WHERE TA1 IS
NOT NULL) AS TB2,
                (SELECT SUM(VT1) AS SUMTA1 FROM VTA) AS TB3
          WHERE TB2.SUMTA1 = TB3.SUMTA1

Check that the two values returned are identical and equal  to
the sum of the values in column TA1 of table TA.

Except where a check for some other value is specified,  check
after  execution of each SQL statement that the value returned
in SQLSTATE indicates successful completion.

If  any  check  fails, record a verdict of  'fail',  otherwise
record a verdict of 'pass'.

(New 21 June 1995)


CTS5 SQL2 Test Purpose 097: Feature #45

IDENTIFICATION
     TEST7522, YTS788

DESCRIPTION
     CREATE CHARACTER SET, implicit default collation

REFERENCES
     11.28 -- <character set definition>
     21.2.18 -- CHARACTER_SETS view
     F#45 -- Character set definition
     F#2 -- Basic information schema

TEST PURPOSE
To  determine  that  if  a <character  set  definition>  which
specifies  neither a <collate clause> nor a <limited collation
definition>  is executed as an <SQL statement> in an  implicit
or  explicit  <procedure>, then a character set descriptor  is
created that describes the specified character set.

NOGO
     None.

TEST SPECIFICATION
Ensure  that  the  schema owned by the  current  authorization
identifier  in  which the character set descriptor  is  to  be
created  does  not  contain a character set descriptor  for  a
character  set  with  the  same  character  set  name  as  the
character set that is to be defined.

Execute  as  an  <SQL  schema  statement>  a  <character   set
definition> that specifies SQL_TEXT as <existing character set
name> and contains no optional elements.

Check that the value returned in SQLSTATE indicates successful
execution.  Commit  the creation of the character  set.  (Note
that  some  implementations may do an  implicit  commit  after
every  Schema Manipulation statement. That is not the  subject
of  this  test,  and  an explicit COMMIT here  will  put  most
implementations into the same state.)

Check that a row containing a description of the character set
specified  in  the  <character  set  definition>  has   become
accessible  through the CHARACTER_SETS view in the Information
Schema.     Check     that     the    columns     FORM_OF_USE,
NUMBER_OF_CHARACTERS,                 DEFAULT_COLLATE_CATALOG,
DEFAULT_COLLATE_SCHEMA,  DEFAULT_COLLATE_NAME  in   that   row
contain  the  same values, respectively, as the  corresponding
columns  in  the row describing the character set SQL_TEXT  in
the Information Schema.

Check  that the value in SQLSTATE after execution of each  SQL
statement indicates successful completion.

If any check has failed, record a verdict of 'fail', otherwise
record a verdict of 'pass'.


PROGRAMMING SPECIFICATION

Create   a  program  that  will  execute  under  authorization
identifier "CTS5" using schema "CTS5". Schema CTS5 should  not
normally  contain a character set descriptor that describes  a
character set  named "testset".




CTS5 SQL2 Test Purpose 098: Feature #45

IDENTIFICATION
     TEST7523, YTS789

DESCRIPTION
     CREATE CHAR SET in schema def, COLLATION FROM DEFAULT

REFERENCES
     11.28 -- <character set definition>
     11.1 -- <schema definition>
     21.2.18 -- CHARACTER_SETS view
     F#45 -- Character set definition
     F#31 -- Schema definition statement
     F#2 -- Basic information schema

TEST PURPOSE
To  determine  that  if  a <character  set  definition>  which
specifies  a  <limited  collation definition>  of  DEFAULT  is
executed as part of the execution of a <schema definition>  as
an  <SQL  statement>  in an implicit or explicit  <procedure>,
then  the  schema  that is created contains  a  character  set
descriptor that describes the specified character set.

NOGO:
None.

TEST SPECIFICATION
Ensure  that the current authorization identifier is  not  the
owner  of  a  schema with name of the schema  that  is  to  be
created.

Execute  as  an  <SQL schema statement> a <schema  definition>
that contains a <character set definition> for a character set
CS  that  specifies SQL_TEXT as <existing character set  name>
and  COLLATION FROM DEFAULT as <limited collation definition>.
Include <schema element>s in the <schema definition> that will
create  a  table, T, that contains a column, C, with  a  <data
type>  that  is  a  <character  string  type>  that  specifies
CHARACTER SET CS.

Check  that the value returned in SQLSTATE indicates that  the
creation  of  the  schema  has been  successful..  Commit  the
creation of the schema. (Note that some implementations may do
an  implicit commit after every Schema Manipulation statement.
That  is not the subject of this test, and an explicit  COMMIT
here will put most implementations into the same state.)

Check   that   a  row  has  become  accessible   through   the
CHARACTER_SETS  view in the Information Schema that  contains,
in  the  columns  CHARACTER_SET_SCHEMA and CHARACTER_SET_NAME,
respectively  the  name of the schema  and  the  name  of  the
character   set  CS.  Check  that  the  columns   FORM_OF_USE,
NUMBER_OF_CHARACTERS,                 DEFAULT_COLLATE_CATALOG,
DEFAULT_COLLATE_SCHEMA, and DEFAULT_COLLATE_NAME in  that  row
contain  the  same values, respectively, as the  corresponding
columns  in  the row describing the character set SQL_TEXT  in
the Information Schema.

Insert  into table T a row that contains a non-null  value  in
column C. Check that T contains one row, and that the value in
column C in that row is equal to the value that was inserted.

Check  that the value in SQLSTATE after execution of each  SQL
statement indicates successful completion.

If any check has failed, record a verdict of 'fail', otherwise
record a verdict of 'pass'.

PROGRAMMING SPECIFICATION
Create   a  program  that  will  execute  under  authorization
identifier  "CTS5". Authorization identifier CTS5  should  not
normally  own  a  schema  named "CTS5C".  Ensure  that  schema
CTS5.CTS5C does not exist.

CTS5 SQL2 Test Purpose 099: Feature #45

IDENTIFICATION
     TEST7524, YTS790
     TEST7525, YTS791
     TEST7526 YTS792

DESCRIPTION
     GRANT USAGE on character set, WITH GRANT OPTION

REFERENCES
     11.28  -- <character set definition>
     11.36 -- <grant statement>
     10.3 -- <privileges>
     11.3  -- <table definition>
     11.4 -- <column definition>
     16.4 -- <set session authorization identifier statement>
     F#45 -- Character set definition
     F#25 -- Domain Definition
     F#32 -- User Authorization
     F#3 -- Basic Schema Manipulation
     F#2 -- Basic Information Schema

TEST PURPOSE
To  ensure that when the USAGE privilege on a character set on
which  the  current owner has the USAGE privilege  with  grant
option  is granted to another user, then the privilege can  be
granted  by the second user to a third user and the  character
set can be used in data type definitions by all three users.

NOGO
     None.

TEST SPECIFICATION
Ensure the current user, A, has the USAGE privilege with grant
option  on  a  defined character set CS, and that  second  and
third users, B and C, do not have any privileges on CS.

Create  a  table,  TA,  which has a  column  TAC  based  on  a
character string <data type> that specifies CHARACTER SET CS.

Check that the value returned in SQLSTATE indicates successful
creation of the table TA. Commit the creation of table TA.

Insert  a row into the table TA such that a non-null value  is
stored in column TAC.

Check that the row has been inserted into the table TA. Commit
the population of the table.

Execute  a  <grant statement> that grants the USAGE  privilege
with  grant  option  on character set CS  to  user  B  as  the
grantee. Commit the granting of the privilege to user B.

Change to authorization identifier B.

Execute a <grant statement> that grants the USAGE privilege on
character set CS to user C as the grantee. Commit the granting
of the privilege to user C.

Create a table TB owned by B that contains a column TBC  based
on a character string <data type> that specifies CHARACTER SET
CS . Commit the creation of the table TB.

Insert  a row into the table TB such that a non-null value  is
stored in column TBC.

Use a <select statement: single row> to check that the row has
been inserted into the table TB.

Commit the population of table TB.

Change to authorization identifier C.

Create  a  domain CD owned by C that is based on  a  character
string  <data type> that specifies CHARACTER SET  CS.   Commit
the creation of the domain.

Check  that the domain has been created by retrieving the  row
describing the domain C.CD from the Information Schema DOMAINS
view.

Create a table TC owned by C that contains a column TCC  based
on the domain CD. Commit the creation of the table TC.

Insert  a row into the table TC such that a non-null value  is
stored in column TCC.

Check that the row has been inserted into the table TC.

Commit the population of table TC.

After each execution of an SQL statement, check that the value
returned in SQLSTATE indicates successful completion.

If any check fails, then record a verdict of 'fail', otherwise
record a verdict of 'pass'.



CTS5 SQL2 Test Purpose 100: Feature #45

IDENTIFICATION
     TEST7527, YTS793
     TEST7528, YTS794
     TEST7529, YTS795

DESCRIPTION
     GRANT USAGE on character set, no WGO

REFERENCES
     11.28  -- <character set definition>
     11.36 -- <grant statement>
     10.3 -- <privileges>
     11.3  -- <table definition>
     11.4 -- <column definition>
     16.4 -- <set session authorization identifier statement>
     F#45 -- Character set definition
     F#32 -- User Authorization
     F#3 -- Basic Schema Manipulation
     F#2 -- Basic Information Schema

TEST PURPOSE
To  ensure that when the USAGE privilege on a character set on
which  the  current owner has the USAGE privilege  with  grant
option  is granted to another user, without the grant  option,
then  the privilege cannot be granted by the second user to  a
third  user,  but the character set can be used in  data  type
definitions by the first two users.

NOGO
None.

TEST SPECIFICATION
Ensure the current user, A, has the USAGE privilege with grant
option  on  a  defined character set CS, and that  second  and
third users, B and C, do not have any privileges on CS.

Create  a  table,  TA,  which has a  column  TAC  based  on  a
character string <data type> that specifies CHARACTER SET CS.

Check that the value returned in SQLSTATE indicates successful
creation of the table TA. Commit the creation of table TA.

Insert  a row into the table TA such that a non-null value  is
stored in column TAC.

Check that the row has been inserted into the table TA. Commit
the population of the table.

Execute a <grant statement> that grants the USAGE privilege on
character  set  CS  without grant option  to  user  B  as  the
grantee. Commit the granting of the privilege to user B.

Change to authorization identifier B.

Execute a <grant statement> that grants the USAGE privilege on
character  set  CS to user C as the grantee.  Check  that  the
value  returned in SQLSTATE indicates that the grant has  been
unsuccessful, with an exception raised: Syntax Rule or  Access
Rule violation.  Terminate the transaction.

Create a table TB owned by B that contains a column TBC  based
on a character string <data type> that specifies CHARACTER SET
CS . Commit the creation of the table TB.

Insert  a row into the table TB such that a non-null value  is
stored in column TBC.

Use a <select statement: single row> to check that the row has
been inserted into the table TB.

Commit the population of table TB.

Change to authorization identifier C.

Attempt to create a table TC owned by C that contains a column
TCC   that  is  based on a character string <data  type>  that
specifies CHARACTER SET CS.  Check that the value returned  in
SQLSTATE  indicates  that the creation has been  unsuccessful,
with   an  exception  raised:  Syntax  Rule  or  Access   Rule
violation.  Terminate the transaction.

Check  that  the  table  has not been created  by  failing  to
retrieving  the  row  describing  the  table  C.TC  from   the
Information Schema TABLES view.

After  each execution of an SQL statement, except those  where
some  other  termination condition or exception  condition  is
expected,  check that the value returned in SQLSTATE indicates
successful completion.

If any check fails, then record a verdict of 'fail', otherwise
record a verdict of 'pass'.

Note:      The  implementation of the early parts of this test
     can  be  combined  with the implementation  of  the  test
     defined in Ref 99.

(Editorial correction, 21 June 1995)


CTS5 SQL2 Test Purpose 101: Feature #45

IDENTIFICATION
     TEST7061, XTS761

DESCRIPTION
     Defined character set in <comparison predicate>.

REFERENCES
     11.28  --  <character set definition>
     10.4  --  <character set specification>
     10.4 SR.3
     10.4 GR.3
     4.2.3  --  Rules determining collating sequence usage.
     8.2  --  <comparison predicate>
     8.2 SR.3
     F#45  --  Character set definition.

TEST PURPOSE
To determine that an operand of a <comparison predicate> may
be a character string from a character set that is specified
with an explicit <character set specification>, where the
<character set specification> is based on SQL_TEXT.

NOGO
     None

TEST SPECIFICATION
Specific names are used below for ease of description only,
and are not intended to constrain the choice of names in the
test program or in the database.

Ensure that before the test is executed, that there exists
under the current schema a user defined character set named CS
based on the SQL_TEXT character set, and a table TABCS with
two columns, C1 and C2, of character string data type, both
declared with an explicit <character set specification> of CS,
and one column, N1, of numeric data type declared with <unique
specification> of UNIQUE. Column N1 can thus be used to
identify the rows of TABCS. The table will contain four rows,
with no null values in any of columns N1, C1 and C2, and with
a value V1 that appears in column C1 in exactly two rows, and
no rows where the value in C1 is the same as the value in C2.

Use an ordered cursor with column N1 as <sort key> to
retrieve all the rows of TABCS in which the value in column C1
is equal to V1, specified as a literal with an explicit
<character set specification> of CS. Check that exactly two
rows are returned and that these rows have the anticipated
contents.

Use a <select statement: single row> with a <set function
specification> with COUNT and count all the rows from TABCS
where the values of the columns C1 and C2 are equal. Check
that the result returned by COUNT is zero.

Use a <select statement: single row> with a <set function
specification> COUNT (*) to retrieve into a host variable, x,
the number of rows in TABCS where the value in column C1 is
greater than the value in column C2.

Use a <select statement: single row> with a <set function
specification> COUNT (C2) to retrieve into a host variable, y,
the number of  rows in TABCS where the value in column C1 is
less than or equal to the value in column C2.

Check that the sum of host variables x and y is 4, the number
of rows present in table TABCS.


If all tests were successful record a pass, otherwise record a
fail.

(Modified 7 July 1995)


CTS5 SQL2 Test Purpose 102: Feature #45

IDENTIFICATION
     TEST7062, XTS762

DESCRIPTION
     Defined character set in <like predicate>.

REFERENCES
     10.4  --  <character set specification>
     10.4 SR.3
     10.4 GR.3
     4.2.3  --  Rules determining collating sequence usage.
     11.28  --  <character set definition>
     8.5  --  <like predicate>
     8.5 SR.1
     F#45  --  Character set definition.

TEST PURPOSE
To determine that different derivations of <character value
expression>s such as <character string literal>s which have
been specified with an explicit <character set specification>
of a user defined character set, then these <character string
literal>s can be specified in a <like predicate> as
<pattern>s.

NOGO
     None

TEST SPECIFICATION
Specific names are used below for ease of description only,
and are not intended to constrain the choice of names in the
test program or in the database.

Ensure that before the test is executed, that there exists
under the current schema a user defined character set named CS
based on the SQL_TEXT character set, and a table TABCS which
will consist of two columns  C1 and C2, of character string
data type, both declared with an explicit <character set
specification> of CS, and one column, N1, of numeric data type
declared with <unique specification> of UNIQUE that can be
used to identify the rows of TABCS. The table will contain
four rows.

Declare an ordered cursor, CR, over table TABCS ,with column
N1 as <sort key>, that specifies in the <where clause> of the
<query expression> a <like predicate> with column C1 as <match
value>, and <pattern> is a <literal> with an explicit
<character set specification> of CS that contains three
characters followed by the arbitrary string specifier, where
the first three characters occur in the same sequence in
column C1 in two rows.

Open cursor CR and fetch all rows. Check that exactly two rows
are returned and that these rows have the anticipated
contents. Close CR.

Let P1 be a character string that consists of three characters
that do not occur as the first three characters of any value
in column C1 of TABCS, followed by the arbitrary string
specifier. Let P2 be a character string that consists of three
characters that do not occur as the first three characters of
any value in column C2 of TABCS, followed by the arbitrary
string specifier.

Execute a <select statement: single row> that specifies COUNT
(C1),  COUNT (C2) as <select list>,  TABCS as <from clause>,
and C1 LIKE _CS 'P1', OR C2 LIKE _CS 'P2' as <where clause>.
Check that both values returned by COUNT are zero.

After execution of each SQL statement, check that the value
returned in SQLSTATE indicates successful completion.

If any check fails record a verdict of 'fail', otherwise
record a verdict of 'pass'.

(Modified 7 July 1995)


CTS5 SQL2 Test Purpose 103: Feature #45

IDENTIFICATION
     TEST7063, XTS763

DESCRIPTION
     Access to CHARACTER_SETS view.

REFERENCES
     21.2.18 -- CHARACTER_SETS view
     21.3.23 --  CHARACTER_SETS base table
     10.4  --  <character set specification>
     10.4 LR.2a  --  Raised Entry SQL restriction which
prohibited the specification of character sets
     F#45  --  Character set definition
     F#2  --  Basic Information schema

TEST PURPOSE
To determine that the CHARACTER_SETS view of the Information
Schema is accessible to a user, and contains rows identifying
the character sets that are accessible to that user, including
user-defined character sets.

NOGO
     None

TEST SPECIFICATION
Specific names are used below for ease of description only,
and are not intended to constrain the choice of names in the
test program or in the database.

Ensure that before the test is executed, that there exists
under the current schema a user defined character set named CS
based on the SQL_TEXT character set and at least one character
set in addition to SQL_TEXT and CS that is accessible to the
current user.

Declare a cursor CR to retrieve all columns and all rows of
the CHARACTER_SETS view in the  Information Schema.

Open CR and fetch all rows.

Check that there are at least three rows, and that two of
those rows describe the character sets SQL_TEXT and CS.

For the rows describe the character sets SQL_TEXT and CS,
check that the value in column NUMBER_OF_CHARACTERS is not
less than 83.

For each row, print the values of CHARACTER_SET_SCHEMA and
CHARACTER_SET_NAME.

After execution of each SQL statement check that the value
returned in SQLSTATE indicates successful completion.

If any of the checks failed record a verdict of 'fail'
otherwise record a verdict of 'pass'.


(Modified 7 July 1995)


CTS5 SQL2 Test Purpose 104: Feature #45

IDENTIFICATION
     TEST7571, YTS814

DESCRIPTION
     <module character set specification>

REFERENCES
     12.2  --  <module name clause>
     5.3 SR6a -- <literal>
     5.4 SR1a  -- Names and identifiers
     6.1 GR1 -- <data type>
      19.1  SR14b   --   <embedded SQL host program>,  derived
<module>
     F#45 -- Character set definition
     F#46 -- Named character sets
     F#3 -- Basic schema manipulation
     F#2 -- Basic information schema

TEST PURPOSE
To  ensure that when a <module character set specification> is
specified  in  a  <module>, then the specified  character  set
identifies  the  character repertoire used for expressing  the
names  of schema objects used in the <module> and the contents
of literals used in the module.

NOGO
None.

TEST SPECIFICATION
The  names  specified below for tables and columns created  by
the  test  are for convenience of explanation only;  different
names must be used for implementation of the specification.

Create  a  <module>  that specifies LATIN1 as  <character  set
specification>  in  <module character  set  specification>  in
<module  name  clause>. In embedded SQL test programs  achieve
this by specifying an <embedded character set declaration>  in
the  <embedded SQL declare section>. (Note that, in  order  to
avoid  a  defect in the SQL standard, the program  should  not
contain more than one <embedded SQL declare section>.)

In  a  schema  owned by the current authorization  identifier,
create a table TT with columns TT1 and TT2,  with numeric  and
character string data types, respectively. In the <data  type>
in  the <column definition> for TT2, include a <character  set
specification> that specifies ASCII_GRAPHIC. In  each  of  the
actual names used for TT, TT1 and TT2, include at least one of
the  characters designated as a letter in ISO 8859-1  that  is
not  included  in  <simple  Latin  letter>  in  ISO/IEC  9075.
Examples  of  suitable  letters are  "Capital  Letter  O  with
oblique  stroke" (coded 13/08, 216 decimal, in  ISO/IEC  9075)
and  "small  letter u with diaeresis" (u-umlaut, coded  15/12,
252 decimal), but other letters may be used.

Check that rows corresponding to table TT and its columns  TT1
and  TT2  exist  in  the Information Schema views  TABLES  and
COLUMNS, respectively. For columns TT1 and TT2, check that the
data type is recorded correctly, and for column TT2 check that
column CHARACTER_SET_NAME contains "ASCII_GRAPHIC".

Execute  four  INSERT statements that attempt to  insert  rows
into  table  TT. For the two of the rows, specify  values  for
column TT2 by means of literals, and for the other two specify
values  for column TT2 by means of host variables. For one  of
each  pair,  specify a value composed of characters  that  are
included in both character sets ASCII_GRAPHIC and LATIN1.  For
the  other member of each pair, include in the value at  least
one   character  that  is  included  in  LATIN1  but  not   in
ASCII_GRAPHIC.  Specify a different value for  column  TT1  in
each row.

Check  that  for  each  case where a  character  that  is  not
included in ASCII_GRAPHIC is specified, an exception is raised
with SQLSTATE containing a value that indicates data exception
- character not in repertoire.

Using  a  cursor ordered on column TT2, retrieve all  rows  of
table  TT.  Check that only the two rows that  were  specified
with  valid  values in column TT2 are in the table,  and  that
they  are  returned  in  the correct order  according  to  the
collating  sequence determined from ISO 8859-1, and  with  the
correct values in column TT1.
After  each  execution of an SQL statement, except  those  for
which  some other termination condition or exception condition
is  specified,  check  that  the value  returned  in  SQLSTATE
indicates successful completion.

If any check fails, then record a verdict of 'fail', otherwise
record a verdict of 'pass'.


(New 22 June 1995)

CTS5 SQL2 Test Purpose 105: Feature #45

IDENTIFICATION
     TEST7064, XTS764

DESCRIPTION
     REVOKE USAGE on character set RESTRICT

REFERENCES
     11.37  --  <revoke statement>
     TC#2  --  11.37 Errata
     11.37 SR6
     11.37 SR8
     11.37 SR11
     11.37  SR18a
     11.37  SR25
     11.37 GR2
     11.37 GR8
     11.37 LR.2a  --  Raised
     13.8  --  <insert statement>
     F#45  --  Character set definition
     F#1  --  Dynamic SQL
     F#2  --  Basic information schema
     F#3  --  Basic schema manipulation
     F#32  --  User Authorization

TEST PURPOSE
To determine that on execution by the current user, GR, of a
<revoke statement> that specifies a character set name, CS, as
object, RESTRICT as <drop behaviour> and a single <grantee>,
GE, then:

a)   if GE holds a grant of USAGE WITH GRANT OPTION on CS from
     GR, and GE does not hold a grant of USAGE on CS from any
     other source, and GE has not granted USAGE on CS to any
     other user, then if GRANT OPTION FOR is specified, all
     columns of any table owned by GE in which there is a
     column that includes character set CS in its data type
     descriptor remains accessible, and the privilege
     descriptor pertaining to that privilege is modified to
     indicate that it is not grantable.

b)   if GE holds a grant of  USAGE on CS from GR without GRANT
     OPTION, and GE does not hold a grant of USAGE on CS from
     any other source, then if GRANT OPTION FOR is not
     specified, execution of the <revoke statement> is
     unsuccessful if GE owns a table in which there is a
     column that includes character set CS in its data type
     descriptor, and successful if GE does not own any schema
     object that requires GE to have the USAGE privilege on
     CS.

NOGO
     None.

TEST SPECIFICATION
Ensure that current user, GR, has the USAGE privilege with
GRANT OPTION on a user-defined character set CS and has
granted the USAGE privilege on CS to a users B and C WITH
GRANT OPTION, and neither B nor C holds the USAGE privilege on
CS granted by any other source. Ensure that C owns a table
TACS that has a column declared with an explicit <character
set specification> of CS, and that B does not own any schema
element that have been defined with an explicit <character set
specification> of CS.

Execute a <select statement: single row> that specifies COUNT
(*) as <select list> to count the number of rows in the
Information Schema USAGE_PRIVILEGES view where the values in
columns GRANTOR, GRANTEE, OBJECT_NAME, OBJECT_TYPE and
IS_GRANTABLE are GR, B, CS, 'CHARACTER SET', and 'YES',
respectively. Check that the value returned is 1.

Execute a <select statement: single row> that specifies
IS_GRANTABLE in its <select list> to retrieve the row in the
Information Schema USAGE_PRIVILEGES view where the values in
columns GRANTOR, GRANTEE, OBJECT_NAME and OBJECT_TYPE are GR,
C, CS, and 'CHARACTER SET', respectively. Check that there is
one such row and that the value in column IS_GRANTABLE is
'YES'.

Terminate the transaction.

Execute a <revoke statement> that specifies REVOKE USAGE ON CS
FROM B RESTRICT.

Execute a <revoke statement> that specifies REVOKE GRANT
OPTION FOR USAGE ON CS FROM C RESTRICT.

Terminate the transaction.

Execute a <select statement: single row> that specifies
IS_GRANTABLE as <select list> to retrieve that column from the
row in the Information Schema USAGE_PRIVILEGES view where the
values in columns GRANTOR, GRANTEE, OBJECT_NAME and
OBJECT_TYPE are GR, C, CS and 'CHARACTER SET', respectively.
Check that one row is returned and that the value returned is
'NO'.

Terminate the transaction.

Change to authorization identifier B and execute a <select
statement: single row> that specifies COUNT (*) as <select
list> to count the number of rows in the Information Schema
USAGE_PRIVILEGES view where the values in columns GRANTEE,
OBJECT_NAME and OBJECT_TYPE are B, CS, and 'CHARACTER SET',
respectively. Check that the value returned is zero.

Terminate the transaction.

Change to authorization identifier GR. Use Dynamic SQL to
prepare and execute a <revoke statement> that specifies REVOKE
USAGE ON CS FROM C RESTRICT. Check that the value returned in
SQLSTATE indicates the exception condition: syntax rule or
access rule violation ('4200').

Terminate the transaction.

Change to authorization identifier C.

Execute an <insert statement> that inserts a row into table
TACS, specifying every column of TACS explicitly in the
<insert column list>.

Execute a <revoke statement> that specifies REVOKE USAGE ON CS
FROM C RESTRICT. Check that the value returned in SQLSTATE
indicates the completion condition: warning - privilege not
revoked ('01006').

Execute a <drop table statement> with TACS as <table name>
with CASCADE <drop behaviour>.

Terminate the transaction with COMMIT.

Change to authorization identifier GR. Execute a <revoke
statement> and revoke USAGE on character set CS from
authorization identifiers B  and C with RESTRICT <drop
behaviour>.

Except where a check for some other value is specified or
implied, after execution of each SQL statement check that the
value returned in SQLSTATE indicates successful execution.

If any of the checks failed record a verdict of 'fail'
otherwise record a verdict of 'pass'.

Specific authorization identifiers, character set, table and
column names names are used for ease of description only, and
are not intended to constrain the choice of names in the test
program or in the database.
(Modified 13 July 1995)

CTS5 SQL2 Test Purpose 106: Feature #45

IDENTIFICATION:
     TEST7065, XTS765

DESCRIPTION
     REVOKE USAGE on character set CASCADE.

REFERENCES
     11.37  --  <revoke statement>
     TC#2 --  11.37 Errata
     11.37 SR.11
     11.37 SR18a
     11.37 GR1
     11.37 GR2
     11.37 GR7.1
     11.37 LR.2a  --  Raised. Entry SQL restriction which
prohibited the use of a <revoke statement>
     F#45  --  Character set definition
     F#2  --  Basic Information schema
     F#32  --  User Authorization

TEST PURPOSE
Let GR be an authorisation identifier that has the USAGE
privilege, WITH GRANT OPTION, on a character set CS. Let GE1
be the only authorisation identifier to which GR has granted
the USAGE privilege on CS, and let that grant be WITH GRANT
OPTION. Let GE2 be the only authorisation identifier to which
GE1 has granted the USAGE privilege on CS, and let that grant
be without the grant option. Let the only grants of USAGE on
CS to GE1 and GE2 be from GR and GE1, respectively. Let GE1
own a table GE1T which has a column, GE1TC, that includes CS
in its data type descriptor and at least one other column and
on which it has granted no privileges, let GE2 own a table
GE2T which has a column, GE2TC, that includes CS in its data
type descriptor and at least one other column and on which it
has granted no privileges.

To determine that on execution, with GR as current user, of a
<revoke statement> that specifies CS as object, CASCADE as
<drop behaviour> and GE1 as the only <grantee>:

a)   if the <revoke statement> specifies GRANT OPTION FROM,
     then the privilege descriptor recording the grant of
     USAGE on CS by GE1 to GE2 is destroyed, the privilege
     descriptor recording the grant by CR of USAGE WITH GRANT
     OPTION on CS to GE1 is modifed to indicate that GE1 now
     holds the privilege USAGE on CS without the grant option,
     table GE1T remains unaltered and accessible by user GE1,
     and table GE2T remains accessible by user GE2, but no
     longer contains column GE2TC.

b)   if the <revoke statement> does not specify GRANT OPTION
     FROM,  then the privilege descriptors recording the
     grants by GR and GE1 of USAGE on CS to GE1 and GE2,
     respectively, column GE1TC of table GE1T and column GE2TC
     of table GE2T are all destroyed.

NOGO
     None

TEST SPECIFICATION
Ensure that current user GR has the USAGE privilege with GRANT
OPTION on a defined character set CS, and that users GE2 and
GE2 do not have USAGE privilege on CS.

Execute a <grant statement> that grants USAGE on CS to GE1
WITH GRANT OPTION.

Terminate the transaction.

Change to user GE1. Create a table GE1T with two columns, the
first, GE1TC, with a character string data type that specifies
a <character set specification> of CS, and the second, GE1TN,
with a numeric data type.

Execute a <grant statement> that grants USAGE on CS to GE2
without the grant option.

Terminate the transaction.

Using <select statement: single row>, retrieve from the
COLUMNS view of the Information Schema the row that describes
column GE1TC of table GE1T. Check that the row exists, with
the correct description of the data type as character string
and character set CS, and that the ordinal position is 1.

Using <select statement: single row>, retrieve from the
COLUMNS view of the Information Schema the row that describes
column GE1TN of table GE1T. Check that the row exists, with
the correct description of the data type as the specified
numeric type, and that the ordinal position is 2.

Terminate the transaction.

Change to user GE2. Create a table GE21T with two columns, the
first, GE2TC, with a character string data type that specifies
a <character set specification> of CS, and the second, GE2TN,
with a numeric data type.

Terminate the transaction.

Using <select statement: single row>, retrieve from the
COLUMNS view of the Information Schema the row that describes
column GE2TC of table GE2T. Check that the row exists, with
the correct description of the data type as character string
and character set CS, and that the ordinal position is 1.

Using <select statement: single row>, retrieve from the
COLUMNS view of the Information Schema the row that describes
column GE2TN of table GE2T. Check that the row exists, with
the correct description of the data type as the specified
numeric type, and that the ordinal position is 2.

Terminate the transaction.

Change to user GR. Execute the <revoke statement>
          REVOKE GRANT OPTION FOR USAGE ON CS FROM GE1 CASCADE

Terminate the transaction.

Change to user GE1.

Using <select statement: single row>, retrieve from the
COLUMNS view of the Information Schema the row that describes
column GE1TC of table GE1T. Check that the row exists, with
the correct description of the data type as character string
and character set CS, and that the ordinal position is 1.

Using <select statement: single row>, retrieve from the
USAGE_PRIVILEGES view of the Information Schema the row that
describes USAGE privileges on character set CS available to or
granted by the current user. Check that there is one such row,
and that it describes a grant without grant option from GR to
GE1.

Terminate the transaction.

Change to user GE2.

Using <select statement: single row>, attempt  to retrieve
from the USAGE_PRIVILEGES view of the Information Schema the
row that describes USAGE privileges on character set CS
available to or granted by the current user. Check that there
is no such row

Using <select statement: single row>, attempt to retrieve from
the COLUMNS view of the Information Schema the row that
describes column GE2TC of table GE2T. Check that the row does
not exist

Using <select statement: single row>, retrieve from the
COLUMNS view of the Information Schema the row that describes
column GE2TN of table GE2T. Check that the row exists, with
the correct description of the data type as the specified
numeric type, and that the ordinal position is now 1.
Terminate the transaction.

Change to user GR.

Execute a <grant statement> that grants USAGE on CS to GE1
WITH GRANT OPTION.

Terminate the transaction.

Change to user GE1.

Execute a <grant statement> that grants USAGE on CS to GE2
without the grant option.

Terminate the transaction.

Change to user GE2. Create a table GE2U with two columns, the
first, GE2UC, with a character string data type that specifies
a <character set specification> of CS, and the second, GE2UN,
with a numeric data type.

Terminate the transaction.

Using <select statement: single row>, retrieve from the
COLUMNS view of the Information Schema the row that describes
column GE2UC of table GE2U. Check that the row exists, with
the correct description of the data type as character string
and character set CS, and that the ordinal position is 1.

Using <select statement: single row>, retrieve from the
COLUMNS view of the Information Schema the row that describes
column GE2UN of table GE2U. Check that the row exists, with
the correct description of the data type as the specified
numeric type, and that the ordinal position is 2.

Terminate the transaction.

Change to user GR. Execute the <revoke statement>
          REVOKE USAGE ON CS FROM GE1 CASCADE

Terminate the transaction.

Change to user GE1.

Using <select statement: single row>, attempt to retrieve from
the COLUMNS view of the Information Schema the row that
describes column GE1TC of table GE1T. Check that the row does
not exist.

Using <select statement: single row>, retrieve from the
COLUMNS view of the Information Schema the row that describes
column GE1TN of table GE1T. Check that the row exists, with
the correct description of the data type as the specified
numeric type, and that the ordinal position is 1.

Using <select statement: single row>, attempt to retrieve from
the USAGE_PRIVILEGES view of the Information Schema the row
that describes USAGE privileges on character set CS available
to or granted by the current user. Check that there is no such
row.

Terminate the transaction.

Drop table GE1T.

Terminate the transaction.

Change to user GE2.

Using <select statement: single row>, attempt  to retrieve
from the USAGE_PRIVILEGES view of the Information Schema the
row that describes USAGE privileges on character set CS
available to or granted by the current user. Check that there
is no such row
Using <select statement: single row>, attempt to retrieve from
the COLUMNS view of the Information Schema the row that
describes column GE2UC of table GE2U. Check that the row does
not exist

Using <select statement: single row>, retrieve from the
COLUMNS view of the Information Schema the row that describes
column GE2UN of table GE2U. Check that the row exists, with
the correct description of the data type as the specified
numeric type, and that the ordinal position is now 1.

Terminate the transaction.

Drop tables GE2T and GE2U.

Terminate the transaction.

Change to user GR.

Except where a check for some other value is specified or
implied, after execution of each SQL statement check that the
value returned in SQLSTATE indicates successful execution.

All specific character set, table and  column names and
authorization identifiers used are for ease of description
only, and are not intended to constrain the choice of names in
the test program or in the database.

If any of the checks failed record a verdict of 'fail',
otherwise record a verdict of 'pass'.


(Rewritten 12 July 1995)


CTS5 SQL2 Test Purpose 107: Feature #45

IDENTIFICATION
     TEST7066, XTS766

DESCRIPTION
     DROP character set no granted privileges

REFERENCES
     11.29  --  <drop character set statement>
     TC#1  --  11.29
     11.29 SR.3
               11.29 LR.2a -- Raised. Entry SQL prohibition on
               use of a <drop character set statement>
     21.2.12 --  USAGE_PRIVILEGES view
     21.3.22 -- USAGE_PRIVILEGES base table
     F#45  --  Character set definition
     F#23  --  Privilege tables

TEST PURPOSE
To determine that when the current user owns a character set,
CS, has not granted any privileges on CS to any other user,
and there are no schema objects that depend  on the existence
of CS, execution of  a <drop character set statement> that
references CS destroys that character set.

NOGO
     None

TEST SPECIFICATION
Let  the current authorization identifier, Z, own a character
set, CS, such that the USAGE privilege on CS has not been
granted to any other user and there are no schema objects that
depend on the existence of  CS.

Use a <select statement: single row> to retrieve from the
CHARACTER_SETS view in the Information Schema the row in which
the values of the columns GRANTEE, OBJECT_SCHEMA, OBJECT_NAME
and OBJECT_TYPE are are equal to Z , the name of the schema
containing CS, CS, and 'CHARACTER SET', respectively. Check
that there is exactly one such row, and that the value in
column GRANTOR is '_SYSTEM'.

Execute a <drop character set statement> that specifies CS as
<character set name>.

Use a <select statement: single row> to attempt to  retrieve
from the CHARACTER_SETS view in the Information Schema the row
in which the values of the columns GRANTEE, OBJECT_SCHEMA,
OBJECT_NAME and OBJECT_TYPE are are equal to Z , the name of
the schema containing CS, CS, and 'CHARACTER SET',
respectively. Check that the value returned in SQLSTATE
indicates the completion condition no data ('02000').

Except where a check for some other vales is specified or
implied, check after execution of each SQL statement that the
value returned in SQLSTATE indicates successful completion.

If any of the checks failed record a verdict of 'fail',
otherwise record a verdict of 'pass'.

All the names used are for ease of description only, and are
not intended to constrain the choice of names in the test
program or in the database.


(Modified, 13 July 1995)


CTS5 SQL2 Test Purpose 108: Feature #45

IDENTIFICATION
     TEST7067, XTS767

DESCRIPTION
     DROP character set, outstanding granted privileges

REFERENCES
     11.29  --  <drop character set statement>
     TC#1 --  11.29
     11.29 GR.1
     11.29 SR.3
     11.29 LR.2a  --  Raised. Entry SQL restriction on the use
of a <drop character set statement>
     11.37  --  <Revoke statement>
     F#45  --  Character set definition
     F#2  --  Basic Information schema
     F#3  --  Basic Schema Manipulation
     F#32  --  User Authorization

TEST PURPOSE
To determine that when the current user owns a character set,
CS, and has granted the USAGE privilege on CS to other users,
then if there are any schema objects that depend on the
existence of CS, execution of a <drop character set statement>
that specifies CS as <character set name> causes an exception
condition of syntax error or access rule violation to be
raised; and if there are no such objects execution of the
statement destroys CS and all privilege descriptors that
record grants of the USAGE privilege on CS.

NOGO
     None

TEST SPECIFICATION
Ensure that current user USR owns a character set CS and has
granted the USAGE privilege on CS to a user USR1 which owns a
table TAV with columns that were defined with an explicit
character set specification of CS.

Execute a <drop character set statement> with CS as <character
set name> and attempt to destroy character set CS. Check that
the value returned in SQLSTATE indicates that the exception
condition syntax error or access rule violation was raised.

Terminate the transaction with COMMIT.

Change to authorization identifier USR1. Execute a <drop table
statement> and that specifies TAV as <table name> and CASCADE
<drop behaviour>.

Terminate the transaction with COMMIT.

Change to authorization identifier USR. Execute a <drop
character set statement> with CS as <character set name> and
attempt to destroy character set CS.

Terminate the transaction with COMMIT.

Use a <select statement: single row> with a COUNT <set
function specification> and determine the number of rows in
the  CHARACTER_SETS view in the Information Schema where the
values of the columns CHARACTER_SET_NAME and
CHARACTER_SET_SCHEMA are equal to CS and USR, respectively.
Check that the value returned by COUNT is zero.

Use a <select statement: single row> with a COUNT <set
function specification>s and determine from the
USAGE_PRIVELEGES view in the Information Schema the number of
rows where the values of the columns OBJECT_SCHEMA,
OBJECT_NAME and OBJECT_TYPE are equal to USR, CS and CHARACTER
SET, respectively. Check that the value returned by COUNT is
zero.
Except where a check for some other value is specified or
implied, check after execution of each SQL statement that the
value returned in SQLSTATE indicates successful completion.

If any of the checks failed record a verdict of 'fail',
otherwise record a verdict of 'pass'.

All specific names used are for ease of description only, and
are not intended to constrain the choice of names in the test
program or in the database.


(Modified 13 July 1995)


CTS5 SQL2 Test Purpose 109: Feature #46

IDENTIFICATION
     TEST7044, XTS744

DESCRIPTION

     Presence of SQL_CHARACTER in CHARACTER_SETS view

REFERENCES:
     21.2.18  --  CHARACTER_SETS view
     21.3.23  --  CHARACTER_SETS base table
     FIPS 16.7 -- Character set support
      F#46  --  Named character sets
      F#2  --  Basic information schema

TEST PURPOSE
To determine that the INFORMATION_SCHEMA.CHARACTER_SETS view
is accessible to a user and it contains a row that describes
the character set SQL_CHARACTER defined in FIPS 127-2.

NOGO
     None.

TEST SPECIFICATION
Define a cursor on the CHARACTER_SETS view in the Information
schema, selecting rows where the values of the columns
CHARACTER_SET_CATALOG, CHARACTER_SET_NAME, and
NUMBER_OF_CHARACTERS contain the values 'INFORMATION_SCHEMA',
'SQL_CHARACTER', and 83, respectively.

Open the cursor and retrieve all rows. Check that there is at
exactly one row and that none of the columns
DEFAULT_COLLATE_CATALOG, DEFAULT_COLLATE_SCHEMA and
DEFAULT_COLLATE_NAME in that row contain the null value.

After execution of each SQL statement check that the value
returned in SQLSTATE indicates successful completion.

If any of the checks failed record a verdict of 'fail',
otherwise record a verdict of 'pass'.


(Modified 13 July 1995)


CTS5 SQL2 Test Purpose 110: Feature #46

IDENTIFICATION
     TEST7045, XTS745

DESCRIPTION
     Presence of ASCII_GRAPHIC in CHARACTER_SETS view

REFERENCES
     21.2.18  --  CHARACTER_SETS view.
     21.3.23  --  CHARACTER_SETS base table
     F#46  --  Named character sets
     F#1  --  Dynamic SQL
     F#2  --  Basic information schema

TEST PURPOSE
To determine that the INFORMATION_SCHEMA.CHARACTER_SETS view
is accessible to a user and it contains a row that describes
the character set ASCII_GRAPHIC defined in FIPS 127-2.

NOGO
     None

TEST SPECIFICATION
Use Dynamic SQL with a <preparable statement> with a <set
function specification> of COUNT(*) access the CHARACTER_SETS
view from the Information schema and count all the rows where
the values of the columns CHARACTER_SET_SCHEMA,
CHARACTER_SET_NAME and NUMBER_OF_CHARACTERS contain the
values: 'INFORMATION_SCHEMA', 'ASCII_GRAPHIC' and 95,
respectively, and none of the columns DEFAULT_COLLATE_CATALOG,
DEFAULT_COLLATE_SCHEMA and DEFAULT_COLLATE_NAME contain the
null value. Check that the value returned by COUNT is equal to
one.

After execution of each SQL statement check that the value
returned in SQLSTATE indicates successful completion.

If any of the checks failed record a verdict of 'fail',
otherwise record a verdict of 'pass'.


(Modified 13 July 1995)


CTS5 SQL2 Test Purpose 111: Feature #46

IDENTIFICATION
     TEST7046, XTS746

DESCRIPTION
     Presence of LATIN1 in CHARACTER_SETS view

REFERENCES
     21.2.18  --  CHARACTER_SETS view.
     21.3.23  --  CHARACTER_SETS base table.
      F#2  --  Basic information schema.
      F#46  --  Named character sets.

TEST PURPOSE
To determine that the INFORMATION_SCHEMA.CHARACTER_SETS view
is accessible  to a user and it contains a row that describes
the character set LATIN1 defined in FIPS 127-2.

NOGO
     None

TEST SPECIFICATION
Use a <select statement: single row> and access the
CHARACTER_SETS view from the Information schema and determine
that there exists a row where the values of the columns
CHARACTER_SET_SCHEMA, CHARACTER_SET_NAME and
NUMBER_OF_CHARACTERS are'INFORMATION_SCHEMA',  'LATIN1' and
191, respectively, and none of the columns
DEFAULT_COLLATE_CATALOG, DEFAULT_COLLATE_SCHEMA and
DEFAULT_COLLATE_NAME contain the null value. Check that there
is exactly one such row.

Except where some other check is specified, after execution of
each SQL statement check that the value returned in SQLSTATE
indicates successful completion.

If any of the checks failed record a verdict of 'fail',
otherwise record a verdict of 'pass'.


(Modified  13 July 1995)

CTS5 SQL2 Test Purpose 112: Feature #46

IDENTIFICATION
     TEST7047, XTS747

DESCRIPTION
     Presence of ASCII_FULL in CHARACTER_SETS view

REFERENCES
     21.2.18   --   CHARACTER_SETS view
     21.3.23   --   CHARACTER_SETS base table
      F#46  --  Named Character sets
      F#1  --  Dynamic SQL
      F#2  --  Basic information schema

TEST PURPOSE
To determine that the INFORMATION_SCHEMA.CHARACTER_SETS view
is accessible  to a user and it contains a row that describes
the character set ASCII_FULL defined in FIPS 127-2.

NOGO
     None

TEST SPECIFICATION
Use Dynamic SQL with an <execute immediate statement> and
execute a <select statement: single row> accessing  the
CHARACTER_SETS view from the Information Schema and specifying
in its <search condition> that the columns
CHARACTER_SET_SCHEMA, CHARACTER_SET_NAME and
NUMBER_OF_CHARACTERS contain the values 'INFORMATION_SCHEMA',
'ASCII_FULL' and 256, respectively, and that none of the
columns COLLATE_CATALOG, COLLATE_SCHEMA and COLLATE_NAME
contain(s) the null value.Check that there is exactly one such
row present.

Except where a check for some other vlue is specified or
implied, after execution of each SQL statement check that the
value returned in SQLSTATE indicates successful completion.

If any of the checks failed record a verdict of 'fail'
otherwise record a verdict of 'pass'.

CTS5 SQL2 Test Purpose 113: Feature #46

IDENTIFICATION
     TEST7068, XTS768
DESCRIPTION:
     Presence of SQL_TEXT in CHARACTER_SETS view

REFERENCES
     21.2.18  --  CHARACTER_SETS view
     21.3.23  --  CHARACTER_SETS base table
     21.3.23 DE.5
     5.1  -- <SQL terminal character>
     4.2 -- Character strings
      F#46  --  Named character sets
      F#2  --  Basic information schema

TEST PURPOSE
To determine that the CHARACTER_SETS view in the Information
Schema is accessible to a user and that it contains exactly
one row that describes the character set
INFORMATION_SCHEMA.SQL_TEXT.

NOGO
     None.

TEST SPECIFICATION
Use a <select statement: single row> with a <set function
specification> of COUNT (*) as <select list> to determine the
number of rows in the view INFORMATION_SCHEMA.CHARACTER_SETS
where the values in the columns CHARACTER_SET_NAME and
CHARACTER_SET_SCHEMA are 'SQL_TEXT' and 'INFORMATION_SCHEMA,'
respectively. Check that the value returned is one.

Use a <select statement: single row> to retrieve all columns
of the row in the view INFORMATION_SCHEMA.CHARACTER_SETS where
the values in the columns CHARACTER_SET_NAME and
CHARACTER_SET_SCHEMA are 'SQL_TEXT' and 'INFORMATION_SCHEMA,'
respectively. Check that the values in columns
DEFAULT_COLLATE_SCHEMA and DEFAULT_COLLATE_NAME are
'INFORMATION_SCHEMA' and 'SQL_TEXT', respectively, that the
values in columns CHARACTER_SET_CATALOG and
DEFAULT_COLLATE_CATALOG are non-null, and that the value in
column NUMBER_OF_CHARACTERS is not less than 83.

After each execution of an SQL statement, check that the value
returned in SQLSTATE indicates successful completion.

If any of the checks failed record a verdict of 'fail',
otherwise record a verdict of 'pass'.

(Modified 29 June 1995)


CTS5 SQL2 Test Purpose 114: Feature #46

IDENTIFICATION
     TEST7069, XTS769

DESCRIPTION
     <Character set specification> of LATIN1 in <literal>

REFERENCES
     10.4  --  Character set specification.
     10.4 LR.2a  --  Raised. Entry SQL restriction which
prohibits the specification of character sets.
     5.3  --  <Literal>
     5.3 SR.6a
     5.3 SR.6b
     5.3 SR.7
     5.3 LR.2e  --  Raised. Entry SQL restriction which
prohibits the specification of character sets in literals.
     F#46  -- Named character sets
     F#6  --  VARCHAR data type

TEST PURPOSE
To determine that the character set LATIN1 is accessible to a
user and it can be used in explicit <character set
specification>s in <literal>s.

NOGO
     None

TEST SPECIFICATION
Use a table TABLATIN1 consisting of four columns, COL1, COL2,
COL3, COL4, with <data type>s  CHARACTER, CHAR VARYING,
VARCHAR, NUMERIC(5), respectively, with each of the character
data types specified with an explicit <character set
specification> of LATIN1. The table must be populated with at
least five rows, such that the values in column COL4 are all
different, and identify the rows of the table, there is a
value that occurs only once in column COL1, there is a value
that occurs exactly twice in column COL2, and there is a value
that occurs exactly three times in column COL3.

Use a <select statement: single row> to retrieve from table
TABLATIN1 the row where the value in column COL1 is equal to a
value specified as a <literal> specified with an explicit
<character set specification> of LATIN1, where that value
occurs once in the column. Check that the expected row is
returned with anticipated contents in the other columns.

Use a <select statement: single row> with a COUNT <set
function specification> to determine the number of rows in
TABLATIN1 in which the value in column COL2 is equal to a
<literal> specified with an explicit <character set
specification> of the LATIN1, where that value occurs twice in
the column. Check that the value two is returned.

Use a cursor ordered on column COL4 to retrieve the rows of
table TABLATIN1 in which the value in column COL3 is equal to
a <literal> specified with an explicit <character set
specification> of the LATIN1, where that value occurs exactly
three times in the column. Open the cursor and fetch all rows.
Check that exactly three rows were returned, and that they
were returned in the anticipated order and with the
anticipated contents.

After each execution of an SQL statement, check that the value
returned in SQLSTATE indicates successful completion.

If any of the checks failed record a verdict of 'fail',
otherwise record a verdict of 'pass'.

(Edited 30 June 1995)

CTS5 SQL2 Test Purpose 115: Feature #46

IDENTIFICATION
     TEST7070, XTS770

DESCRIPTION
     <Character set specification> of SQL_CHARACTER in an
<identifier>

REFERENCES
     10.4  --  Character set specification
     10.4 LR.2a  --  Raised. Entry SQL restriction which
prohibits the specification of character sets.
     5.4  --  <Names and identifiers>.
     5.4 SR.2a
     5.4 LR.2b --  Raised. Entry SQL restriction which
prohibits the specification of character sets in identifiers
     F#46  --  Named character sets
     F#3  --  Basic Schema manipulation

TEST PURPOSE
To determine that the SQL_CHARACTER character set is available
in an implementation, and that it can be specified in an
explicit <character set specification> in an <identifier>.

NOGO
     None

TEST SPECIFICATION
Under the current schema create a table, TA, with two columns,
TA1 of numeric data type and TA2 of character string data
type. For both columns, specify a <character set
specification> of SQL_CHARACTER in the <identifier> that names
the column

Commit the table creation of table TA.

Insert three rows into the table, with different values in
column TA1 of each row.

Use an cursor ordered on TA1 to retrieve the rows of table TA.

Check that the three rows are returned in the correct order
and with the correct contents.

After each execution of an SQL statement, check that the value
returned in SQLSTATE indicates successful completion.

If any of the checks failed record a verdict of 'fail'
otherwise record a verdict of 'pass'.



CTS5 SQL2 Test Purpose 116: Feature #46

IDENTIFICATION
     TEST7071, XTS771

DESCRIPTION
     CHARACTER SET ASCII_GRAPHIC in <data type>

REFERENCES
     10.4  --  Character set specification.
     10.4 LR.2a  --  Raised. Entry SQL restriction which
prohibits the specification of character sets.
     6.1  --  <Data type>
     6.1 SR.10
     6.1 GR.1
               6.1 LR.2a  --  Raised. Entry SQL restriction
               which prohibits the specification of VARYING or
               VARCHAR in a <character string type>
               6.1 LR.2c --   Raised. Entry SQL restriction
               which prohibits the specification of CHARACTER
               SET in a <data type>
     F#46  --  Named character sets
     F#6  --  VARCHAR data type
     F#3  --  Basic Schema manipulation

TEST PURPOSE
To determine that the ASCII_GRAPHIC character set is available
in an implementation and can be specified explicitly in a
<character set specification> in a <data type>.

NOGO
     None

TEST SPECIFICATION
Create a table T1 with columns num1 of numeric data type, str1
of data type CHAR and str2 of data type VARCHAR. Declare an
explicit character set specification of  ASCII_GRAPHIC for
each of the character type columns. Declare num1 as primary
key so that the rows of the table can be distinguished by the
contents stored in that column.

Commit the creation of table T1.

Populate T1 with three rows.

Use a <select statement: single row> and a <set function
specification> with COUNT(*) to count the rows in which the
value in column str1 is equal to a <literal> specified
explicitly with a <character set specification> of
ASCII_GRAPHIC, where that value occurs once in the column.

 Check that the result returned by COUNT equals one.

Use an cursor ordered on num1 to retrieve all the rows of T1.
Check that rows are returned with the anticipated order and
contents.

After each execution of an SQL statement check that the value
returned in SQLSTATE indicates successful completion.

If any of the checks failed record a verdict of 'fail',
otherwise record a verdict of 'pass'.

Restore the database in its original state by using a <drop
table statement> with T1 as <table name> and CASCADE <drop
behaviour>.

CTS5 SQL2 Test Purpose 117: Feature #47

IDENTIFICATION
     TEST7530, YTS796

DESCRIPTION
     <scalar subquery> as first operand in <comp. predicate>

REFERENCES
     6.11 LR2e
     7.11  --  <scalar  subquery>, <row subquery>  and  <table
     subquery>
     8.2 -- <comparison predicate>
     F#47 -- Scalar subquery values

TEST PURPOSE
To  determine that a <scalar subquery> may be specified  as  a
<value expression> in the first <row value constructor>  of  a
<comparison predicate>.

NOGO
     None.

TEST SPECIFICATION
Create a <select statement: single row> that has a <comparison
predicate>,   CP,  as  the  <where  clause>  in   its   <table
expression>. Let the right hand side of CP be a reference to a
column  of  the table referenced in the <from clause>  of  the
<table  expression>.  Let  the <comp  op>  of  CP  be  <equals
operator>. Let the left hand side of CP be a <scalar subquery>
that  selects  a  value  from a column of  some  other  table,
depending on the value of a parameter.

Execute  the  <select statement: single row> with a  parameter
value that should cause the result of the <scalar subquery> to
be  a  single value that in turn causes the <select statement:
single row> to return a single row. Check that a single row is
returned and that it is the row that was expected.

Execute  the  <select statement: single row> with a  parameter
value that should cause the result of the <scalar subquery> to
be  more than one value. Check that an exception condition  is
raised: cardinality violation.

If  either  check  failed, record a fail, otherwise  record  a
pass.



CTS5 SQL2 Test Purpose 118: Feature #47

IDENTIFICATION
     TEST7558, YTS797

DESCRIPTION
     <scalar subquery> in SET of searched update

REFERENCES
     6.11 LR2e -- restriction lifted
     7.11  --  <scalar  subquery>, <row subquery>  and  <table
     subquery>
     13.10 F -- <update statement: searched>
     13.9 F4 -- <update source>
     F#47 -- Scalar subquery values

TEST PURPOSE
To  determine that when a <scalar subquery> is specified in  a
<value  expression>  in  an  <update  source>  in  an  <update
statement: searched>, then the value of that <scalar subquery>
is used in evaluation of the <value expression>.

NOGO
     None.

TEST SPECIFICATION
Explicit  column names and table names are used here only  for
purposes of reference within this Test Specification, and  are
not  intended  to  constrain  the  names  that  are  used   in
implementations of this specification.

Let  TT be a table with columns, A and B, populated in such  a
way  that  the rows of the table may be distinguished  by  the
values in column A.

Let  TU be a table with a column D, that has a data type  that
is assignable to the data type of column B of table TT, and  a
column E that has a data type that is comparable with the data
type  of  column A of table TT. Let table TU be  populated  in
such  a  way that where column E in table TU contains a  value
that  is  equal to the value in column A in some row in  table
TT, column D in table TU contains a known value. Let there  be
no more than one value in column A of table TT for which there
are  multiple rows in table TU where column E has that  value.
Let  the  values in column D of table TU in the rows in  which
column E contains a value equal to some value in column  A  of
table  TT be different. Let there be at least one row in table
TT for which there is no corresponding row in table TU.

Execute an <update statement: searched> that updates column  B
of  table TT in all rows where the value in column A is  equal
to  some  value  in  column E of table TU, where  the  <update
source> for column B specifies a <value expression> that is  a
<scalar subquery> that evaluates to the value in column  D  of
the  row  in which column E contains a value that is equal  to
the  value  in column A of the row in table TT that  is  being
updated.  Since there are rows in table TU that  will  produce
multiple values for some row of table TT, the execution should
be  unsuccessful and no rows in table TT should  be  modified.
Check  that the value returned in SQLSTATE indicates  that  an
exception condition has been raised: cardinality violation.

Check that the content of table TT has not been modified.

Terminate the transaction with ROLLBACK.

Execute  another  <update statement: searched>,  identical  to
the  previous one except that the rows of TT for  which  there
are  multiple corresponding rows in table TU are excluded from
the update. The update should be successful.

Check  that  in those rows of table TT for which  there  is  a
single matching row in table TU the value in column B has been
replaced  by the value from column D of the matching  row;  in
those  rows  which were eliminated from the update because  of
multiple matching rows the values in column B has not changed;
and  in  those rows in table TT for which there is no matching
row in table TU the value in column B is the null value.

Except  where  other  checks on status values  are  specified,
check  after execution of every SQL statement that  the  value
returned in SQLSTATE indicates successful completion.

If  any  check  fails, record a verdict of  'fail',  otherwise
record a verdict of 'pass'.



CTS5 SQL2 Test Purpose 119: Feature #45

IDENTIFICATION
     TEST7559, YTS798

DESCRIPTION
     <scalar subquery> in <select list> of single-row select

REFERENCES
     6.11 LR2e -- <value expression>, restriction lifted
     7.11  --  <scalar  subquery>, <row subquery>  and  <table
     subquery>
     13.10 F -- <select statement: single row>
     F#47 -- Scalar subquery values


TEST PURPOSE
To  determine that when a <scalar subquery> is specified in  a
<value   expression>  in  the  <select  list>  of  a   <select
statement:  single  row>,  then  the  value  of  that  <scalar
subquery> is used in evaluation of the <value expression>.

NOGO:
     None.

TEST SPECIFICATION
Explicit  column names and table names are used here only  for
purposes of reference within this Test Specification, and  are
not  intended  to  constrain  the  names  that  are  used   in
implementations of this specification.

Let  TT be a table with columns, A and B, populated in such  a
way  that  the rows of the table may be distinguished  by  the
values in column A.

Let  TU be a table with a column D, that has a data type  that
is assignable to the data type of column B of table TT, and  a
column E that has a data type that is comparable with the data
type  of  column A of table TT. Let table TU be  populated  in
such  a  way that where column E in table TU contains a  value
that  is  equal to the value in column A in some row in  table
TT, column D in table TU contains a known value. Let there  be
no more than one value in column A of table TT for which there
are  multiple rows in table TU where column E has that  value.
Let  the  values in column D of table TU in the rows in  which
column E contains a value equal to some value in column  A  of
table  TT be different. Let there be at least one row in table
TT for which there is no corresponding row in table TU.

Execute a <select statement: single row> that specifies column
A of table TT as one <select sublist> and a <value expression>
consisting of a <scalar subquery> as another <select sublist>,
and a <table expression> that evaluate to the row in table  TT
that  has multiple corresponding rows in table TU. The <scalar
subquery>  should select column D from those rows of table  TU
that  correspond to the selected row from table TT. Check that
the  execution of the statement is unsuccessful, with a  value
returned  in  SQLSTATE that indicates an exception  condition:
cardinality violation.

Execute a <select statement: single row> that is identical  to
the  previous  statement,  with the  exception  that  the  row
selected from table TT has a unique corresponding row in table
TU. Check that the values returned are the value from column A
of  the selected row of table TT, and the value from column  D
of the corresponding row in table TU.

Execute a <select statement: single row> that is identical  to
the  first statement, with the exception that the row selected
from table TT has no corresponding row in table TU. Check that
the  values  returned  are the value  from  column  A  of  the
selected row of table TT, and the null value.

Except  where  other  checks on status values  are  specified,
check  after execution of every SQL statement that  the  value
returned in SQLSTATE indicates successful completion.

If  any  check  fails, record a verdict of  'fail',  otherwise
record a verdict of 'pass'.



CTS5 SQL2 Test Purpose 120: Feature #48

IDENTIFICATION
     TEST7531, YTS799

DESCRIPTION
     <subquery> as <row value constructor> in <null predicate>

REFERENCES
     8.6 GR2 -- <null predicate> - IS NULL
     8.6 GR3 -- <null predicate> - IS  NOT NULL
     7.11  --  <scalar  subquery>, <row subquery>  and  <table
     subquery>
     7.1 -- <row value constructor>
     F#48 -- Expanded null predicate

TEST PURPOSE
To determine that when a <scalar subquery> or a <row subquery>
is  specified  as  the  <row value constructor>  in   a  <null
predicate>,  then  the  nullity  or  non-nullity  of  the  row
elements  is used correctly in determination of the  value  of
the <null predicate>.

NOGO:
     None.

TEST SPECIFICATION
Explicit  column names and table names are used here only  for
purposes of reference within this Test Specification, and  are
not  intended  to  constrain  the  names  that  are  used   in
implementations of this specification.

Let TT be a table with columns, TTA, TTB and TTC, populated in
such a way that the rows of the table may be distinguished  by
the  values  in column TTA; columns TTB and TTC  each  contain
some  null  and  some non-null values; and  for  each  of  the
possible combinations (non-null, non-null), (non-null,  null),
(null,  non-null)  and (null, null) in columns  TTB  and  TTC,
there is at least one row in which that combination occurs.

Let  TU  be a table with a columns TUD and TUE, such that  the
data  types  of  column TUE and column TTA  of  table  TT  are
comparable. Let table TU be populated in such a way that there
is  at  most  one row in table TU where column TUE contains  a
value  equal to any given value from column TTA in  table  TT,
and  where  column TUE in table TU contains a  value  that  is
equal  to  the  value in column TTA in some row in  table  TT,
column  TUD  in table TU contains a known value, and  some  of
these values are the null value.

Declare a cursor CRA with a <cursor specification>, CSA,  that
is a <query specification> that specifies columns TTA, TTB and
TTC  of  table TT as <select list>. The <where clause> of  CSA
shall  contain a <null predicate> that specifies NULL  and  in
which the <row value constructor> is a <scalar subquery>  that
selects the value from column TUD of table TU in the row where
the value in column TUE is equal to the value in column TTA of
table TA.

Fetch  all rows of cursor CRA, and check that they consist  of
exactly  those  rows  from table TT  for  which  there  is  no
corresponding row in table TU in which the value in column TUD
is not the null value.

Declare a second cursor, CRB, that is identical to cursor CRA,
except that NOT NULL is specified in place of NULL.

Fetch  all rows of cursor CRB, and check that they consist  of
exactly  those  rows  from  table TT  for  which  there  is  a
corresponding row in table TU in which the value in column TUD
is not the null value.

Execute a <select statement: single row> that specifies  COUNT
(*)  as  <select list> and a <table expression> that specifies
SELECT  *  FROM  TT WHERE (TTB, TTC) IS NULL. Check  that  the
value  returned is the number of rows in table  TT  where  the
value  in column TTB is null, the value in column TTC is null,
or the value in both columns is null.

Execute a <select statement: single row> that specifies  COUNT
(*)  as  <select list> and a <table expression> that specifies
SELECT * FROM TT WHERE (TTB, TTC) IS NOT NULL. Check that  the
value  returned is the number of rows in table  TT  where  the
values in columns TTB and column TTC are both non-null.
Execute a <select statement: single row> that specifies  COUNT
(*)  as  <select list> and a <table expression> that specifies
SELECT * FROM TT WHERE NOT (TTB, TTC) IS NULL. Check that  the
value  returned  is the number of rows in table  TT  where  at
least one of the values in columns TTB and TTC is non-null.

Check  after execution of every SQL statement that  the  value
returned in SQLSTATE indicates successful completion.

If  any  check  fails, record a verdict of  'fail',  otherwise
record a verdict of 'pass'.



CTS5 SQL2 Test Purpose 121: Feature #48

IDENTIFICATION
     TEST7532, YTS800

DESCRIPTION
     <null predicate> with <interval value expression> as <row
     value constructor>

REFERENCES
     8.6 GR2 -- <null predicate> - IS NULL
     8.6 GR3 -- <null predicate> - IS  NOT NULL
     6.15 -- <interval value expression>
     F#48 -- Expanded null predicate
     F#5 -- DATETIME data types

TEST PURPOSE
To  determine  that  when an <interval  value  expression>  is
specified  as  the  <row  value  constructor>  in    a   <null
predicate>,  then the nullity or non-nullity of the  <interval
value  expression> is used correctly in determination  of  the
value of the <null predicate>.

NOGO
     None.

TEST SPECIFICATION
Explicit  column names and table names are used here only  for
purposes of reference within this Test Specification, and  are
not  intended  to  constrain  the  names  that  are  used   in
implementations of this specification.

Let  TT be a table with columns TTA, with a numeric data type,
TTB,  with  a data type of interval, and TTC with a data  type
that is exact numeric with scale zero. Let TT be populated  in
such a way that the rows of the table may be distinguished  by
the  values  in  column TTA, and  columns  TTB  and  TTC  each
contain  some null and some non-null values; and for  each  of
the  possible  combinations (non-null,  non-null),  (non-null,
null),  (null, non-null) and (null, null), there is  at  least
one  row  in which that combination occurs in columns TTB  and
TTC.

Declare a cursor CRA with a <cursor specification>, CSA,  that
is  a <query specification> that specifies column TTA of table
TT as <select list>. The <where clause> of CSA shall contain a
<null  predicate> that specifies NULL and in  which  the  <row
value  constructor> specifies an <interval  value  expression>
that is TTB+TTC.

Fetch  all  rows of cursor CRA, and check that  they  identify
exactly  those rows from table TT for which either column  TTB
or column TTC, or both, contains the null value.

Execute a <select statement: single row> that specifies  COUNT
(*)  as  <select list> and a <table expression> that specifies
SELECT * FROM TT WHERE NOT TTB+TTC IS NOT NULL. Check that the
value  returned is the number of rows in table  TT  where  the
value in one or both of columns TTB and TTC is null.

Check  after execution of every SQL statement that  the  value
returned in SQLSTATE indicates successful completion.

If  any  check  fails, record a verdict of  'fail',  otherwise
record a verdict of 'pass'.



CTS5 SQL2 Test Purpose 122: Feature #48

IDENTIFICATION
     TEST7533, YTS801

DESCRIPTION
     <null predicate> with NULL as <row value constructor>

REFERENCES
     8.6 GR2 -- <null predicate> - IS NULL
     8.6 GR3 -- <null predicate> - IS  NOT NULL
     13.5 GR2b -- <select statement: single row>
     7.1 F4 -- <null specification>
     13.5 GR2b -- <select statement: single row>
     F#48 -- Expanded null predicate

     
TEST PURPOSE
To  determine that when a <null specification> is specified as
a   <row   value  constructor  element>  in  the  <row   value
constructor>  in a <null predicate>, then the nullity  of  the
row  is  used correctly in determination of the value  of  the
<null predicate>.

NOGO:
     None.

TEST SPECIFICATION
Note  that  LR  1a of 7.1, <row value constructor>,  specifies
that  in  Intermediate  SQL a <row value  constructor>  simply
contained  in a <null predicate> shall not contain  more  than
one  <row  value  constructor element>. Therefore  it  is  not
possible, for the purposes of this test, to combine the  <null
specification> with any other <row value constructor  element>
in the <row value constructor> of the <null predicate>.

Execute a <select statement: single row> that specifies  COUNT
(*)  as  <select  list>  and  NULL  IS  NULL  as  the  <search
condition>  in the <where clause> to determine the  number  of
rows  in  some  table. Check that the value  returned  is  the
number of rows in the table.

Execute  a  <select statement: single row>  that  attempts  to
retrieve a row from some table and specifies NULL IS NOT  NULL
as  the  <search condition> in the <where clause>. Check  that
the  value  returned  in  SQLSTATE  indicates  the  completion
condition:  no data, and that no SQL-data values are  assigned
to the targets identified in the <select target list>.

Declare a cursor on some table, with NOT NULL IS NOT NULL  AND
<comparison predicate> as the <search condition> of the <where
clause>  of  the <table expression> of the <query expression>.
Open  the  cursor  and  fetch all rows. Check  that  the  rows
returned are those that satisfy the <comparison predicate>.

Except  where  other checks are specified above,  check  after
execution  of every SQL statement that the value  returned  in
SQLSTATE indicates successful completion.

If  any  check  fails, record a verdict of  'fail',  otherwise
record a verdict of 'pass'.



CTS5 SQL2 Test Purpose 123: Feature #48

IDENTIFICATION
     TEST7569, YTS812

DESCRIPTION
     <null   predicate>  with  concatenation  in   <row  value
     constructor>

REFERENCES
     8.6 GR2 -- <null predicate> - IS NULL
     8.6 GR3 -- <null predicate> - IS  NOT NULL
     6.13  GR2  --  <string value expression>
     13.5 GR2b -- <select statement: single row>
     F#48 -- Expanded null predicate

TEST PURPOSE
To  determine that when the <row value constructor> in a <null
predicate>  contains a single <row value constructor  element>
and that <row value constructor element> contains a <character
value  expression> that contains a <concatenation>,  then  the
<row  value constructor>  is determined to be null if and only
if some <character factor> is null.

NOGO:
     None.

TEST SPECIFICATION
Explicit  table names, column names and cursor name  are  used
only for reference within this Test Specification, and are not
intended  to constrain the names used in an implementation  of
this specification.

Let  TA be a table with columns that include TA1, TA2 and  TA3
with  data  types  that  are numeric, fixed  length  character
string and variable length character string, respectively, and
values in TA1 are required to be unique.

Populate  TA  such that column TA2 contains  one  null  value,
column  TA2 contains one null value and one zero-length value,
both in rows where the value in TA2 is non-null, and there are
some rows where there are no null or zero-length values.

Execute a <select statement: single row> that specifies:
      COUNT (*) as <select list>;
     FROM TA as <from clause>; and
       TA2 || TA3 IS NOT NULL as the <search condition> in the
<where clause>.

  Check that the value returned is two less than the number of
rows in TA.

Declare  an  ordered cursor CR that specifies  column  TA1  of
table TA as the <select list> and
     TA3 || TA2 IS NULL
as the <search condition> in its <query specification>.

Open CR and fetch all rows. Check that the cursor contains two
rows  and that the values returned identify the rows in  which
TA2 or TA3 contains a null value.

Except  where  other checks are specified above,  check  after
execution  of every SQL statement that the value  returned  in
SQLSTATE indicates successful completion.

If  any  check  fails, record a verdict of  'fail',  otherwise
record a verdict of 'pass'.


CTS5 SQL2 Test Purpose 124: Feature #48

IDENTIFICATION
     TEST7570, YTS813

DESCRIPTION
     <null predicate> with <numeric value expression> in  <row
     value constructor>

REFERENCES
     8.6 GR2 -- <null predicate> - IS NULL
     8.6 GR3 -- <null predicate> - IS  NOT NULL
     6.12  GR1  --  <numeric value expression>
       6.2   GR7   --   <value  specification>   and   <target
specification>
     13.5 GR2b -- <select statement: single row>
     F#48 -- Expanded null predicate

     
TEST PURPOSE
To  determine that when the <row value constructor> in a <null
predicate>  contains a single <row value constructor  element>
and  that  <row value constructor element> contains a <numeric
value  expression> that is not a <column reference>, then  the
<row  value constructor>  is determined to be null if and only
if the <numeric value expression> is null.

NOGO
     None

TEST SPECIFICATION
Explicit  table names, column names and cursor name  are  used
only for reference within this Test Specification, and are not
intended  to constrain the names used in an implementation  of
this specification.

Let  TA be a table with columns that include TA1, TA2 and  TA3
with numeric data types. Let column TA1 be the primary key  of
TA.

Populate  TA  such that columns TA2 and TA3 each  contain  one
null  value, in different rows, and there are some rows  where
neither column TA2 nor column TA3 contains the null value.

Execute a <select statement: single row> that specifies:
      COUNT (*) as <select list>;
     FROM TA as <from clause>; and
       TA2 + TA3 IS NOT NULL as the <search condition> in  the
<where clause>.

  Check that the value returned is two less than the number of
rows in TA.

Declare  an  ordered cursor CR that specifies  column  TA1  of
table TA as the <select list> and
     TA3 - TA2 IS NULL
as the <search condition> in its <query specification>.

Open CR and fetch all rows. Check that the cursor contains two
rows  and that the values returned identify the rows in  which
TA2 or TA3 contains a null value.

Set a negative value in integer host variable hind. Execute an
<update  statement: searched> that updates table  TA,  setting
column  TA2  to  a value that does not exist  in  that  column
before the statement is executed in all rows where
     TA3 * :hv INDICATOR :hind IS NOT NULL
is true. Check that no values in the table are changed.

Set a positive value in integer host variable hind. Execute an
<update  statement: searched> that updates table  TA,  setting
column  TA2  to  a value that does not exist  in  that  column
before the statement is executed in all rows where
     TA3 * :hv INDICATOR :hind IS NOT NULL
is  true. Check that all values in column TA3, except  in  the
row  that contains the null value, have been replaced  by  the
value  specified in the <update statement: searched>. A simple
way  to  carry out this check is to count the number  of  rows
where column TA3 contains the new value, with a separate check
that the null value still exists in its original row.

Except  where  other checks are specified above,  check  after
execution  of every SQL statement that the value  returned  in
SQLSTATE indicates successful completion.

If  any  check  fails, record a verdict of  'fail',  otherwise
record a verdict of 'pass'.


CTS5 SQL2 Test Purpose 125: Feature #49

IDENTIFICATION:
     TEST7048, XTS748

DESCRIPTION:
       Named   constraint  in  column  definition  in   schema
definition.

REFERENCES:
     11.1 -- <schema definition>
     11.3 -- <table definition>
     11.4 -- <column definition>
     11.4 SR.9
               11.4  LR.2c  --  Raised. Entry SQL  restriction
               which    prohibited   the   specification    of
               <constraint name definition>.
      10.6  --  <constraint name definition>  and  <constraint
attributes>
     10.6 SR.1
     10.6 SR.2
               10.6  LR.2a  --  Raised. Entry SQL  restriction
               which    prohibited   the   specification    of
               <constraint name definition>.
     11.7 -- <unique constraint definition>
     11.8 -- <referential constraint definition>
     11.9 -- <check constraint definition>
     F#2 --   Basic information schema.
     F#1 --   Dynamic SQL.
     F#3 --   Basic schema manipulation.
     F#33 -- Constraint tables.
     F#21 -- Schema definition
     F#49 -- Constraint management.

TEST PURPOSE.
To  determine  that  a  <constraint name>  can  be  explicitly
specified  in  a  <constraint name definition>  in  a  <column
constrain  definition> in a <column definition>  in  a  <table
definition> in a <schema definition>.

NOGO : none.

TEST SPECIFICATION.
Ensure  that there is no schema in the current catalog with  a
schema  name  equal to TESTCON and no schema  in  the  current
catalog with a schema name equal to TESTCON2.

Create  a  schema with schema name TESTCON,  which contains  a
table  with  three columns, each of which has a numeric  <data
type>s.  In each of the three <column definition>s, specify  a
<column  constraint definition> which specifies a  <constraint
name definition> and  a <column constraint> of, respectively:
     NOT NULL,
     UNIQUE, and
     CHECK (<column name>  > 0).

Ensure  that each <constraint name> is different from the  two
others.

Commit the creation of the schema and table.

Use   a   cursor   and  determine  through   access   to   the
TABLE_CONSTRAINTS view in the Information Schema all the  rows
corresponding  to schema TESTCON. Check that there  are  three
rows  and  that the values in the  CONSTRAINT_NAME column  the
<constraint name>s defined above.

Use  Dynamic SQL with a <preparable SQL schema statement>  and
execute  an  <execute immediate statement> creating  a  schema
with <schema name> TESTCON2, which contains a table with three
columns two of which have a  numeric <data type> and the third
a  character  string  <data type>. In each  of  these  <column
definition>s,  specify a <column constraint definition>  which
specifies  a  <constraint  name  definition>  and   a   column
constraint of, respectively:
     UNIQUE,
     CHECK(<column_name >  > 1000), and
     NOT NULL

Commit the creation of the schema and table.

Use   a   cursor   and  determine  through   access   to   the
TABLE_CONSTRAINTS view in the Information Schema all the  rows
that  describe  table constraints associated with  the  schema
TESTCON2  are present and that the CONSTRAINT_NAME  column  of
this  view contains the anticipated <constraint name>s defined
above.

After  execution of each SQL statement check  that  the  value
returned in SQLSTATE indicates successful completion.

If  any  of  the  checks failed record  a  verdict  of  'fail'
otherwise record a verdict of 'pass'.

All  the names used are for ease of description only, and  are
not  intended  to constrain the choice of names  in  the  test
program or in the database.

(16 March 1995)


CTS5 SQL2 Test Purpose 126: Feature #49

IDENTIFICATION:
     TEST7049, XTS749

DESCRIPTION:
     Named table constraint in table definition.

REFERENCES:
     11.3 --   <Table definition>.
     11.6 --   <Table constraint definition>.
     11.6 SR.1
     11.6 GR.2
               11.6  LR.2a  --  Raised. Entry SQL  restriction
               which  prohibits the use of a <constraint  name
               definition>.
      10.6  --    <Constraint name definition> and <constraint
attributes>.
     10.6 SR.1
     10.6 SR.2
               10.6  LR.2a  --  Raised. Entry SQL  restriction
               which  prohibits the use of a <constraint  name
               definition>.
     11.7 --   <Unique constraint definition>.
     11.8 --   <Referential constraint definition>.
     11.9 --   <Check constraint definition>.
     F#2  --   Basic information schema.
     F#3  --   Basic schema manipulation.
     F#33 --   Constraint tables.
     F#44 --   Constraint management.

TEST PURPOSE.
To  determine  that  a  <constraint name>  can  be  explicitly
specified  in  a  <table constraint definition>  in  a  <table
definition>.

NOGO: None.

TEST SPECIFICATION.
Ensure  that  there  is no table in the  current  schema  with
<table  name>  equal  to  TESTCON  and  no  constraints   with
<constraint name>s equal to CONSTR1, CONSTR2 and CONSTR3.

Create  a  table TESTCON with three columns of  numeric  <data
type>  and <column name>s COL1, COL2, and COL3. In the  <table
definition>   include   the   following   <table    constraint
definition>s:

     CONSTRAINT  CONSTR1
          PRIMARY KEY(COL1, COL2)
     CONSTRAINT  CONSTR2
          CHECK(COL2 > 0)
     CONSTRAINT  CONSTR3
          FOREIGN KEY(COL3) REFERENCES TAB(COL)

Where  TAB is the table name of a table in the current  schema
with  at least one column of numeric <data type> and a  column
name  COL  which  is  the  only  unique  column  of  a  unique
constraint of TAB.

Commit the creation of the table.

Use  a  cursor to check that all the rows associated with  the
table TESTCON are present in the view TABLE_CONSTRAINTS in the
Information  Schema,  and  that  the  CONSTRAINT_NAME   column
contains the anticipated <constraint name>s.

After  execution of each SQL statement check  that  the  value
returned in SQLSTATE indicates successful completion.

If  any  of  the  checks failed record a  verdict  of  'fail',
otherwise record a verdict of 'pass'.


(16 March 1995)


CTS5 SQL2 Test Purpose 127: Feature #49

IDENTIFICATION:
     TEST7050, XTS750

DESCRIPTION:
     Named  domain constraint

REFERENCES:
     11.21 -- <domain definition>
     11.21 SR.6a
     11.21 GR.5
     11.21 GR.6
      10.6  --  <constraint name definition>  and  <constraint
attributes>
     10.6 SR.1
     10.6 SR.2
               10.6  LR.2a   -- Raised. Entry SQL  restriction
               which  prohibits the use of a <constraint  name
               definition>.
     11.9 -- <check constraint definition>
     F#2  -- Basic information schema.
     F#3  -- Basic schema manipulation.
     F#25 -- Domain definition
     F#33 -- Constraint tables.
     F#44 -- Constraint management.


TEST PURPOSE.
To  determine  that  a  <constraint name>  can  be  explicitly
specified  in  a  <constraint name definition>  in  a  <domain
constraint > in a <domain definition>.

NOGO : none.

TEST SPECIFICATION.
Ensure  that  there  is no domain in the current  schema  with
<domain  name>  equal  to  TESTDOM  and  no  constraint   with
<constraint name> equal to DOMCONST.

Create  a domain, TESTCON, of numeric <data type> with <domain
constraint>:
     CONSTRAINT DOMCONST
          CHECK(VALUE > 0)

Use a cursor and retrieve from the DOMAIN_CONSTRAINTS view  in
the  Information Schema all the rows corresponding  to  domain
DOMCONST.  Check  that  one  row  is  returned  and  that  the
CONSTRAINT_NAME  column  contains  the  expected   <constraint
name>.

After  execution of each SQL statement check  that  the  value
returned in SQLSTATE indicates successful completion.

If  any  of  the  checks failed, record a verdict  of  'fail',
otherwise record a verdict of 'pass'.

All  the names used are for ease of description only, and  are
not  intended  to constrain the choice of names  in  the  test
program or in the database.


(16 March 1995)
(Additional reference added - 2 June 1995)


CTS5 SQL2 Test Purpose 128: Feature #49

IDENTIFICATION:
     TEST7051, XTS751

DESCRIPTION:
       Name   of   violated  column  constraint  returned   in
diagnostics

REFERENCES:
   18.1 -- <get diagnostics statement>
   18.1 LR  2a  --     Raised.  Entry  SQL  restriction  which
          prohibited the use of a <get diagnostics statement>.
   11.4 --  <column definition>.
   11.6 --  <table constraint definition>
   11.7 --  <unique constraint definition>.
   11.8 --  <referential constraint definition>.
   11.9 --  <check constraint definition>.
   F#12 --  Get diagnostics.
   F#30 --  Table operations.
   F#49   --  Constraint management.


TEST PURPOSE.
To  determine that when a column is associated with  a  <table
constraint  definition>,  then  an  attempt  to  violate  that
constraint by attempting to insert non-permissible  values  to
that  column is detected, and the name of the column  and  the
name  of  the constraint can be retrieved from the diagnostics
area by execution of a <get diagnostics statement>.

NOGO :  None.

TEST SPECIFICATION.
Use  a  table,  TAB2, from the standard schema which  contains
seven  columns, four of numeric <data type> and the  remaining
three  of  character  string <data type>  with  the  following
characteristics :

  col_num1 NUMERIC(5) PRIMARY KEY
  col_str1   VARCHAR(15) NOT NULL,
  col_str2   VARCHAR(10),
  col_num2 NUMERIC(5) CONSTRAINT constr_1 REFERENCES TAB2,
     col_str3     VARCHAR(25)   CONSTRAINT   constr_2   UNIQUE
(col_str1,col_str2),
  col_num3 NUMERIC(7,2),
  col_num4 NUMERIC(3) NOT NULL
       CONSTRAINT  FOREIGN  KEY constr_3  REFERENCES  TAB1  ON
DELETE CASCADE);

TAB1 is another table from the standard schema having a column
constrained as PRIMARY KEY of data type NUMERIC(3).

Insert  two  rows  in TAB2 ensuring that  none  of  the  above
constraints is violated.

Insert  a  row  in  table  TAB2 which  attempts  to  insert  a
duplicate  value  in the column that was associated  with  the
unique  specification. Use a <get diagnostics  statement>  and
check  that the values returned in the <condition information>
identify  the  unique  constraint  being  violated    in   the
CONSTRAINT_NAME  along with the column  name  (col_str3),  and
that the value returned in RETURNED_SQLSTATE indicates that an
integrity constraint violation has occurred.

Insert  two  more rows in the table attempting to violate  the
foreign  key constraint by inserting a non existing value  for
the  referenced column. Use a <get diagnostics  statement>  to
check  that the values returned in the <condition information>
identify   the  referential  constraint  name  being  violated
(constr_3)  and the referenced column name in the FOREIGN  key
constraint.  Check  also that the value  in  RETURNED_SQLSTATE
indicates that an integrity constraint violation has occurred.

Insert  one more row in the table attempting to insert in  the
column  associated  with  the check constraint  a  null  value
(col_str1).  Use a <get diagnostics statement> to  check  that
the  values  returned in the <condition information>  identify
the check constraint being violated, the name of the violating
column name and  that the value in RETURNED_SQLSTATE indicates
that an integrity constraint violation has occurred.

After  each  execution  of  an  SQL  statement,  except   <get
diagnostics  statement>,  check that  the  expected  value  is
returned in SQLSTATE.

If  any  of  the  checks failed record a  verdict  of  'fail',
otherwise record a verdict of 'pass'.

All  the names used are for ease of description only, and  are
not  intended  to constrain the choice of names  in  the  test
program or in the database.


(16 March 1995)


CTS5 SQL2 Test Purpose 129: Feature #50

IDENTIFICATION
     TEST7548, YTS802

DESCRIPTION
     Support of SQL_FEATURES table in documentation schema

REFERENCES
     FIPS15.1  --  SQL_FEATURES table
     F# 50 -- Documentation schema

TEST PURPOSE
To    determine   that   the   SQL_FEATURES   table   in   the
FIPS_DOCUMENTATION schema is accessible to a user and contains
a  row  for  each FIPS feature that describes the feature  and
indicates   whether   or   not  it   is   supported   by   the
implementation.

NOGO:
     None.

TEST SPECIFICATION
Create      a      cursor     based     on      the      table
FIPS_DOCUMENTATION.SQL_FEATURES, ordered on column FEATURE_ID.
Retrieve all rows of the cursor. Check that there is a row for
each of the 89 FIPS features. For each feature, check that the
FEATURE_NAME column contains the name assigned to the  feature
in  section  14  of FIPS 127-2. Check that the  CLASSIFICATION
column  contains  'TRANSITIONAL'  for  features  #1  to   #24,
'INTERMEDIATE'  for features #25 to #50, 'FULL'  for  features
#51 to #83, and 'RDA' for features #84 to #89.

Use  a  <select statement: single row> and COUNT (*) to  check
that      there     is     no     row     in     the     table
FIPS_DOCUMENTATION.SQL_FEATURES   where   column   IS_VERIFIED
contains 'YES' and column IS_SUPPORTED does not contain 'YES'.

Check  that  the column IS_VERIFIED contains 'YES' in  exactly
those rows that identify features for which the implementation
has  passed all tests in the conformance test suite that apply
to  that  feature. The determination of tests that  have  been
passed  is made by reference to the list of supported features
supplied as input to the test system test selection mechanism,
as  follows. Let TT be the table that contains the  identities
of  the FIPS features for which conformance claims are  to  be
tested,  and let TTA be the column of that table that contains
the identifying number of each of those features. Check, using
COUNT    (*),    that   for   each   row    in    the    table
FIPS_DOCUMENTATION.SQL_FEATURES   where   column   IS_VERIFIED
contains 'YES', there is a row in TT where the value in column
TTA   contains  the  value  in  column  FEATURE_ID  of   table
FIPS_DOCUMENTATION.SQL_FEATURES.

Except  where  other checks are specified above,  check  after
execution  of every SQL statement that the value  returned  in
SQLSTATE indicates successful completion.

If  any  check  fails, record a verdict of  'fail',  otherwise
record a verdict of 'pass'.



CTS5 SQL2 Test Purpose 130: Feature #50

IDENTIFICATION
     TEST7549
     TEST7549

DESCRIPTION
     Support of SQL_SIZING table in documentation schema

REFERENCES
     FIPS15.2  --  SQL_Sizing table
     F# 50 -- Documentation schema

TEST PURPOSE
To    determine   that   the   SQL_SIZING   table    in    the
FIPS_DOCUMENTATION schema is accessible to a user and contains
a row for each FIPS database construct defined in Section 16.6
of  FIPS  127-2,  identifying the  construct  and  giving  the
default  values  for Entry SQL and Intermediate  SQL  and  the
value   for   the   construct  that  is   supported   by   the
implementation.

NOGO
     None.

TEST SPECIFICATION
Create      a      cursor     based     on      the      table
FIPS_DOCUMENTATION.SQL_SIZING, ordered  on  column  SIZING_ID.
Retrieve all rows of the cursor. Check that there is a row for
each  of  the  89 items defined in section 16.6  of  FIPS  PUB
127-2.  For each item, check that the DESCRIPTION, ENTRY_VALUE
and  INTERMEDIATE_VALUE  columns  contain,  respectively,  the
description,  the Entry value and the Intermediate  value  for
that  item  defined  in section 16.6 of FIPS 127-2, with  each
asterisk converted to the null value.

Let TT be a table with columns of data types NUMERIC, DECIMAL,
INTEGER, SMALLINT, FLOAT, REAL and DOUBLE PRECISION. For  each
of  those columns, execute an <insert statement> that  inserts
into  TT  a row that contains the maximum value for that  data
type, derived from the value in the column VALUE_SUPPORTED  of
the  table  FIPS_DOCUMENTATION.SQL_SIZING for that data  type,
and  zero in all other columns.

Use  a  <select  statement: single row> and the SUM  aggregate
function  to retrieve the sum of the values in each column  of
table  TT. Check that, for each column, the value returned  is
the non-zero value that was stored in that column.

Except  where  other checks are specified above,  check  after
execution  of every SQL statement that the value  returned  in
SQLSTATE indicates successful completion.

If  any  check  fails, record a verdict of  'fail',  otherwise
record a verdict of 'pass'.
